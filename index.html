<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Store Manager Simulator</title>
    
    <!-- CSS Files -->
    
    
    
    
    
    
    
    
    
    
    
    
    
        <!-- Phase 5B: Staff Management CSS -->
    
    
    <!-- Phase 5C: Automation CSS -->
    
    
    <!-- Perchance Plugin Imports -->
    <script>
        generateImage = {import:text-to-image-plugin} // generates ai powered images        
        generatorStats = {import:generator-stats-plugin} //allows you to add a page view counter and get other stats about your generator        
        generateText = {import:ai-text-plugin} //generate text (stories, poems, etc) based on an instruction        
        date = {import:date-plugin} //manipulate dates, and output them in specific formats        
        favicon = {import:favicon-plugin} //allows you to change the browser tab icon for your generator        
        commentsPlugin = {import:comments-plugin} //allows you to embed a little comments/feedback section in your generator        
        fullscreenButton = {import:fullscreen-button-plugin} //fullscreen functionality        
        speak = {import:text-to-speech-plugin} //text to speech capabilit        
        literal = {import:literal-plugin} //¬†automatically put backslashes in front of curly/square brackets in some text        
        remember = {import:unsafe-rememberchange} //¬†allows you to save variables so they're not lost when the page is reloade        
        kv = {import:kv-plugin} //allows you to store data in a way that will remain accessible after page reload/close
        backgroundImage = {import:background-image-plugin} //allows you to easily set a background image for your generator

    </script>
    <script>
        // Map Perchance plugin globals to window so other systems can detect them
        (function exposePerchancePluginsToWindow(){
            try {
                if (typeof generateImage !== 'undefined' && !window.generateImage) window.generateImage = generateImage;
                if (typeof generateText !== 'undefined' && !window.generateText) window.generateText = generateText;
                if (typeof ai !== 'undefined' && !window.ai) window.ai = ai;
                if (typeof speak !== 'undefined' && !window.speak) window.speak = speak;
                if (typeof kv !== 'undefined' && !window.kv) window.kv = kv;
                if (typeof remember !== 'undefined' && !window.remember) window.remember = remember;
            } catch (e) {
                console.warn('‚ö†Ô∏è Plugin global exposure failed:', e);
            }
        })();
        // Also retry on DOMContentLoaded in case plugins attach later
        document.addEventListener('DOMContentLoaded', () => {
            try {
                if (typeof generateImage !== 'undefined') window.generateImage = window.generateImage || generateImage;
                if (typeof generateText !== 'undefined') window.generateText = window.generateText || generateText;
                if (typeof ai !== 'undefined') window.ai = window.ai || ai;
                if (typeof speak !== 'undefined') window.speak = window.speak || speak;
                if (typeof kv !== 'undefined') window.kv = window.kv || kv;
                if (typeof remember !== 'undefined') window.remember = window.remember || remember;
            } catch {}
        });
    </script>
    <style>

/* === src/styles/main.css === */
/* Main CSS - Store Manager Simulator */

/* CSS Reset and Base Styles */
* {
    margin: 0 !important;
    padding: 0 !important;
    box-sizing: border-box !important;
}

html, body {
    height: 100% !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
    background-color: #1a202c !important;
    color: #e2e8f0 !important;
    overflow: hidden !important;
}

/* NOTE: Do NOT globally hide all content; screens manage their own visibility */

/* Only show the active screen */
.screen {
    width: 100vw !important;
    height: 100vh !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    z-index: 100 !important;
    display: none !important;
}

.screen:not(.hidden) {
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
}

.screen.hidden {
    display: none !important;
}

/* Layout Classes */
.screen {
    width: 100vw !important;
    height: 100vh !important;
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    transition: opacity 0.3s ease;
    z-index: 100 !important;
}

.screen.hidden {
    opacity: 0 !important;
    pointer-events: none !important;
    display: none !important;
}

.screen:not(.hidden) {
    opacity: 1 !important;
    pointer-events: auto !important;
    display: block !important;
}

/* Setup Screen Styles */
#setup-screen {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
    color: white !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    z-index: 1000 !important;
}

.setup-container {
    background: rgba(255, 255, 255, 0.95) !important;
    color: #333 !important;
    border-radius: 20px !important;
    padding: 40px !important;
    max-width: 600px !important;
    width: 90% !important;
    box-shadow: 0 20px 40px rgba(0,0,0,0.3) !important;
    text-align: center !important;
}

.setup-container h1 {
    font-size: 2.5rem !important;
    margin-bottom: 20px !important;
    color: #667eea !important;
}

.setup-container h2 {
    font-size: 1.8rem !important;
    margin-bottom: 15px !important;
    color: #555 !important;
}

.setup-container p {
    font-size: 1.2rem !important;
    margin-bottom: 30px !important;
    line-height: 1.6 !important;
}

.setup-buttons {
    display: flex !important;
    gap: 20px !important;
    justify-content: center !important;
    flex-wrap: wrap !important;
}

.setup-button {
    background: #667eea !important;
    color: white !important;
    border: none !important;
    padding: 15px 30px !important;
    border-radius: 10px !important;
    font-size: 1.1rem !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3) !important;
}

.setup-button:hover {
    background: #5a67d8 !important;
    transform: translateY(-2px) !important;
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4) !important;
}

.setup-button.secondary {
    background: #718096 !important;
    box-shadow: 0 4px 15px rgba(113, 128, 150, 0.3) !important;
}

.setup-button.secondary:hover {
    background: #4a5568 !important;
    box-shadow: 0 6px 20px rgba(113, 128, 150, 0.4) !important;
}

.setup-phase {
    display: block !important;
}

.setup-phase.hidden {
    display: none !important;
}

.setup-navigation {
    border-top: 1px solid #e2e8f0 !important;
    padding-top: 20px !important;
    margin-top: 20px !important;
    display: none !important; /* Hide navigation by default */
}

.setup-navigation.show {
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
}

/* Additional visibility toggles for Perchance environment */
.setup-navigation.visible {
    display: block !important;
}

.setup-phase.active {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
}

/* Character Creation UI */
.cc-container {
    display: grid !important;
    grid-template-columns: 2fr 1fr !important;
    gap: 16px !important;
    align-items: start !important;
}
.cc-form { background: #ffffff !important; color: #1f2937 !important; border-radius: 12px !important; padding: 16px !important; box-shadow: 0 8px 20px rgba(0,0,0,0.08) !important; }
.cc-preview { background: #ffffff !important; color: #1f2937 !important; border-radius: 12px !important; padding: 16px !important; box-shadow: 0 8px 20px rgba(0,0,0,0.08) !important; min-height: 200px !important; }
.cc-section { margin-bottom: 16px !important; }
.cc-row { display: grid !important; grid-template-columns: repeat(3, 1fr) !important; gap: 12px !important; }
.cc-grid { display: grid !important; grid-template-columns: repeat(3, 1fr) !important; gap: 12px !important; }
.cc-field { display: flex !important; flex-direction: column !important; gap: 6px !important; }
.cc-field label { font-weight: 600 !important; color: #374151 !important; }
.cc-field input, .cc-field select, .cc-field textarea { padding: 8px 10px !important; border: 1px solid #e5e7eb !important; border-radius: 8px !important; background: #f9fafb !important; color: #111827 !important; }
.cc-chips { display: flex !important; flex-wrap: wrap !important; gap: 8px !important; margin-top: 8px !important; }
.cc-chip { padding: 6px 10px !important; background: #f3f4f6 !important; border: 1px solid #e5e7eb !important; border-radius: 9999px !important; cursor: pointer !important; user-select: none !important; }
.cc-chip.active { background: #e0e7ff !important; border-color: #6366f1 !important; color: #3730a3 !important; }
.cc-btn { background: #6366f1 !important; color: #fff !important; border: none !important; padding: 10px 16px !important; border-radius: 10px !important; cursor: pointer !important; }
.cc-btn.secondary { background: #e5e7eb !important; color: #111827 !important; }
.cc-nav { display: flex !important; justify-content: space-between !important; gap: 8px !important; margin-top: 12px !important; }
.cc-image { width: 100% !important; aspect-ratio: 1 / 1 !important; background: #f3f4f6 !important; border-radius: 12px !important; display: grid !important; place-items: center !important; color: #9ca3af !important; object-fit: cover !important; }
.cc-gallery { display: grid !important; grid-template-columns: repeat(2, 1fr) !important; gap: 12px !important; margin-top: 10px !important; }
.cc-thumb { width: 100% !important; border-radius: 8px !important; cursor: pointer !important; border: 2px solid transparent !important; }
.cc-thumb.selected { border-color: #6366f1 !important; }
/* Thumb wrapper and controls */
.cc-thumb-wrap { position: relative !important; }
.cc-regen-btn { position: absolute !important; right: 8px !important; bottom: 8px !important; width: 28px !important; height: 28px !important; border-radius: 50% !important; border: none !important; background: rgba(17,24,39,0.7) !important; color: #fff !important; cursor: pointer !important; display: flex !important; align-items: center !important; justify-content: center !important; font-size: 14px !important; }
.cc-regen-btn[disabled] { opacity: 0.5 !important; cursor: not-allowed !important; }
.cc-thumb-overlay { position: absolute !important; inset: 0 !important; background: rgba(0,0,0,0.35) !important; color: #fff !important; display: flex !important; align-items: center !important; justify-content: center !important; font-size: 12px !important; border-radius: 8px !important; }
.cc-status { margin-left: 10px !important; font-size: 12px !important; opacity: 0.9 !important; }

/* Welcome phase should not show navigation */
.setup-phase:first-child + * .setup-navigation {
    display: none !important;
}

/* Loading Screen - Should be visible initially */
#loading-screen {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
    z-index: 999 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    color: white !important;
}

#loading-screen.hidden {
    display: none !important;
}

.loading-content {
    text-align: center !important;
    color: white !important;
}

.loading-content h1 {
    font-size: 3rem !important;
    margin-bottom: 2rem !important;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3) !important;
}

.loading-spinner {
    width: 50px !important;
    height: 50px !important;
    border: 4px solid rgba(255,255,255,0.3) !important;
    border-top: 4px solid white !important;
    border-radius: 50% !important;
    animation: spin 1s linear infinite !important;
    margin: 2rem auto !important;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.view {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    transition: transform 0.3s ease;
    transform: translateX(100%);
}

.view.active {
    transform: translateX(0);
}

/* Loading Screen */
.loading-screen {
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
}

.loading-content {
    text-align: center;
    color: white;
}

.loading-content h1 {
    font-size: 3rem;
    margin-bottom: 2rem;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

.loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid rgba(255,255,255,0.3);
    border-top: 4px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 2rem auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Game Interface - Hidden by default */
#game-interface {
    display: none !important;
}

#game-interface:not(.hidden) {
    display: block !important;
}

/* Views within game interface */
.view {
    width: 100% !important;
    height: 100% !important;
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    display: none !important;
}

.view.active {
    display: block !important;
}

/* Utility Classes */
.flex {
    display: flex !important;
}

.flex-column {
    flex-direction: column !important;
}

.justify-center {
    justify-content: center !important;
}

.align-center {
    align-items: center !important;
}

.text-center {
    text-align: center !important;
}

.m-0 { margin: 0; }
.m-1 { margin: 0.5rem; }
.m-2 { margin: 1rem; }
.m-3 { margin: 1.5rem; }

.p-0 { padding: 0; }
.p-1 { padding: 0.5rem; }
.p-2 { padding: 1rem; }
.p-3 { padding: 1.5rem; }

.w-100 { width: 100%; }
.h-100 { height: 100%; }

.rounded { border-radius: 8px; }
.shadow { box-shadow: 0 2px 8px rgba(0,0,0,0.15); }

/* Typography */
h1 { font-size: 2.5rem; font-weight: 700; }
h2 { font-size: 2rem; font-weight: 600; }
h3 { font-size: 1.5rem; font-weight: 600; }
h4 { font-size: 1.25rem; font-weight: 500; }
h5 { font-size: 1rem; font-weight: 500; }

.text-sm { font-size: 0.875rem; }
.text-lg { font-size: 1.125rem; }
.text-xl { font-size: 1.25rem; }

/* States */
.disabled {
    opacity: 0.5;
    pointer-events: none;
}

.hidden {
    display: none !important;
}

.invisible {
    visibility: hidden;
}

/* Animations */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideInUp {
    from { transform: translateY(20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

@keyframes slideInDown {
    from { transform: translateY(-20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

.fade-in {
    animation: fadeIn 0.3s ease;
}

.slide-in-up {
    animation: slideInUp 0.3s ease;
}

.slide-in-down {
    animation: slideInDown 0.3s ease;
}

/* Scrollbars */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: var(--bg-secondary);
}

::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--text-secondary);
}

/* Focus Styles */
*:focus {
    outline: 2px solid var(--primary);
    outline-offset: 2px;
}

/* Media Queries */
@media (max-width: 768px) {
    html {
        font-size: 14px;
    }
    
    .loading-content h1 {
        font-size: 2rem;
    }
}

@media (max-width: 480px) {
    html {
        font-size: 12px;
    }
    
    .loading-content h1 {
        font-size: 1.5rem;
    }
}


/* === src/styles/automation.css === */
/* Phase 5C: Automation Interface Styling */

.automation-interface {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 15px;
    padding: 25px;
    color: white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    min-height: 600px;
}

.automation-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 2px solid rgba(255,255,255,0.2);
}

.automation-header h2 {
    margin: 0;
    font-size: 2em;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

.automation-status {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 1.1em;
}

.status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
}

.status-indicator.optimal {
    background: #10b981;
    box-shadow: 0 0 10px rgba(16, 185, 129, 0.6);
}

.status-indicator.good {
    background: #f59e0b;
    box-shadow: 0 0 10px rgba(245, 158, 11, 0.6);
}

.status-indicator.warning {
    background: #ef4444;
    box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);
}

.status-indicator.offline {
    background: #6b7280;
    box-shadow: 0 0 10px rgba(107, 114, 128, 0.6);
}

/* Navigation */
.automation-nav {
    display: flex;
    gap: 10px;
    margin-bottom: 25px;
    overflow-x: auto;
    padding: 5px;
}

.automation-tab {
    background: rgba(255,255,255,0.1);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 10px;
    padding: 12px 20px;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    white-space: nowrap;
    font-weight: 600;
}

.automation-tab:hover {
    background: rgba(255,255,255,0.2);
    transform: translateY(-2px);
}

.automation-tab.active {
    background: rgba(255,255,255,0.3);
    border-color: rgba(255,255,255,0.5);
    box-shadow: 0 4px 15px rgba(255,255,255,0.2);
}

/* Content Areas */
.automation-content {
    background: rgba(255,255,255,0.95);
    border-radius: 15px;
    padding: 25px;
    margin-bottom: 20px;
    color: #1f2937;
    min-height: 400px;
}

/* Overview View */
.overview-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
}

.overview-card {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    border: 1px solid rgba(0,0,0,0.05);
}

.overview-card h3 {
    margin: 0 0 15px 0;
    color: #1e293b;
    font-size: 1.3em;
}

.status-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
}

.status-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.status-label {
    font-size: 0.9em;
    color: #64748b;
    margin-bottom: 5px;
}

.status-value {
    font-size: 1.8em;
    font-weight: bold;
    color: #1e293b;
}

.active-systems {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.system-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px;
    background: rgba(255,255,255,0.8);
    border-radius: 8px;
    border-left: 4px solid #10b981;
}

.system-icon {
    font-size: 1.2em;
    margin-right: 10px;
}

.system-name {
    flex: 1;
    font-weight: 600;
}

.system-status.online {
    color: #10b981;
    font-weight: bold;
}

.no-systems {
    text-align: center;
    color: #64748b;
    font-style: italic;
    padding: 20px;
}

/* Recommendations */
.recommendations {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.recommendation-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px;
    background: rgba(255,255,255,0.8);
    border-radius: 8px;
    border-left: 4px solid #3b82f6;
}

.recommendation-item.high {
    border-left-color: #ef4444;
}

.recommendation-item.medium {
    border-left-color: #f59e0b;
}

.recommendation-item.low {
    border-left-color: #10b981;
}

.rec-type {
    background: #3b82f6;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.8em;
    font-weight: bold;
}

.rec-message {
    flex: 1;
    margin: 0 15px;
    font-size: 0.9em;
}

.rec-action {
    background: #10b981;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.3s ease;
}

.rec-action:hover {
    background: #059669;
}

/* Performance Summary */
.performance-summary {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
}

.perf-metric {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.metric-label {
    font-size: 0.9em;
    color: #64748b;
    margin-bottom: 5px;
}

.metric-value {
    font-size: 1.5em;
    font-weight: bold;
    color: #1e293b;
}

/* Systems View */
.systems-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
}

.systems-header h3 {
    margin: 0;
    color: #1e293b;
}

.btn-emergency {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s ease;
}

.btn-emergency:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
}

.systems-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 20px;
}

.system-card {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    border: 2px solid transparent;
    transition: all 0.3s ease;
}

.system-card.active {
    border-color: #10b981;
    box-shadow: 0 6px 20px rgba(16, 185, 129, 0.2);
}

.system-card.inactive {
    border-color: #e5e7eb;
    opacity: 0.8;
}

.system-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 15px;
}

.system-header h4 {
    margin: 0;
    color: #1e293b;
    display: flex;
    align-items: center;
    gap: 10px;
}

.toggle-switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: 0.4s;
    border-radius: 24px;
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.4s;
    border-radius: 50%;
}

input:checked + .toggle-slider {
    background-color: #10b981;
}

input:checked + .toggle-slider:before {
    transform: translateX(26px);
}

.system-description {
    color: #64748b;
    margin-bottom: 15px;
    line-height: 1.4;
}

.system-details {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 15px;
}

.detail-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.detail-label {
    color: #64748b;
    font-size: 0.9em;
}

.detail-value {
    font-weight: 600;
    color: #1e293b;
}

.detail-value.online {
    color: #10b981;
}

.detail-value.offline {
    color: #6b7280;
}

.btn-configure {
    background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s ease;
}

.btn-configure:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 10px rgba(59, 130, 246, 0.3);
}

/* Performance View */
.performance-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
}

.perf-card {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.perf-card h4 {
    margin: 0 0 15px 0;
    color: #1e293b;
}

.metric-chart {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.chart-bar {
    position: relative;
    background: #e5e7eb;
    border-radius: 8px;
    height: 30px;
    overflow: hidden;
}

.bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #10b981 0%, #059669 100%);
    border-radius: 8px;
    transition: width 0.3s ease;
}

.bar-fill.error {
    background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%);
}

.bar-label {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.85em;
    font-weight: 600;
    color: #1f2937;
    z-index: 2;
}

.quality-display {
    display: flex;
    align-items: center;
    gap: 20px;
}

.quality-circle {
    position: relative;
    width: 80px;
    height: 80px;
}

.circle-progress {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: conic-gradient(
        #10b981 0deg,
        #10b981 calc(var(--progress) * 3.6deg),
        #e5e7eb calc(var(--progress) * 3.6deg),
        #e5e7eb 360deg
    );
    display: flex;
    align-items: center;
    justify-content: center;
}

.quality-score {
    font-size: 1.2em;
    font-weight: bold;
    color: #1e293b;
}

.quality-details {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.quality-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.cost-breakdown {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.cost-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    border-radius: 6px;
}

.cost-item.positive {
    background: rgba(16, 185, 129, 0.1);
    border-left: 3px solid #10b981;
}

.cost-item.negative {
    background: rgba(239, 68, 68, 0.1);
    border-left: 3px solid #ef4444;
}

.cost-value.positive {
    color: #10b981;
    font-weight: bold;
}

.cost-value.negative {
    color: #ef4444;
    font-weight: bold;
}

/* AI Assistant View */
.ai-status-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
}

.ai-card {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.ai-card.full-width {
    grid-column: 1 / -1;
}

.ai-metrics {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 15px;
}

.ai-metric {
    text-align: center;
}

.intelligence-bars {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.intel-bar {
    display: flex;
    align-items: center;
    gap: 10px;
}

.intel-label {
    width: 100px;
    font-size: 0.9em;
    color: #64748b;
}

.intel-progress {
    flex: 1;
    height: 8px;
    background: #e5e7eb;
    border-radius: 4px;
    overflow: hidden;
}

.intel-fill {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6 0%, #1d4ed8 100%);
    border-radius: 4px;
    transition: width 0.3s ease;
}

.recent-decisions {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.decision-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px;
    background: rgba(255,255,255,0.8);
    border-radius: 8px;
    border-left: 4px solid #3b82f6;
}

.decision-type {
    background: #3b82f6;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.8em;
    font-weight: bold;
}

.decision-context {
    flex: 1;
    margin: 0 15px;
    font-size: 0.9em;
}

.decision-confidence {
    font-weight: bold;
    color: #10b981;
}

/* Settings View */
.settings-sections {
    display: flex;
    flex-direction: column;
    gap: 25px;
    margin-bottom: 30px;
}

.settings-section {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.settings-section h4 {
    margin: 0 0 15px 0;
    color: #1e293b;
    display: flex;
    align-items: center;
    gap: 10px;
}

.settings-form {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.setting-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 15px;
}

.setting-item label {
    font-weight: 600;
    color: #374151;
    min-width: 120px;
}

.setting-item input,
.setting-item select {
    padding: 8px 12px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    background: white;
    color: #374151;
}

.setting-item input[type="range"] {
    flex: 1;
    max-width: 200px;
}

.settings-actions {
    display: flex;
    gap: 15px;
    justify-content: center;
}

.btn-save,
.btn-reset {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s ease;
}

.btn-save {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    color: white;
}

.btn-reset {
    background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
    color: white;
}

.btn-save:hover,
.btn-reset:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}

/* Alerts */
.automation-alerts {
    background: rgba(255,255,255,0.95);
    border-radius: 15px;
    padding: 20px;
    color: #1f2937;
}

.alerts-container h4 {
    margin: 0 0 15px 0;
    color: #1e293b;
}

.alerts-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
    max-height: 200px;
    overflow-y: auto;
}

.alert-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px;
    border-radius: 8px;
    border-left: 4px solid #3b82f6;
}

.alert-item.success {
    background: rgba(16, 185, 129, 0.1);
    border-left-color: #10b981;
}

.alert-item.warning {
    background: rgba(245, 158, 11, 0.1);
    border-left-color: #f59e0b;
}

.alert-item.error {
    background: rgba(239, 68, 68, 0.1);
    border-left-color: #ef4444;
}

.alert-item.info {
    background: rgba(59, 130, 246, 0.1);
    border-left-color: #3b82f6;
}

.alert-item.recommendation {
    background: rgba(139, 92, 246, 0.1);
    border-left-color: #8b5cf6;
}

.alert-icon {
    margin-right: 10px;
    font-size: 1.1em;
}

.alert-message {
    flex: 1;
    font-size: 0.9em;
}

.alert-time {
    font-size: 0.8em;
    color: #64748b;
    margin-right: 10px;
}

.alert-dismiss {
    background: none;
    border: none;
    color: #6b7280;
    cursor: pointer;
    font-size: 1.2em;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.alert-dismiss:hover {
    color: #374151;
}

.no-alerts {
    text-align: center;
    color: #64748b;
    font-style: italic;
    padding: 20px;
}

/* Loading State */
.automation-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 200px;
    color: #64748b;
    font-size: 1.1em;
}

/* Responsive Design */
@media (max-width: 768px) {
    .automation-interface {
        padding: 15px;
    }
    
    .automation-nav {
        flex-wrap: wrap;
    }
    
    .automation-header {
        flex-direction: column;
        gap: 15px;
        align-items: flex-start;
    }
    
    .overview-grid,
    .systems-grid,
    .performance-grid,
    .ai-status-grid {
        grid-template-columns: 1fr;
    }
    
    .setting-item {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
    }
    
    .setting-item label {
        min-width: auto;
    }
    
    .settings-actions {
        flex-direction: column;
    }
    
    .systems-header {
        flex-direction: column;
        gap: 15px;
        align-items: stretch;
    }
}


/* === Loading Screen Styles === */
#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    z-index: 9999;
}

#loading-screen h1 {
    font-size: 3em;
    margin-bottom: 20px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

#loading-screen p {
    font-size: 1.2em;
    margin-bottom: 30px;
}

.loading-spinner {
    width: 50px;
    height: 50px;
    border: 5px solid rgba(255,255,255,0.3);
    border-top: 5px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

#game-container {
    width: 100%;
    height: 100vh;
    overflow: hidden;
}

    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen" class="screen">
        <div class="loading-content">
            <h1>Store Manager Simulator</h1>
            <div class="loading-spinner"></div>
            <p>Initializing your store...</p>
        </div>
    </div>

    <!-- Game Setup Screen -->
    <div id="setup-screen" class="screen hidden">
        <div class="setup-container">
            <h1>üè™ Welcome to Store Manager Simulator</h1>
            <div id="setup-content">
                <!-- Welcome Phase -->
                <div id="welcomePhase" class="setup-phase">
                    <h2>Start Your Business Empire</h2>
                    <p>Build and manage your own store, hire staff, serve customers, and grow your business empire!</p>
                    
                    <div class="setup-buttons">
                        <button id="newGameButton" class="setup-button" onclick="window.__startNewGame && window.__startNewGame()">üÜï Start New Game</button>
                        <button id="loadGameButton" class="setup-button secondary" onclick="window.__loadGame && window.__loadGame()">üìÅ Load Game</button>
                    </div>
                    
                    <div style="margin-top: 30px;">
                        <label style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                            <input type="checkbox" id="adultContentToggle" style="transform: scale(1.2);">
                            <span>Enable Adult Content (18+)</span>
                        </label>
                    </div>
                </div>
                
                <!-- Character Phase -->
                <div id="characterPhase" class="setup-phase hidden">
                    <h2>Create Your Character</h2>
                    <p>Customize your store manager</p>
                    <div id="characterBuilder" class="cc-container">
                        <div id="characterForm">
                            <!-- Character creation will be populated by JavaScript -->
                        </div>
                        <div id="characterPreview">
                            <!-- Character preview will be rendered here -->
                        </div>
                    </div>
                </div>
                
                <!-- Store Phase -->
                <div id="storePhase" class="setup-phase hidden">
                    <h2>Setup Your Store</h2>
                    <p>Configure your business</p>
                    <div id="storeForm">
                        <!-- Store setup will be populated by JavaScript -->
                    </div>
                </div>
                
                <!-- Complete Phase -->
                <div id="completePhase" class="setup-phase hidden">
                    <h2>Ready to Start!</h2>
                    <p>Your store is ready to open for business!</p>
                    <div class="setup-buttons">
                        <button id="gameStartButton" class="setup-button" onclick="window.__startPlaying && window.__startPlaying()">üöÄ Start Playing!</button>
                    </div>
                </div>
            </div>
            
            <!-- Navigation -->
            <div class="setup-navigation" style="margin-top: 30px;">
                <button id="setupPrevButton" class="setup-button secondary" style="display: none;">‚Üê Previous</button>
                <button id="setupNextButton" class="setup-button" style="display: none;">Next ‚Üí</button>
                <button id="setupSkipButton" class="setup-button secondary" style="display: none;">Skip</button>
            </div>
        </div>
    </div>

    <!-- Main Game Interface -->
    <div id="game-interface" class="screen hidden">
        <!-- Store View -->
        <div id="store-view" class="view active">
            <div class="store-header">
                <div class="store-info">
                    <h2 id="store-name">Your Store</h2>
                    <div class="store-stats">
                        <span id="current-cash">$0</span>
                        <span id="current-time">Day 1 - 8:00 AM</span>
                    </div>
                </div>
                <div class="store-actions">
                    <button id="computer-btn" class="action-btn">üíª Computer</button>
                    <button id="pause-btn" class="action-btn">‚è∏Ô∏è Pause</button>
                </div>
            </div>
            
            <div class="store-main">
                <div class="store-floor">
                    <div id="customer-area" class="customer-area">
                        <!-- Customers will appear here -->
                    </div>
                    <div id="counter-area" class="counter-area">
                        <button id="checkout-btn" class="checkout-btn">Checkout Counter</button>
                    </div>
                </div>
                
                <div class="store-sidebar">
                    <div class="inventory-quick">
                        <h3>Quick Inventory</h3>
                        <div id="inventory-list">
                            <!-- Quick inventory items -->
                        </div>
                    </div>
                    
                    <div class="daily-goals">
                        <h3>Daily Goals</h3>
                        <div id="goals-list">
                            <!-- Daily goals -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Computer Interface -->
        <div id="computer-view" class="view">
            <div class="computer-screen">
                <div class="computer-header">
                    <div class="window-controls">
                        <button id="close-computer">‚úï</button>
                    </div>
                    <div class="computer-title">Store Management System</div>
                </div>
                <div class="computer-desktop" id="computer-desktop">
                    <!-- Apps and windows will be created here -->
                </div>
            </div>
        </div>

        <!-- Conversation Interface -->
        <div id="conversation-view" class="view">
            <div class="conversation-container">
                <div class="customer-info">
                    <div id="customer-avatar" class="customer-avatar"></div>
                    <div class="customer-details">
                        <h3 id="customer-name">Customer</h3>
                        <p id="customer-mood">Neutral</p>
                    </div>
                </div>
                
                <div class="conversation-content">
                    <div id="dialogue-history" class="dialogue-history">
                        <!-- Conversation history -->
                    </div>
                    
                    <div class="dialogue-options">
                        <div id="dialogue-choices" class="dialogue-choices">
                            <!-- Response options -->
                        </div>
                    </div>
                </div>
                
                <div class="conversation-actions">
                    <button id="end-conversation" class="action-btn">End Conversation</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification System -->
    <div id="notification-container" class="notification-container"></div>

    <!-- Modal Container -->
    <div id="modal-container" class="modal-container"></div>

    <!-- Core JavaScript Files -->
    
    
    
    
    <!-- System Scripts -->
    
    
    
    
    
    
    
    
    
    <!-- UI Scripts -->
    
    
    
    
    
    
    
    
    
    <!-- Workstation Scripts -->
    
    
    
    
    <!-- Phase 5B: Staff Management Scripts -->
    
    
    
    <!-- Phase 5C: Automation Scripts -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <!-- Data Files -->
    
    
    <!-- Save System -->
    
    
    <!-- Game Initialization -->
    
    
    <!-- Main Application -->
    
    <script>

/* === Store Manager Simulator - Combined Build === */
(function() {
    'use strict';
    
    console.log('üè™ Store Manager Simulator - Loading...');
    
    // Global game state containers
    window.gameState = {};
    window.eventBus = null;
    window.uiManager = null;
    window.workComputer = null;

/* === src/scripts/core/constants.js === */
// Game Constants and Enums
const GAME_CONSTANTS = {
    // Game States
    GAME_STATES: {
        LOADING: 'loading',
        SETUP: 'setup', 
        PLAYING: 'playing',
        PAUSED: 'paused',
        COMPUTER: 'computer',
        CONVERSATION: 'conversation'
    },

    // Views
    VIEWS: {
        STORE: 'store-view',
        COMPUTER: 'computer-view', 
        CONVERSATION: 'conversation-view'
    },

    // Time Constants
    TIME: {
        GAME_SPEED: 1000, // 1 second = 1 game minute
        MINUTES_PER_HOUR: 60,
        HOURS_PER_DAY: 24,
        STORE_OPEN_HOUR: 8,
        STORE_CLOSE_HOUR: 22
    },

    // Financial Constants
    FINANCE: {
        STARTING_CASH: 500,
        STARTING_DEBT_BANK: 50000,
        STARTING_DEBT_MOB: 25000,
        STARTING_DEBT_SUPPLIER: 10000,
        BANK_INTEREST_RATE: 0.03, // 3% monthly
        RENT_WEEKLY: 1200
    },

    // Relationship Levels
    RELATIONSHIP_LEVELS: {
        STRANGER: { min: 0, max: 20, name: 'Stranger' },
        REGULAR: { min: 21, max: 50, name: 'Regular' },
        FRIEND: { min: 51, max: 80, name: 'Friend' },
        VIP: { min: 81, max: 100, name: 'VIP' }
    },

    // Romance Levels
    ROMANCE_LEVELS: {
        NONE: { min: 0, max: 29, name: 'None' },
        INTERESTED: { min: 30, max: 60, name: 'Interested' },
        DATING: { min: 61, max: 80, name: 'Dating' },
        PARTNER: { min: 81, max: 100, name: 'Partner' }
    },

    // Staff Roles
    STAFF_ROLES: {
        CASHIER: { wage: 40, name: 'Cashier' },
        JANITOR: { wage: 30, name: 'Janitor' },
        STOCKER: { wage: 35, name: 'Stocker' },
        SECURITY: { wage: 50, name: 'Security Guard' },
        ASSISTANT_MANAGER: { wage: 60, name: 'Assistant Manager' }
    },

    // Product Categories
    PRODUCT_CATEGORIES: [
        'Food & Beverages',
        'Personal Care',
        'Electronics',
        'Clothing',
        'Home & Garden',
        'Books & Media',
        'Toys & Games',
        'Automotive',
        'Health & Wellness',
        'Adult Products'
    ],

    // NPC Archetypes
    NPC_ARCHETYPES: [
        'college_student',
        'business_professional', 
        'retiree',
        'young_parent',
        'teenager',
        'tradesperson',
        'artist',
        'fitness_enthusiast',
        'tech_worker',
        'service_worker'
    ],

    // Event Types
    EVENT_TYPES: {
        CUSTOMER: 'customer',
        STAFF: 'staff',
        FINANCIAL: 'financial',
        SECURITY: 'security',
        RANDOM: 'random',
        DEBT_COLLECTION: 'debt_collection'
    },

    // Security System Types
    SECURITY_SYSTEMS: {
        CAMERAS: { cost: 2000, effectiveness: 0.6 },
        ALARMS: { cost: 3000, effectiveness: 0.8 },
        GUARD: { dailyCost: 50, effectiveness: 0.9 }
    },

    // Progression Tiers
    PROGRESSION_TIERS: {
        TIER_1: { revenue: 0, name: 'Starting Out' },
        TIER_2: { revenue: 25000, name: 'Getting Established' },
        TIER_3: { revenue: 75000, name: 'Growing Business' },
        TIER_4: { revenue: 150000, name: 'Major Enterprise' }
    }
};

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = GAME_CONSTANTS;
}


/* === src/scripts/core/eventBus.js === */
// Event Bus System for Module Communication
class EventBus {
    constructor() {
        this.events = {};
        this.debugMode = false;
    }

    // Subscribe to an event
    on(eventName, callback, context = null) {
        if (!this.events[eventName]) {
            this.events[eventName] = [];
        }

        this.events[eventName].push({
            callback: callback,
            context: context
        });

        if (this.debugMode) {
            console.log(`üì° EventBus: Subscribed to '${eventName}'`);
        }
    }

    // Subscribe to an event only once
    once(eventName, callback, context = null) {
        const onceWrapper = (...args) => {
            callback.apply(context, args);
            this.off(eventName, onceWrapper);
        };

        this.on(eventName, onceWrapper, context);
    }

    // Unsubscribe from an event
    off(eventName, callback) {
        if (!this.events[eventName]) return;

        this.events[eventName] = this.events[eventName].filter(
            event => event.callback !== callback
        );

        if (this.debugMode) {
            console.log(`üì° EventBus: Unsubscribed from '${eventName}'`);
        }
    }

    // Emit an event
    emit(eventName, ...args) {
        if (!this.events[eventName]) return;

        if (this.debugMode) {
            console.log(`üì° EventBus: Emitting '${eventName}'`, args);
        }

        this.events[eventName].forEach(event => {
            try {
                if (event.context) {
                    event.callback.apply(event.context, args);
                } else {
                    event.callback(...args);
                }
            } catch (error) {
                console.error(`‚ùå EventBus: Error in '${eventName}' handler:`, error);
            }
        });
    }

    // Remove all listeners for an event
    removeAllListeners(eventName = null) {
        if (eventName) {
            delete this.events[eventName];
        } else {
            this.events = {};
        }
    }

    // Get list of all events
    getEvents() {
        return Object.keys(this.events);
    }

    // Get listener count for an event
    getListenerCount(eventName) {
        return this.events[eventName] ? this.events[eventName].length : 0;
    }

    // Enable/disable debug mode
    setDebugMode(enabled) {
        this.debugMode = enabled;
        console.log(`üì° EventBus: Debug mode ${enabled ? 'enabled' : 'disabled'}`);
    }
}

// Create global event bus instance
const gameEventBus = new EventBus();

// Common game events
const GAME_EVENTS = {
    // Game State Events
    GAME_STARTED: 'game:started',
    GAME_PAUSED: 'game:paused',
    GAME_RESUMED: 'game:resumed',
    GAME_SAVED: 'game:saved',
    GAME_LOADED: 'game:loaded',

    // Time Events
    TIME_TICK: 'time:tick',
    TIME_HOUR_CHANGED: 'time:hour_changed',
    TIME_DAY_CHANGED: 'time:day_changed',
    STORE_OPENED: 'time:store_opened',
    STORE_CLOSED: 'time:store_closed',

    // Customer Events
    CUSTOMER_ENTERED: 'customer:entered',
    CUSTOMER_LEFT: 'customer:left',
    CUSTOMER_CHECKOUT: 'customer:checkout',
    CONVERSATION_STARTED: 'conversation:started',
    CONVERSATION_ENDED: 'conversation:ended',

    // Financial Events
    TRANSACTION_COMPLETED: 'finance:transaction_completed',
    DEBT_PAYMENT_DUE: 'finance:debt_payment_due',
    CASH_LOW: 'finance:cash_low',
    PROFIT_MILESTONE: 'finance:profit_milestone',

    // Staff Events
    STAFF_HIRED: 'staff:hired',
    STAFF_FIRED: 'staff:fired',
    STAFF_ISSUE: 'staff:issue',

    // NPC Events
    NPC_CREATED: 'npc:created',
    NPC_RELATIONSHIP_CHANGED: 'npc:relationship_changed',
    NPC_MOOD_CHANGED: 'npc:mood_changed',

    // Product Events
    PRODUCT_ADDED: 'product:added',
    PRODUCT_SOLD: 'product:sold',
    INVENTORY_LOW: 'product:inventory_low',
    RESTOCK_NEEDED: 'product:restock_needed',

    // UI Events
    VIEW_CHANGED: 'ui:view_changed',
    MODAL_OPENED: 'ui:modal_opened',
    MODAL_CLOSED: 'ui:modal_closed',
    NOTIFICATION_SHOWN: 'ui:notification_shown',

    // Computer Events
    COMPUTER_OPENED: 'computer:opened',
    COMPUTER_CLOSED: 'computer:closed',
    APP_OPENED: 'computer:app_opened',
    APP_CLOSED: 'computer:app_closed',

    // Security Events
    THEFT_DETECTED: 'security:theft_detected',
    SECURITY_INCIDENT: 'security:incident',
    ALARM_TRIGGERED: 'security:alarm_triggered'
};

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { EventBus, gameEventBus, GAME_EVENTS };
}
// Also attach to window for browser usage
if (typeof window !== 'undefined') {
    window.gameEventBus = gameEventBus;
    window.GAME_EVENTS = GAME_EVENTS;
}


/* === src/scripts/core/gameState.js === */
// Central Game State Management
class GameState {
    constructor() {
        this.initialized = false;
        this.currentState = GAME_CONSTANTS.GAME_STATES.LOADING;
        this.currentView = GAME_CONSTANTS.VIEWS.STORE;
        
        // Initialize core game data
        this.data = this.getDefaultGameData();
        
        // Bind methods
        this.save = this.save.bind(this);
        this.load = this.load.bind(this);
        this.reset = this.reset.bind(this);
    }

    // Get default game data structure
    getDefaultGameData() {
        return {
            // Game Meta
            version: '1.0.0',
            created: new Date().toISOString(),
            lastSaved: new Date().toISOString(),
            meta: {
                playtime: 0,
                adultContentEnabled: false
            },
            
            // Player Data
            player: {
                name: '',
                age: 25,
                gender: 'other',
                appearance: '',
                profilePicture: null,
                experience: 0,
                level: 1,
                stats: { energy: 100 }
            },

            // Store Data
            store: {
                name: 'Your Store',
                type: 'general',
                environment: 'city',
                backgroundImage: null,
                reputation: 50,
                cleanliness: 100,
                security: {
                    cameras: false,
                    alarms: false,
                    guard: false
                },
                hours: {
                    monday:   { open: '08:00', close: '22:00', closed: false },
                    tuesday:  { open: '08:00', close: '22:00', closed: false },
                    wednesday:{ open: '08:00', close: '22:00', closed: false },
                    thursday: { open: '08:00', close: '22:00', closed: false },
                    friday:   { open: '08:00', close: '22:00', closed: false },
                    saturday: { open: '09:00', close: '21:00', closed: false },
                    sunday:   { open: '10:00', close: '18:00', closed: false }
                }
            },

            // Financial Data
            finances: {
                cash: GAME_CONSTANTS.FINANCE.STARTING_CASH,
                totalRevenue: 0,
                totalExpenses: 0,
                dailyExpenses: {
                    utilities: 50,
                    maintenance: 20
                },
                debts: {
                    bank: {
                        amount: GAME_CONSTANTS.FINANCE.STARTING_DEBT_BANK,
                        interestRate: GAME_CONSTANTS.FINANCE.BANK_INTEREST_RATE,
                        monthlyPayment: 1500,
                        missedPayments: 0
                    },
                    mob: {
                        amount: GAME_CONSTANTS.FINANCE.STARTING_DEBT_MOB,
                        weeklyPayment: 500,
                        missedPayments: 0
                    },
                    supplier: {
                        amount: GAME_CONSTANTS.FINANCE.STARTING_DEBT_SUPPLIER,
                        monthlyPayment: 300,
                        missedPayments: 0
                    }
                },
                // Compatibility with systems expecting singular 'debt' entries
                debt: {
                    bank: { dueDate: 7, nextPayment: 1500 },
                    mob: { dueDate: 7, nextPayment: 500 },
                    supplier: { dueDate: 30, nextPayment: 300 }
                },
                investments: {
                    techCorp: { shares: 0, value: 0 },
                    retailChain: { shares: 0, value: 0 },
                    cryptoCoin: { amount: 0, value: 0 },
                    localBonds: { amount: 0, value: 0 },
                    commodityFund: { shares: 0, value: 0 }
                },
                transactions: []
            },

            // Time Data
            time: {
                currentDay: 1,
                dayOfWeek: 1,
                currentWeek: 1,
                currentMonth: 1,
                currentTime: '08:00',
                currentHour: 8,
                currentMinute: 0,
                totalMinutes: 0,
                isOpen: true,
                isStoreOpen: true,
                speed: 1,
                gameSpeed: 1,
                paused: false
            },

            // Inventory Data
            inventory: {
                products: [],
                categories: {},
                lowStockThreshold: 5,
                totalValue: 0
            },

            // NPCs Data
            npcs: {
                registry: {},
                queue: [],
                currentCustomers: [],
                staff: [],
                totalGenerated: 0,
                customers: new Map(),
                encounterHistory: [],
                relationshipEvents: []
            },

            // Relationships Data
            relationships: {},

            // Staff Data
            staff: {
                employees: [],
                schedule: {},
                hireable: [],
                payroll: { totalWeekly: 0, lastPayDate: 0 }
            },

            // Events Data
            events: {
                history: [],
                pending: [],
                triggers: {}
            },

            // Progression Data
            progression: {
                currentTier: 1,
                achievements: [],
                milestones: {},
                unlockedFeatures: []
            },

            // Settings Data
            settings: {
                adultContent: false,
                difficulty: 'normal',
                notifications: true,
                autoSave: true,
                soundEnabled: false
            }
        };
    }

    // Initialize game state
    initialize() {
        if (this.initialized) return;

        console.log('üéÆ Initializing Game State...');
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Ensure required complex structures exist and set convenient aliases
        try {
            if (!(this.data?.npcs?.customers instanceof Map)) {
                this.data.npcs.customers = new Map();
            }
            // Alias for systems that expect gameState.npcs as a Map
            this.npcs = this.data.npcs.customers;
            // Ensure store hours exist
            if (!this.data.store.hours) {
                this.data.store.hours = {
                    monday:   { open: '08:00', close: '22:00', closed: false },
                    tuesday:  { open: '08:00', close: '22:00', closed: false },
                    wednesday:{ open: '08:00', close: '22:00', closed: false },
                    thursday: { open: '08:00', close: '22:00', closed: false },
                    friday:   { open: '08:00', close: '22:00', closed: false },
                    saturday: { open: '09:00', close: '21:00', closed: false },
                    sunday:   { open: '10:00', close: '18:00', closed: false }
                };
            }
            // Keep meta.adultContentEnabled in sync with settings.adultContent
            this.data.meta.adultContentEnabled = !!this.data.settings.adultContent;
        } catch (e) {
            console.warn('‚ö†Ô∏è Post-initialize normalization failed:', e);
        }
        
        // Mark as initialized
        this.initialized = true;
        
        gameEventBus.emit(GAME_EVENTS.GAME_STARTED);
        console.log('‚úÖ Game State initialized');
    }

    // Set up event listeners
    setupEventListeners() {
        // Auto-save on important events
        gameEventBus.on(GAME_EVENTS.TRANSACTION_COMPLETED, () => {
            if (this.data.settings.autoSave) {
                this.autoSave();
            }
        });

        gameEventBus.on(GAME_EVENTS.TIME_DAY_CHANGED, () => {
            if (this.data.settings.autoSave) {
                this.autoSave();
            }
        });
    }

    // Get current game state
    getState() {
        return this.currentState;
    }

    // Set game state
    setState(newState) {
        const oldState = this.currentState;
        this.currentState = newState;
        
        console.log(`üéÆ State changed: ${oldState} ‚Üí ${newState}`);
        gameEventBus.emit('state:changed', { oldState, newState });
    }

    // Get current view
    getView() {
        return this.currentView;
    }

    // Set current view
    setView(newView) {
        const oldView = this.currentView;
        this.currentView = newView;
        
        console.log(`üëÅÔ∏è View changed: ${oldView} ‚Üí ${newView}`);
        gameEventBus.emit(GAME_EVENTS.VIEW_CHANGED, { oldView, newView });
    }

    // Get game data
    getData() {
        return this.data;
    }

    // Update game data
    updateData(path, value) {
        const pathArray = path.split('.');
        let current = this.data;
        
        // Navigate to the parent object
        for (let i = 0; i < pathArray.length - 1; i++) {
            if (!current[pathArray[i]]) {
                current[pathArray[i]] = {};
            }
            current = current[pathArray[i]];
        }
        
        // Set the value
        current[pathArray[pathArray.length - 1]] = value;
        
        // Update last saved time
        this.data.lastSaved = new Date().toISOString();
    }

    // Get nested data value
    getValue(path) {
        const pathArray = path.split('.');
        let current = this.data;
        
        for (const key of pathArray) {
            if (current && current.hasOwnProperty(key)) {
                current = current[key];
            } else {
                return undefined;
            }
        }
        
        return current;
    }

    // Save game state
    save(slot = 'quicksave') {
        try {
            const saveData = {
                ...this.data,
                lastSaved: new Date().toISOString()
            };
            
            localStorage.setItem(`storeManager_${slot}`, JSON.stringify(saveData));
            console.log(`üíæ Game saved to slot: ${slot}`);
            
            gameEventBus.emit(GAME_EVENTS.GAME_SAVED, { slot, data: saveData });
            return true;
        } catch (error) {
            console.error('‚ùå Failed to save game:', error);
            return false;
        }
    }

    // Load game state
    load(slot = 'quicksave') {
        try {
            const saveData = localStorage.getItem(`storeManager_${slot}`);
            if (!saveData) {
                console.warn(`‚ö†Ô∏è No save data found in slot: ${slot}`);
                return false;
            }
            
            this.data = JSON.parse(saveData);
            console.log(`üìÇ Game loaded from slot: ${slot}`);
            
            gameEventBus.emit(GAME_EVENTS.GAME_LOADED, { slot, data: this.data });
            return true;
        } catch (error) {
            console.error('‚ùå Failed to load game:', error);
            return false;
        }
    }

    // Auto-save
    autoSave() {
        this.save('autosave');
    }

    // Initialize a fresh game
    initializeNewGame() {
        // Reset to defaults but preserve existing settings toggles if already chosen
        const prevSettings = this.data?.settings ? { ...this.data.settings } : null;
        this.data = this.getDefaultGameData();
        if (prevSettings) {
            this.data.settings = { ...this.data.settings, ...prevSettings };
            this.data.meta.adultContentEnabled = !!this.data.settings.adultContent;
        }
        // Day/time sane defaults
        this.data.time.currentDay = 1;
        this.data.time.currentTime = '08:00';
        this.data.time.isOpen = true;
        // Put game into SETUP state
        this.setState(GAME_CONSTANTS.GAME_STATES.SETUP);
        // Ensure view starts at store (UI will switch screens accordingly)
        this.setView(GAME_CONSTANTS.VIEWS.STORE);
    }

    // Reset game to default state
    reset() {
        console.log('üîÑ Resetting game state...');
        this.data = this.getDefaultGameData();
        gameEventBus.emit('state:reset');
    }

    // Export game data
    export() {
        return JSON.stringify(this.data, null, 2);
    }

    // Import game data
    import(jsonData) {
        try {
            const importedData = JSON.parse(jsonData);
            this.data = { ...this.getDefaultGameData(), ...importedData };
            console.log('üì• Game data imported successfully');
            return true;
        } catch (error) {
            console.error('‚ùå Failed to import game data:', error);
            return false;
        }
    }

    // Get save slots
    getSaveSlots() {
        const slots = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('storeManager_')) {
                const slotName = key.replace('storeManager_', '');
                const data = JSON.parse(localStorage.getItem(key));
                slots.push({
                    name: slotName,
                    lastSaved: data.lastSaved,
                    playerName: data.player.name,
                    storeName: data.store.name,
                    day: data.time.currentDay,
                    cash: data.finances.cash
                });
            }
        }
        return slots.sort((a, b) => new Date(b.lastSaved) - new Date(a.lastSaved));
    }

    // Delete save slot
    deleteSave(slot) {
        try {
            localStorage.removeItem(`storeManager_${slot}`);
            console.log(`üóëÔ∏è Save slot deleted: ${slot}`);
            return true;
        } catch (error) {
            console.error('‚ùå Failed to delete save:', error);
            return false;
        }
    }
}

// Create global game state instance
const gameState = new GameState();

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { GameState, gameState };
}
// Also attach to window for browser usage
if (typeof window !== 'undefined') {
    window.gameState = gameState;
}


/* === scripts/systems/aiHooks.js === */
// AI Hooks for Perchance Plugin Integration
class AIHooks {
    constructor() {
        this.initialized = false;
        this.generationQueue = [];
        this.cache = new Map();
        this.isGenerating = false;
    }

    // Initialize AI systems
    initialize() {
        if (this.initialized) return;

        console.log('ü§ñ Initializing AI Hooks...');
        
        // Check for Perchance plugins
        this.checkPluginAvailability();
        
        this.initialized = true;
        console.log('‚úÖ AI Hooks initialized');
    }

    // Check if Perchance plugins are available
    checkPluginAvailability() {
        const isCallable = fn => typeof fn === 'function';
        const hasAi = (typeof window !== 'undefined' && isCallable(window.ai)) || (typeof ai !== 'undefined' && isCallable(ai));
        const hasGenerateText = (typeof window !== 'undefined' && isCallable(window.generateText)) || (typeof generateText !== 'undefined' && isCallable(generateText));
        const hasGenerateImage = (typeof window !== 'undefined' && isCallable(window.generateImage)) || (typeof generateImage !== 'undefined' && isCallable(generateImage));
        const hasSpeak = (typeof window !== 'undefined' && isCallable(window.speak)) || (typeof speak !== 'undefined' && isCallable(speak));
        const hasKV = (typeof window !== 'undefined' && typeof window.kv !== 'undefined' && window.kv !== null) || (typeof kv !== 'undefined' && kv !== null);
        const hasRemember = (typeof window !== 'undefined' && typeof window.remember !== 'undefined' && window.remember !== null) || (typeof remember !== 'undefined' && remember !== null);

        this.plugins = {
            textGeneration: hasAi || hasGenerateText,
            imageGeneration: hasGenerateImage,
            textToSpeech: hasSpeak,
            storage: hasKV,
            remember: hasRemember
        };

        console.log('üîå Plugin availability:', this.plugins);
    }

    // Generate text using AI
    async generateText(prompt, options = {}) {
        const cacheKey = `text_${this.hashString(prompt)}`;
        
        // Check cache first
        if (this.cache.has(cacheKey) && !options.skipCache) {
            console.log('üìö Using cached text generation');
            return this.cache.get(cacheKey);
        }

        if (!this.plugins.textGeneration) {
            console.warn('‚ö†Ô∏è Text generation plugin not available');
            return this.getFallbackText(prompt, options);
        }

        try {
            console.log('ü§ñ Generating text...', { prompt: prompt.substring(0, 50) + '...' });
            
            // Use available text generation plugin
            let result;
            const aiFn = (typeof window !== 'undefined' && typeof window.ai === 'function') ? window.ai : (typeof ai === 'function' ? ai : null);
            const textFn = (typeof window !== 'undefined' && typeof window.generateText === 'function') ? window.generateText : (typeof generateText === 'function' ? generateText : null);
            const fn = aiFn || textFn;
            if (!fn) return this.getFallbackText(prompt, options);
            result = await fn(prompt, options);

            // Cache the result
            this.cache.set(cacheKey, result);
            
            return result;
        } catch (error) {
            console.error('‚ùå Text generation failed:', error);
            return this.getFallbackText(prompt, options);
        }
    }

    // Generate image using AI
    async generateImage(prompt, options = {}) {
        let cacheKey = `image_${this.hashString(prompt)}`;
        if (options && options.skipCache) {
            // add entropy so sequential calls don‚Äôt collide on same prompt
            cacheKey += `_${Date.now()}_${Math.floor(Math.random()*1e6)}`;
        }
        
        // Check cache first
        if (this.cache.has(cacheKey) && !options.skipCache) {
            console.log('üìö Using cached image generation for key:', cacheKey);
            return this.cache.get(cacheKey);
        }

    if (!this.plugins.imageGeneration) {
            console.warn('‚ö†Ô∏è Image generation plugin not available');
            return this.getFallbackImage(prompt, options);
        }

        try {
            // Log full prompt once for transparency; avoid excessive spam by slicing only in object preview
            console.log('üé® Generating image with prompt:', prompt);
            
            const fn = (typeof window !== 'undefined' && typeof window.generateImage === 'function') ? window.generateImage : (typeof generateImage === 'function' ? generateImage : null);
            const result = fn ? await fn(prompt, options) : this.getFallbackImage(prompt, options);
            
            // Cache the result unless caller disabled cache
            if (!options.skipCache) {
                this.cache.set(cacheKey, result);
            }
            
            return result;
        } catch (error) {
            console.error('‚ùå Image generation failed:', error);
            return this.getFallbackImage(prompt, options);
        }
    }

    // Generate NPC data
    async generateNPC(archetype, context = {}) {
        const prompt = this.buildNPCPrompt(archetype, context);
        
        try {
            const result = await this.generateText(prompt, {
                maxLength: 500,
                temperature: 0.8
            });

            return this.parseNPCData(result, archetype);
        } catch (error) {
            console.error('‚ùå NPC generation failed:', error);
            return this.getFallbackNPC(archetype);
        }
    }

    // Generate product data
    async generateProduct(category, context = {}) {
        const prompt = this.buildProductPrompt(category, context);
        
        try {
            const textResult = await this.generateText(prompt, {
                maxLength: 200,
                temperature: 0.7
            });

            const productData = this.parseProductData(textResult, category);
            
            // Generate product image if needed
            if (productData && !productData.image) {
                const imagePrompt = `Product photo: ${productData.name}, ${productData.description}, clean white background, professional lighting`;
                productData.image = await this.generateImage(imagePrompt, {
                    style: 'product-photo',
                    aspectRatio: '1:1'
                });
            }

            return productData;
        } catch (error) {
            console.error('‚ùå Product generation failed:', error);
            return this.getFallbackProduct(category);
        }
    }

    // Generate dialogue response
    async generateDialogue(context) {
        const prompt = this.buildDialoguePrompt(context);
        
        try {
            const result = await this.generateText(prompt, {
                maxLength: 150,
                temperature: 0.9
            });

            return this.parseDialogueResponse(result, context);
        } catch (error) {
            console.error('‚ùå Dialogue generation failed:', error);
            return this.getFallbackDialogue(context);
        }
    }

    // Generate event or news
    async generateEvent(type, context = {}) {
        const prompt = this.buildEventPrompt(type, context);
        
        try {
            const result = await this.generateText(prompt, {
                maxLength: 300,
                temperature: 0.8
            });

            return this.parseEventData(result, type);
        } catch (error) {
            console.error('‚ùå Event generation failed:', error);
            return this.getFallbackEvent(type);
        }
    }

    // Text-to-speech
    async speakText(text, options = {}) {
        if (!this.plugins.textToSpeech) {
            console.warn('‚ö†Ô∏è Text-to-speech plugin not available');
            return false;
        }

        try {
            await window.speak(text, options);
            return true;
        } catch (error) {
            console.error('‚ùå Text-to-speech failed:', error);
            return false;
        }
    }

    // Store data persistently
    async storeData(key, value) {
    if (this.plugins.storage && window.kv && typeof window.kv.set === 'function') {
            try {
        await window.kv.set(key, value);
                return true;
            } catch (error) {
                console.error('‚ùå KV storage failed:', error);
            }
        }
        
        // Fallback to localStorage
        try {
            localStorage.setItem(`ai_${key}`, JSON.stringify(value));
            return true;
        } catch (error) {
            console.error('‚ùå localStorage failed:', error);
            return false;
        }
    }

    // Retrieve stored data
    async retrieveData(key) {
    if (this.plugins.storage && window.kv && typeof window.kv.get === 'function') {
            try {
        return await window.kv.get(key);
            } catch (error) {
                console.error('‚ùå KV retrieval failed:', error);
            }
        }
        
        // Fallback to localStorage
        try {
            const data = localStorage.getItem(`ai_${key}`);
            return data ? JSON.parse(data) : null;
        } catch (error) {
            console.error('‚ùå localStorage retrieval failed:', error);
            return null;
        }
    }

    // Build prompts (these will be enhanced in later phases)
    buildNPCPrompt(archetype, context) {
        return `Generate a realistic NPC for a store simulation game:
Archetype: ${archetype}
Context: ${JSON.stringify(context)}
Include: name, age, appearance, personality, background, spending habits
Format as JSON.`;
    }

    buildProductPrompt(category, context) {
        return `Generate a product for a ${category} store:
Context: ${JSON.stringify(context)}
Include: name, description, price, rarity
Format as JSON.`;
    }

    buildDialoguePrompt(context) {
        return `Generate dialogue for a store customer:
Customer: ${context.customerName}
Mood: ${context.mood}
Situation: ${context.situation}
Respond naturally and realistically.`;
    }

    buildEventPrompt(type, context) {
        return `Generate a ${type} event for a store simulation:
Context: ${JSON.stringify(context)}
Make it realistic and engaging.`;
    }

    // Parse generated content (basic implementations)
    parseNPCData(text, archetype) {
        try {
            return JSON.parse(text);
        } catch {
            return this.getFallbackNPC(archetype);
        }
    }

    parseProductData(text, category) {
        try {
            return JSON.parse(text);
        } catch {
            return this.getFallbackProduct(category);
        }
    }

    parseDialogueResponse(text, context) {
        return {
            text: text.trim(),
            mood: context.mood,
            choices: []
        };
    }

    parseEventData(text, type) {
        return {
            type: type,
            title: 'Random Event',
            description: text.trim(),
            effects: {}
        };
    }

    // Fallback content when AI fails
    getFallbackText(prompt, options) {
        return "I'm thinking about what to say...";
    }

    getFallbackImage(prompt, options) {
        return "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2Y0ZjRmNCIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSIxMiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzk5OTk5OSI+SW1hZ2U8L3RleHQ+PC9zdmc+";
    }

    getFallbackNPC(archetype) {
        return {
            name: 'Mystery Customer',
            age: 30,
            archetype: archetype,
            appearance: 'A regular person',
            personality: 'Friendly',
            background: 'Lives in the neighborhood',
            spendingPower: 50
        };
    }

    getFallbackProduct(category) {
        return {
            name: 'Generic Item',
            category: category,
            description: 'A useful product',
            price: 10,
            cost: 5,
            rarity: 'common'
        };
    }

    getFallbackDialogue(context) {
        return {
            text: "Hello! I'm looking around your store.",
            mood: context.mood || 'neutral',
            choices: ['Welcome! Let me know if you need help.', 'Feel free to browse.']
        };
    }

    getFallbackEvent(type) {
        return {
            type: type,
            title: 'Something Happened',
            description: 'An event occurred at your store.',
            effects: {}
        };
    }

    // Utility functions
    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash.toString();
    }

    // Clear cache
    clearCache() {
        this.cache.clear();
        console.log('üßπ AI cache cleared');
    }

    // Get cache size
    getCacheSize() {
        return this.cache.size;
    }
}

// Create global AI hooks instance
const aiHooks = new AIHooks();

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { AIHooks, aiHooks };
}
// Also attach to window for browser usage
if (typeof window !== 'undefined') {
    window.aiHooks = aiHooks;
}


/* === scripts/systems/timeSystem.js === */
/**
 * Time System - Handles day/week progression and time-based events
 */

class TimeSystem {
    constructor() {
        this.gameState = null;
        this.eventBus = null;
        this.isRunning = false;
        this.interval = null;
        this.tickSpeed = 1000; // milliseconds per game minute
        this.autoSaveInterval = 30; // minutes between auto-saves
        this.lastAutoSave = 0;
        
        // Time constants
        this.MINUTES_PER_HOUR = 60;
        this.HOURS_PER_DAY = 24;
        this.DAYS_PER_WEEK = 7;
        this.WEEKS_PER_MONTH = 4;
        
        // Business hours
        this.DEFAULT_OPEN_TIME = "09:00";
        this.DEFAULT_CLOSE_TIME = "21:00";
        
        // Event scheduling
        this.scheduledEvents = [];
        this.recurringEvents = [];
    }

    initialize(gameState, eventBus) {
        this.gameState = gameState;
        this.eventBus = eventBus;
        
        // Listen for time-related events
        this.eventBus.on('game.start', () => this.start());
        this.eventBus.on('game.pause', () => this.pause());
        this.eventBus.on('game.resume', () => this.resume());
        this.eventBus.on('game.stop', () => this.stop());
        this.eventBus.on('time.setSpeed', (speed) => this.setSpeed(speed));
        this.eventBus.on('store.openClose', (isOpen) => this.toggleStore(isOpen));
        
        console.log('‚è∞ Time System initialized');
    }

    start() {
        if (this.isRunning) return;
        
        this.isRunning = true;
        this.gameState.data.time.lastUpdate = Date.now();
        
        this.interval = setInterval(() => {
            this.tick();
        }, this.tickSpeed);
        
        this.eventBus.emit('time.started');
        console.log('‚è∞ Time system started');
    }

    pause() {
        if (!this.isRunning) return;
        
        this.isRunning = false;
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
        
        this.eventBus.emit('time.paused');
        console.log('‚è∞ Time system paused');
    }

    resume() {
        if (this.isRunning) return;
        this.start();
        this.eventBus.emit('time.resumed');
    }

    stop() {
        this.pause();
        this.eventBus.emit('time.stopped');
        console.log('‚è∞ Time system stopped');
    }

    tick() {
        if (!this.isRunning) return;
        
        const timeData = this.gameState.data.time;
        const now = Date.now();
        const deltaTime = now - timeData.lastUpdate;
        
        // Calculate minutes passed based on time speed
        const minutesPassed = (deltaTime / 1000) * timeData.speed;
        
        // Update game time
        this.addMinutes(minutesPassed);
        timeData.lastUpdate = now;
        
        // Update playtime
        this.gameState.data.meta.playtime += deltaTime / 1000;
        
        // Check for scheduled events
        this.processScheduledEvents();
        
        // Auto-save check
        this.checkAutoSave();
        
        // Emit time update event
        this.eventBus.emit('time.updated', {
            time: timeData.currentTime,
            day: timeData.currentDay,
            week: timeData.currentWeek,
            dayOfWeek: timeData.dayOfWeek
        });
    }

    addMinutes(minutes) {
        const timeData = this.gameState.data.time;
        const currentTime = this.timeToMinutes(timeData.currentTime);
        const newTime = currentTime + minutes;
        
        // Handle day overflow
        if (newTime >= this.MINUTES_PER_HOUR * this.HOURS_PER_DAY) {
            const daysToAdd = Math.floor(newTime / (this.MINUTES_PER_HOUR * this.HOURS_PER_DAY));
            this.addDays(daysToAdd);
            
            const remainingMinutes = newTime % (this.MINUTES_PER_HOUR * this.HOURS_PER_DAY);
            timeData.currentTime = this.minutesToTime(remainingMinutes);
        } else {
            timeData.currentTime = this.minutesToTime(newTime);
        }
        
        // Check store hours
        this.updateStoreStatus();
    }

    addDays(days) {
        const timeData = this.gameState.data.time;
        
        for (let i = 0; i < days; i++) {
            timeData.currentDay++;
            timeData.dayOfWeek++;
            
            if (timeData.dayOfWeek > 7) {
                timeData.dayOfWeek = 1;
                timeData.currentWeek++;
                this.processWeekEnd();
            }
            
            if (timeData.currentWeek > this.WEEKS_PER_MONTH) {
                timeData.currentWeek = 1;
                timeData.currentMonth++;
                this.processMonthEnd();
            }
            
            this.processDayEnd();
            this.processDayStart();
        }
    }

    processDayStart() {
        const timeData = this.gameState.data.time;
        
        // Reset daily stats
        this.gameState.data.player.stats.energy = Math.min(100, 
            this.gameState.data.player.stats.energy + 20);
        
        // Process daily expenses
        this.processDailyExpenses();
        
        // Generate daily events
        this.generateDailyEvents();
        
        // Update NPC availability
        this.updateNPCAvailability();
        
        this.eventBus.emit('time.dayStart', {
            day: timeData.currentDay,
            dayOfWeek: timeData.dayOfWeek,
            week: timeData.currentWeek
        });
        
        console.log(`üåÖ Day ${timeData.currentDay} (${this.getDayName(timeData.dayOfWeek)}) started`);
    }

    processDayEnd() {
        const timeData = this.gameState.data.time;
        
        // Force close store
        timeData.isOpen = false;
        
        // Process end-of-day finances
        this.processEndOfDayFinances();
        
        // Update staff schedules
        this.updateStaffSchedules();
        
        // Process relationship decay
        this.processRelationshipDecay();
        
        this.eventBus.emit('time.dayEnd', {
            day: timeData.currentDay,
            week: timeData.currentWeek,
            sales: this.getDailySales()
        });
        
        console.log(`üåô Day ${timeData.currentDay} ended`);
    }

    processWeekEnd() {
        // Pay staff
        this.processWeeklyPayroll();
        
        // Process debt payments
        this.processDebtPayments();
        
        // Generate weekly reports
        this.generateWeeklyReport();
        
        this.eventBus.emit('time.weekEnd', {
            week: this.gameState.data.time.currentWeek,
            revenue: this.getWeeklyRevenue()
        });
        
        console.log(`üìä Week ${this.gameState.data.time.currentWeek} ended`);
    }

    processMonthEnd() {
        // Pay monthly expenses (rent, insurance, etc.)
        this.processMonthlyExpenses();
        
        // Update market conditions
        this.updateMarketConditions();
        
        // Generate monthly report
        this.generateMonthlyReport();
        
        this.eventBus.emit('time.monthEnd', {
            month: this.gameState.data.time.currentMonth,
            profit: this.getMonthlyProfit()
        });
        
        console.log(`üìà Month ${this.gameState.data.time.currentMonth} ended`);
    }

    updateStoreStatus() {
        const timeData = this.gameState.data.time;
        const storeHours = this.gameState.data.store.hours;
        const dayName = this.getDayName(timeData.dayOfWeek).toLowerCase();
        const dayHours = storeHours[dayName];
        
        if (!dayHours || dayHours.closed) {
            timeData.isOpen = false;
            return;
        }
        
        const currentMinutes = this.timeToMinutes(timeData.currentTime);
        const openMinutes = this.timeToMinutes(dayHours.open);
        const closeMinutes = this.timeToMinutes(dayHours.close);
        
        const wasOpen = timeData.isOpen;
        timeData.isOpen = currentMinutes >= openMinutes && currentMinutes < closeMinutes;
        
        // Emit events on status change
        if (wasOpen !== timeData.isOpen) {
            this.eventBus.emit('store.statusChanged', {
                isOpen: timeData.isOpen,
                time: timeData.currentTime
            });
            
            if (timeData.isOpen) {
                this.eventBus.emit('store.opened');
                console.log('üè™ Store opened for business');
            } else {
                this.eventBus.emit('store.closed');
                console.log('üîí Store closed');
            }
        }
    }

    // Utility Methods
    timeToMinutes(timeString) {
        const [hours, minutes] = timeString.split(':').map(Number);
        return hours * this.MINUTES_PER_HOUR + minutes;
    }

    minutesToTime(minutes) {
        const hours = Math.floor(minutes / this.MINUTES_PER_HOUR);
        const mins = Math.floor(minutes % this.MINUTES_PER_HOUR);
        return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
    }

    getDayName(dayNumber) {
        const days = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
        return days[dayNumber] || 'Unknown';
    }

    setSpeed(speed) {
        this.gameState.data.time.speed = Math.max(0.1, Math.min(10, speed));
        this.eventBus.emit('time.speedChanged', this.gameState.data.time.speed);
    }

    toggleStore(isOpen) {
        this.gameState.data.time.isOpen = isOpen;
        this.eventBus.emit('store.statusChanged', { isOpen });
    }

    // Event Scheduling
    scheduleEvent(eventData, triggerTime) {
        this.scheduledEvents.push({
            ...eventData,
            triggerTime,
            id: this.generateEventId()
        });
    }

    scheduleRecurring(eventData, interval, triggerCondition) {
        this.recurringEvents.push({
            ...eventData,
            interval,
            triggerCondition,
            lastTriggered: 0,
            id: this.generateEventId()
        });
    }

    processScheduledEvents() {
        const currentTime = this.getCurrentTimeStamp();
        
        // Process one-time events
        this.scheduledEvents = this.scheduledEvents.filter(event => {
            if (currentTime >= event.triggerTime) {
                this.eventBus.emit('event.triggered', event);
                return false; // Remove from array
            }
            return true; // Keep in array
        });
        
        // Process recurring events
        this.recurringEvents.forEach(event => {
            if (currentTime - event.lastTriggered >= event.interval) {
                if (!event.triggerCondition || event.triggerCondition()) {
                    this.eventBus.emit('event.triggered', event);
                    event.lastTriggered = currentTime;
                }
            }
        });
    }

    getCurrentTimeStamp() {
        const timeData = this.gameState.data.time;
        return timeData.currentDay * 1440 + this.timeToMinutes(timeData.currentTime);
    }

    generateEventId() {
        return 'event_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
    }

    // Financial Processing Methods
    processDailyExpenses() {
        const expenses = this.gameState.data.finances.dailyExpenses;
        let totalExpenses = 0;
        
        Object.entries(expenses).forEach(([type, amount]) => {
            this.gameState.data.finances.cash -= amount;
            totalExpenses += amount;
            
            this.gameState.data.finances.transactions.push({
                id: this.generateEventId(),
                type: 'expense',
                category: type,
                amount: -amount,
                timestamp: Date.now(),
                description: `Daily ${type}`
            });
        });
        
        this.eventBus.emit('finances.dailyExpenses', { total: totalExpenses });
    }

    processEndOfDayFinances() {
        // Calculate daily profit/loss
        const dailySales = this.getDailySales();
        const dailyExpenses = Object.values(this.gameState.data.finances.dailyExpenses)
            .reduce((sum, expense) => sum + expense, 0);
        
        const dailyProfit = dailySales - dailyExpenses;
        
        this.eventBus.emit('finances.dailyReport', {
            sales: dailySales,
            expenses: dailyExpenses,
            profit: dailyProfit
        });
    }

    processWeeklyPayroll() {
        const staff = this.gameState.data.staff;
        let totalPayroll = 0;
        
        staff.employees.forEach(employee => {
            const weeklyPay = employee.hourlyRate * employee.hoursWorked;
            this.gameState.data.finances.cash -= weeklyPay;
            totalPayroll += weeklyPay;
            
            // Reset hours for next week
            employee.hoursWorked = 0;
            
            this.gameState.data.finances.transactions.push({
                id: this.generateEventId(),
                type: 'expense',
                category: 'payroll',
                amount: -weeklyPay,
                timestamp: Date.now(),
                description: `Weekly pay for ${employee.name}`
            });
        });
        
        staff.payroll.totalWeekly = totalPayroll;
        staff.payroll.lastPayDate = this.gameState.data.time.currentDay;
        
        this.eventBus.emit('finances.payroll', { total: totalPayroll });
    }

    processDebtPayments() {
        const debt = this.gameState.data.finances.debt;
        const currentDay = this.gameState.data.time.currentDay;
        
        // Check each debt for due payments
        Object.entries(debt).forEach(([debtType, debtData]) => {
            if (currentDay >= debtData.dueDate) {
                this.eventBus.emit('debt.paymentDue', {
                    type: debtType,
                    amount: debtData.nextPayment,
                    daysOverdue: currentDay - debtData.dueDate
                });
            }
        });
    }

    processMonthlyExpenses() {
        // Rent, insurance, utilities
        const monthlyExpenses = {
            rent: 6000,
            insurance: 750,
            utilities: 1500
        };
        
        Object.entries(monthlyExpenses).forEach(([type, amount]) => {
            this.gameState.data.finances.cash -= amount;
            
            this.gameState.data.finances.transactions.push({
                id: this.generateEventId(),
                type: 'expense',
                category: type,
                amount: -amount,
                timestamp: Date.now(),
                description: `Monthly ${type}`
            });
        });
    }

    // Helper Methods for Financial Calculations
    getDailySales() {
        const today = this.gameState.data.time.currentDay;
        return this.gameState.data.finances.transactions
            .filter(t => t.type === 'sale' && this.isSameDay(t.timestamp, today))
            .reduce((sum, t) => sum + t.amount, 0);
    }

    getWeeklyRevenue() {
        const currentWeek = this.gameState.data.time.currentWeek;
        return this.gameState.data.finances.transactions
            .filter(t => t.type === 'sale' && this.isSameWeek(t.timestamp, currentWeek))
            .reduce((sum, t) => sum + t.amount, 0);
    }

    getMonthlyProfit() {
        const currentMonth = this.gameState.data.time.currentMonth;
        const transactions = this.gameState.data.finances.transactions
            .filter(t => this.isSameMonth(t.timestamp, currentMonth));
        
        const revenue = transactions
            .filter(t => t.type === 'sale')
            .reduce((sum, t) => sum + t.amount, 0);
        
        const expenses = transactions
            .filter(t => t.type === 'expense')
            .reduce((sum, t) => sum + Math.abs(t.amount), 0);
        
        return revenue - expenses;
    }

    // Auto-save functionality
    checkAutoSave() {
        if (!this.gameState.data.settings.autoSave) return;
        
        const currentMinutes = this.getCurrentTimeStamp();
        if (currentMinutes - this.lastAutoSave >= this.autoSaveInterval) {
            this.eventBus.emit('game.autoSave');
            this.lastAutoSave = currentMinutes;
        }
    }

    // Placeholder methods for future implementation
    generateDailyEvents() {
        // TODO: Generate random daily events
    }

    updateNPCAvailability() {
        // TODO: Update which NPCs are available today
    }

    updateStaffSchedules() {
        // TODO: Update staff schedules for next day
    }

    processRelationshipDecay() {
        // TODO: Slowly decay relationships that aren't maintained
    }

    generateWeeklyReport() {
        // TODO: Generate comprehensive weekly business report
    }

    generateMonthlyReport() {
        // TODO: Generate comprehensive monthly business report
    }

    updateMarketConditions() {
        // TODO: Update product demand, pricing, competition
    }

    // Date comparison helpers
    isSameDay(timestamp, gameDay) {
        // Convert timestamp to game day and compare
        // This is a simplified implementation
        return true; // TODO: Implement proper date comparison
    }

    isSameWeek(timestamp, gameWeek) {
        // Convert timestamp to game week and compare
        return true; // TODO: Implement proper date comparison
    }

    isSameMonth(timestamp, gameMonth) {
        // Convert timestamp to game month and compare
        return true; // TODO: Implement proper date comparison
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TimeSystem;
} else if (typeof window !== 'undefined') {
    window.TimeSystem = TimeSystem;
}


/* === scripts/systems/npcSystem.js === */
/**
 * NPC System - Handles NPC generation, management, and interactions
 * Implements hybrid generation: basic traits first, AI enrichment later
 */

class NPCSystem {
    constructor() {
        this.gameState = null;
        this.eventBus = null;
        this.aiHooks = null;
        this.nameData = null;
        this.archetypeData = null;
        this.encounterQueue = [];
        this.enrichmentQueue = [];
        this.isEnriching = false;
        this.maxEncountersPerDay = 8;
        this.npcGenerationBatch = 5;
    }

    initialize(gameState, eventBus, aiHooks) {
        this.gameState = gameState;
        this.eventBus = eventBus;
        this.aiHooks = aiHooks;
        
        // Load name and archetype data
        this.loadNameData();
        this.loadArchetypeData();
        
        // Initialize NPC AI Enhancer if available
        if (typeof npcAIEnhancer !== 'undefined') {
            npcAIEnhancer.initialize(aiHooks);
            this.npcAIEnhancer = npcAIEnhancer;
            console.log('üß† NPC AI Enhancer connected to NPC System');
        }
        
        // Listen for events
        this.eventBus.on('game.start', () => this.onGameStart());
        this.eventBus.on('time.dayStart', () => this.generateDailyEncounters());
        this.eventBus.on('customer.encounter', (npcId) => this.handleEncounter(npcId));
        this.eventBus.on('npc.requestEnrichment', (npcId) => this.enrichNPC(npcId));
        this.eventBus.on('store.customerEnter', () => this.getNextCustomer());
        this.eventBus.on('npc.enriched', (data) => this.onNPCEnriched(data));
        
        console.log('üë• NPC System initialized');
    }

    loadNameData() {
        // Curated name lists for realistic generation
        this.nameData = {
            first: {
                female: [
                    'Emma', 'Olivia', 'Ava', 'Isabella', 'Sophia', 'Charlotte', 'Mia', 'Amelia',
                    'Harper', 'Evelyn', 'Abigail', 'Emily', 'Elizabeth', 'Mila', 'Ella', 'Avery',
                    'Sofia', 'Camila', 'Aria', 'Scarlett', 'Victoria', 'Madison', 'Luna', 'Grace',
                    'Chloe', 'Penelope', 'Layla', 'Riley', 'Zoey', 'Nora', 'Lily', 'Eleanor',
                    'Hannah', 'Lillian', 'Addison', 'Aubrey', 'Ellie', 'Stella', 'Natalie', 'Zoe'
                ],
                male: [
                    'Liam', 'Noah', 'Oliver', 'Elijah', 'William', 'James', 'Benjamin', 'Lucas',
                    'Henry', 'Alexander', 'Mason', 'Michael', 'Ethan', 'Daniel', 'Jacob', 'Logan',
                    'Jackson', 'Sebastian', 'Jack', 'Aiden', 'Owen', 'Samuel', 'Matthew', 'Joseph',
                    'Levi', 'Mateo', 'David', 'John', 'Wyatt', 'Carter', 'Julian', 'Luke',
                    'Grayson', 'Isaac', 'Jayden', 'Theodore', 'Gabriel', 'Anthony', 'Dylan', 'Leo'
                ],
                neutral: [
                    'Alex', 'Jordan', 'Taylor', 'Casey', 'Riley', 'Avery', 'Quinn', 'Sage',
                    'River', 'Rowan', 'Cameron', 'Charlie', 'Parker', 'Hayden', 'Emery', 'Finley',
                    'Dakota', 'Reese', 'Peyton', 'Blake', 'Drew', 'Phoenix', 'Skyler', 'Eden'
                ]
            },
            last: [
                'Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis',
                'Rodriguez', 'Martinez', 'Hernandez', 'Lopez', 'Gonzalez', 'Wilson', 'Anderson', 'Thomas',
                'Taylor', 'Moore', 'Jackson', 'Martin', 'Lee', 'Perez', 'Thompson', 'White',
                'Harris', 'Sanchez', 'Clark', 'Ramirez', 'Lewis', 'Robinson', 'Walker', 'Young',
                'Allen', 'King', 'Wright', 'Scott', 'Torres', 'Nguyen', 'Hill', 'Flores',
                'Green', 'Adams', 'Nelson', 'Baker', 'Hall', 'Rivera', 'Campbell', 'Mitchell',
                'Carter', 'Roberts', 'Gomez', 'Phillips', 'Evans', 'Turner', 'Diaz', 'Parker'
            ]
        };
    }

    loadArchetypeData() {
        // Character archetypes with traits and behaviors
        this.archetypeData = {
            // Student archetypes
            'college_student': {
                name: 'College Student',
                ageRange: [18, 22],
                spendingPower: [5, 25],
                frequencyModifier: 0.8,
                traits: ['budget_conscious', 'social', 'tech_savvy'],
                behaviors: ['buys_cheap_food', 'shops_late', 'uses_student_discounts'],
                interests: ['energy_drinks', 'snacks', 'electronics', 'study_supplies'],
                dialogue_style: 'casual',
                relationship_speed: 1.2
            },
            'grad_student': {
                name: 'Graduate Student',
                ageRange: [22, 28],
                spendingPower: [10, 40],
                frequencyModifier: 0.6,
                traits: ['intellectual', 'stressed', 'budget_conscious'],
                behaviors: ['buys_coffee', 'shops_efficiently', 'research_focused'],
                interests: ['coffee', 'healthy_food', 'books', 'office_supplies'],
                dialogue_style: 'thoughtful',
                relationship_speed: 0.9
            },

            // Professional archetypes
            'young_professional': {
                name: 'Young Professional',
                ageRange: [25, 35],
                spendingPower: [30, 80],
                frequencyModifier: 1.0,
                traits: ['ambitious', 'busy', 'image_conscious'],
                behaviors: ['quick_shopping', 'brand_aware', 'convenience_focused'],
                interests: ['fashion', 'electronics', 'quick_meals', 'self_care'],
                dialogue_style: 'professional',
                relationship_speed: 0.8
            },
            'business_executive': {
                name: 'Business Executive',
                ageRange: [35, 55],
                spendingPower: [100, 300],
                frequencyModifier: 0.4,
                traits: ['wealthy', 'demanding', 'time_pressed'],
                behaviors: ['expects_service', 'buys_premium', 'impatient'],
                interests: ['luxury_items', 'premium_brands', 'convenience', 'status_symbols'],
                dialogue_style: 'authoritative',
                relationship_speed: 0.6
            },

            // Family archetypes
            'soccer_mom': {
                name: 'Soccer Mom',
                ageRange: [30, 45],
                spendingPower: [40, 120],
                frequencyModifier: 1.3,
                traits: ['family_focused', 'organized', 'value_conscious'],
                behaviors: ['bulk_shopping', 'compares_prices', 'family_first'],
                interests: ['family_products', 'household_items', 'kids_snacks', 'health_products'],
                dialogue_style: 'friendly',
                relationship_speed: 1.1
            },
            'working_parent': {
                name: 'Working Parent',
                ageRange: [28, 50],
                spendingPower: [35, 100],
                frequencyModifier: 1.1,
                traits: ['stressed', 'efficient', 'practical'],
                behaviors: ['rushed_shopping', 'necessity_focused', 'multitasking'],
                interests: ['quick_meals', 'family_essentials', 'convenience_items'],
                dialogue_style: 'hurried',
                relationship_speed: 0.9
            },

            // Senior archetypes
            'retiree': {
                name: 'Retiree',
                ageRange: [65, 85],
                spendingPower: [20, 60],
                frequencyModifier: 1.5,
                traits: ['traditional', 'social', 'value_conscious'],
                behaviors: ['leisurely_shopping', 'brand_loyal', 'enjoys_conversation'],
                interests: ['traditional_products', 'comfort_items', 'health_products'],
                dialogue_style: 'chatty',
                relationship_speed: 1.3
            },
            'wealthy_senior': {
                name: 'Wealthy Senior',
                ageRange: [60, 80],
                spendingPower: [80, 200],
                frequencyModifier: 0.8,
                traits: ['wealthy', 'particular', 'experienced'],
                behaviors: ['quality_focused', 'expects_respect', 'stories_and_advice'],
                interests: ['premium_products', 'comfort_items', 'luxury_goods'],
                dialogue_style: 'wise',
                relationship_speed: 1.0
            },

            // Unique archetypes
            'local_regular': {
                name: 'Local Regular',
                ageRange: [25, 65],
                spendingPower: [15, 50],
                frequencyModifier: 2.0,
                traits: ['loyal', 'friendly', 'community_minded'],
                behaviors: ['routine_shopping', 'supports_local', 'spreads_word'],
                interests: ['consistent_products', 'local_news', 'community_events'],
                dialogue_style: 'familiar',
                relationship_speed: 1.5
            },
            'tourist': {
                name: 'Tourist',
                ageRange: [20, 60],
                spendingPower: [10, 100],
                frequencyModifier: 0.1,
                traits: ['curious', 'temporary', 'adventurous'],
                behaviors: ['impulse_buying', 'asks_questions', 'one_time_visit'],
                interests: ['local_specialties', 'souvenirs', 'convenience_items'],
                dialogue_style: 'curious',
                relationship_speed: 0.5
            },
            'influencer': {
                name: 'Social Media Influencer',
                ageRange: [18, 35],
                spendingPower: [20, 150],
                frequencyModifier: 0.3,
                traits: ['attention_seeking', 'trend_focused', 'image_obsessed'],
                behaviors: ['photos_everything', 'expects_freebies', 'creates_content'],
                interests: ['trendy_items', 'photogenic_products', 'unique_finds'],
                dialogue_style: 'performative',
                relationship_speed: 0.7
            },
            'night_owl': {
                name: 'Night Owl',
                ageRange: [20, 40],
                spendingPower: [15, 60],
                frequencyModifier: 0.6,
                traits: ['nocturnal', 'alternative', 'independent'],
                behaviors: ['late_night_shopping', 'unconventional', 'privacy_focused'],
                interests: ['energy_drinks', 'snacks', 'convenience_items'],
                dialogue_style: 'minimal',
                relationship_speed: 0.8
            }
        };
    }

    // Core NPC Generation
    generateBasicNPC(archetype = null) {
        if (!archetype) {
            archetype = this.selectRandomArchetype();
        }

        const archetypeData = this.archetypeData[archetype];
        if (!archetypeData) {
            console.error('Unknown archetype:', archetype);
            return null;
        }

        const gender = this.selectGender();
        const age = this.generateAge(archetypeData.ageRange);
        const name = this.generateName(gender);
        const spendingPower = this.generateSpendingPower(archetypeData.spendingPower);

        const npc = {
            id: this.generateId(),
            
            // Basic Information
            name: name,
            age: age,
            gender: gender,
            pronouns: this.getPronouns(gender),
            archetype: archetype,
            
            // Financial
            spendingPower: spendingPower,
            currentCash: Math.floor(spendingPower * (0.5 + Math.random() * 1.5)),
            
            // Behavioral
            traits: [...archetypeData.traits],
            behaviors: [...archetypeData.behaviors],
            interests: [...archetypeData.interests],
            frequencyModifier: archetypeData.frequencyModifier,
            
            // Interaction
            dialogue_style: archetypeData.dialogue_style,
            relationship_speed: archetypeData.relationship_speed,
            mood: this.generateMood(),
            patience: Math.floor(Math.random() * 100) + 1,
            
            // Game State
            relationship: 0,
            relationshipLevel: 'stranger',
            lastVisit: 0,
            visitCount: 0,
            totalSpent: 0,
            
            // AI Enhancement Status
            isEnriched: false,
            enrichmentData: null,
            
            // Avatar
            avatar: null,
            appearance: {
                description: '',
                prompt: ''
            },
            
            // Background (filled during enrichment)
            backstory: '',
            personalityDetails: '',
            secrets: [],
            historyWithPlayer: '',
            
            // Timestamps
            created: Date.now(),
            lastInteraction: 0
        };

        return npc;
    }

    selectRandomArchetype() {
        const archetypes = Object.keys(this.archetypeData);
        return archetypes[Math.floor(Math.random() * archetypes.length)];
    }

    selectGender() {
        const roll = Math.random();
        if (roll < 0.45) return 'female';
        if (roll < 0.90) return 'male';
        return 'non-binary';
    }

    generateAge(ageRange) {
        const [min, max] = ageRange;
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    generateName(gender) {
        let firstNames;
        if (gender === 'non-binary') {
            firstNames = this.nameData.first.neutral;
        } else {
            firstNames = this.nameData.first[gender] || this.nameData.first.neutral;
        }
        
        const firstName = firstNames[Math.floor(Math.random() * firstNames.length)];
        const lastName = this.nameData.last[Math.floor(Math.random() * this.nameData.last.length)];
        
        return `${firstName} ${lastName}`;
    }

    generateSpendingPower(range) {
        const [min, max] = range;
        // Use weighted random for more realistic distribution
        const roll1 = Math.random();
        const roll2 = Math.random();
        const normalizedRoll = (roll1 + roll2) / 2; // Creates bell curve
        
        return Math.floor(normalizedRoll * (max - min) + min);
    }

    getPronouns(gender) {
        const pronounMap = {
            'female': 'she/her',
            'male': 'he/him',
            'non-binary': 'they/them'
        };
        return pronounMap[gender] || 'they/them';
    }

    generateMood() {
        const moods = ['happy', 'neutral', 'stressed', 'excited', 'tired', 'irritated', 'cheerful'];
        return moods[Math.floor(Math.random() * moods.length)];
    }

    // NPC Encounter System
    onGameStart() {
        // Generate initial NPC pool
        this.generateInitialNPCPool();
        
        // Start background enrichment process
        this.startBackgroundEnrichment();
    }

    generateInitialNPCPool() {
        const poolSize = 30 + Math.floor(Math.random() * 15); // 30-44 NPCs
        
        console.log(`üë• Generating initial NPC pool of ${poolSize} characters...`);
        
        for (let i = 0; i < poolSize; i++) {
            const npc = this.generateBasicNPC();
            if (npc) {
                this.gameState.data.npcs.customers.set(npc.id, npc);
                this.enrichmentQueue.push(npc.id);
            }
        }
        
        console.log(`üë• Generated ${this.gameState.data.npcs.customers.size} NPCs`);
        this.eventBus.emit('npc.poolGenerated', { 
            count: this.gameState.data.npcs.customers.size 
        });
    }

    generateDailyEncounters() {
        // Clear previous day's encounters
        this.encounterQueue = [];
        
        // Determine number of encounters for today
        const baseEncounters = this.maxEncountersPerDay;
        const storeType = this.gameState.data.store.type;
        const environment = this.gameState.data.store.environment;
        
        // Adjust for store type and environment
        let encounterMultiplier = 1.0;
        if (storeType === 'convenience') encounterMultiplier = 1.3;
        if (storeType === 'boutique') encounterMultiplier = 0.7;
        if (environment === 'city') encounterMultiplier *= 1.2;
        if (environment === 'rural') encounterMultiplier *= 0.6;
        
        const todayEncounters = Math.floor(baseEncounters * encounterMultiplier);
        
        // Select NPCs for today
        const availableNPCs = Array.from(this.gameState.data.npcs.customers.values())
            .filter(npc => this.shouldNPCVisitToday(npc));
        
        // Add regulars first
        const regulars = availableNPCs
            .filter(npc => npc.relationshipLevel !== 'stranger')
            .sort((a, b) => b.relationship - a.relationship);
        
        for (let i = 0; i < Math.min(regulars.length, Math.floor(todayEncounters * 0.4)); i++) {
            this.encounterQueue.push(regulars[i].id);
        }
        
        // Fill remaining slots with other NPCs
        const others = availableNPCs.filter(npc => !this.encounterQueue.includes(npc.id));
        const remainingSlots = todayEncounters - this.encounterQueue.length;
        
        for (let i = 0; i < remainingSlots && i < others.length; i++) {
            const randomNPC = others[Math.floor(Math.random() * others.length)];
            if (!this.encounterQueue.includes(randomNPC.id)) {
                this.encounterQueue.push(randomNPC.id);
            }
        }
        
        // Generate new NPCs if pool is getting low
        if (this.gameState.data.npcs.customers.size < 20) {
            this.generateMoreNPCs(10);
        }
        
        this.eventBus.emit('npc.dailyEncountersGenerated', {
            count: this.encounterQueue.length,
            encounters: this.encounterQueue
        });
        
        console.log(`üë• Generated ${this.encounterQueue.length} encounters for today`);
    }

    shouldNPCVisitToday(npc) {
        // Base probability modified by archetype frequency
        let probability = 0.3 * npc.frequencyModifier;
        
        // Relationship modifier
        if (npc.relationshipLevel === 'regular') probability *= 1.5;
        if (npc.relationshipLevel === 'friend') probability *= 2.0;
        if (npc.relationshipLevel === 'vip') probability *= 2.5;
        
        // Recency modifier (less likely if visited recently)
        const daysSinceLastVisit = this.gameState.data.time.currentDay - npc.lastVisit;
        if (daysSinceLastVisit < 2) probability *= 0.3;
        else if (daysSinceLastVisit < 5) probability *= 0.7;
        
        return Math.random() < probability;
    }

    getNextCustomer() {
        if (this.encounterQueue.length === 0) {
            return null;
        }
        
        const npcId = this.encounterQueue.shift();
        const npc = this.gameState.data.npcs.customers.get(npcId);
        
        if (!npc) {
            return this.getNextCustomer(); // Try next in queue
        }
        
        // Update visit statistics
        npc.visitCount++;
        npc.lastVisit = this.gameState.data.time.currentDay;
        npc.lastInteraction = Date.now();
        
        // Trigger enrichment if not already done
        if (!npc.isEnriched) {
            this.enrichNPC(npcId);
        }
        
        this.eventBus.emit('npc.customerEntered', { npc });
        return npc;
    }

    handleEncounter(npcId) {
        const npc = this.gameState.data.npcs.customers.get(npcId);
        if (!npc) return;
        
        // Add to encounter history
        this.gameState.data.npcs.encounterHistory.unshift({
            npcId: npcId,
            timestamp: Date.now(),
            day: this.gameState.data.time.currentDay,
            type: 'customer_visit'
        });
        
        // Keep history manageable
        if (this.gameState.data.npcs.encounterHistory.length > 100) {
            this.gameState.data.npcs.encounterHistory.pop();
        }
        
        this.eventBus.emit('npc.encounterProcessed', { npc });
    }

    // AI Enrichment System
    startBackgroundEnrichment() {
        if (this.isEnriching || this.enrichmentQueue.length === 0) return;
        
        this.isEnriching = true;
        this.processEnrichmentQueue();
    }

    async processEnrichmentQueue() {
        while (this.enrichmentQueue.length > 0) {
            const npcId = this.enrichmentQueue.shift();
            await this.enrichNPCBackground(npcId);
            
            // Add small delay to prevent overwhelming the AI
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        this.isEnriching = false;
    }

    async enrichNPCBackground(npcId) {
        const npc = this.gameState.data.npcs.customers.get(npcId);
        if (!npc || npc.isEnriched) return;
        
        try {
            let enrichmentData;
            
            // Use new AI enhancer if available
            if (this.npcAIEnhancer) {
                enrichmentData = await this.npcAIEnhancer.enrichNPC(npc);
            } else {
                // Fallback to original enrichment
                enrichmentData = await this.generateNPCEnrichment(npc);
            }
            
            this.applyEnrichment(npc, enrichmentData);
            
            console.log(`üë• Enriched NPC: ${npc.name}`);
        } catch (error) {
            console.error('Failed to enrich NPC:', npc.name, error);
        }
    }

    async enrichNPC(npcId) {
        // Immediate enrichment for active encounters
        const npc = this.gameState.data.npcs.customers.get(npcId);
        if (!npc || npc.isEnriched) return npc;
        
        try {
            let enrichmentData;
            
            // Use new AI enhancer if available
            if (this.npcAIEnhancer) {
                enrichmentData = await this.npcAIEnhancer.enrichNPC(npc);
            } else {
                // Fallback to original enrichment
                enrichmentData = await this.generateNPCEnrichment(npc);
            }
            
            this.applyEnrichment(npc, enrichmentData);
            
            this.eventBus.emit('npc.enriched', { npc });
            return npc;
        } catch (error) {
            console.error('Failed to enrich NPC:', npc.name, error);
            return npc;
        }
    }

    async generateNPCEnrichment(npc) {
        const archetype = this.archetypeData[npc.archetype];
        
        const prompt = `Create a detailed character profile for ${npc.name}, a ${npc.age}-year-old ${npc.gender} ${archetype.name}.

Character traits: ${npc.traits.join(', ')}
Interests: ${npc.interests.join(', ')}
Spending power: ${npc.spendingPower}

Generate:
1. A detailed backstory (2-3 sentences)
2. Personality details (quirks, habits, mannerisms)
3. A secret or interesting fact about them
4. Their potential relationship with the store owner
5. Physical appearance description

Keep the tone ${this.gameState.data.meta.adultContentEnabled ? 'mature and potentially flirtatious' : 'friendly and appropriate'}.`;

        const enrichmentText = await this.aiHooks.generateText(prompt);
        
        // Parse AI response (this would need more sophisticated parsing)
        const enrichmentData = this.parseEnrichmentResponse(enrichmentText);
        
        // Generate avatar
        const avatarPrompt = this.buildAvatarPrompt(npc, enrichmentData);
        const refinedPrompt = `${avatarPrompt}, professional studio headshot, soft diffused lighting, neutral background, 50mm lens, shallow depth of field, natural skin texture, cinematic color grading`;
        const avatarUrl = await this.aiHooks.generateImage(refinedPrompt, {
            style: 'portrait',
            quality: 'high',
            aspectRatio: '1:1',
            skipCache: true
        });
        
        return {
            ...enrichmentData,
            avatar: avatarUrl
        };
    }

    parseEnrichmentResponse(text) {
        // Simple parsing - in production this would be more sophisticated
        return {
            backstory: "Generated backstory from AI",
            personalityDetails: "Generated personality details",
            secrets: ["Generated secret"],
            historyWithPlayer: "No prior history",
            appearance: {
                description: "Generated appearance description",
                prompt: "Generated avatar prompt"
            }
        };
    }

    buildAvatarPrompt(npc, enrichmentData) {
        const archetype = this.archetypeData[npc.archetype];
        
        let prompt = `${npc.age} year old ${npc.gender} person, ${archetype.name.toLowerCase()}`;
        
        if (enrichmentData.appearance?.description) {
            prompt += `, ${enrichmentData.appearance.description}`;
        }
        
        prompt += ', portrait photo, friendly expression, retail customer, realistic';
        
        return prompt;
    }

    applyEnrichment(npc, enrichmentData) {
        npc.backstory = enrichmentData.backstory || '';
        npc.personalityDetails = enrichmentData.personalityDetails || '';
        npc.secrets = enrichmentData.secrets || [];
        npc.historyWithPlayer = enrichmentData.historyWithPlayer || '';
        npc.avatar = enrichmentData.avatar;
        npc.appearance.description = enrichmentData.appearance?.description || '';
        npc.appearance.prompt = enrichmentData.appearance?.prompt || '';
        npc.enrichmentData = enrichmentData;
        npc.isEnriched = true;
    }

    // NPC Management
    generateMoreNPCs(count) {
        for (let i = 0; i < count; i++) {
            const npc = this.generateBasicNPC();
            if (npc) {
                this.gameState.data.npcs.customers.set(npc.id, npc);
                this.enrichmentQueue.push(npc.id);
            }
        }
        
        // Restart enrichment if needed
        if (!this.isEnriching && this.enrichmentQueue.length > 0) {
            this.startBackgroundEnrichment();
        }
    }

    updateRelationship(npcId, change, reason = '') {
        const npc = this.gameState.data.npcs.customers.get(npcId);
        if (!npc) return;
        
        const oldLevel = npc.relationshipLevel;
        npc.relationship = Math.max(0, Math.min(100, npc.relationship + change));
        
        // Update relationship level
        const newLevel = this.getRelationshipLevel(npc.relationship);
        npc.relationshipLevel = newLevel;
        
        // Track relationship events
        if (oldLevel !== newLevel) {
            this.gameState.data.npcs.relationshipEvents.push({
                npcId: npcId,
                oldLevel: oldLevel,
                newLevel: newLevel,
                timestamp: Date.now(),
                reason: reason
            });
            
            this.eventBus.emit('npc.relationshipLevelChanged', {
                npc: npc,
                oldLevel: oldLevel,
                newLevel: newLevel,
                reason: reason
            });
        }
        
        this.eventBus.emit('npc.relationshipChanged', {
            npc: npc,
            change: change,
            reason: reason
        });
    }

    getRelationshipLevel(points) {
        if (points < 20) return 'stranger';
        if (points < 50) return 'regular';
        if (points < 80) return 'friend';
        return 'vip';
    }

    // Utility Methods
    generateId() {
        return 'npc_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
    }

    getNPC(npcId) {
        return this.gameState.data.npcs.customers.get(npcId);
    }

    getAllNPCs() {
        return Array.from(this.gameState.data.npcs.customers.values());
    }

    getEncounteredNPCs() {
        return this.getAllNPCs().filter(npc => npc.visitCount > 0);
    }

    getNPCsByRelationshipLevel(level) {
        return this.getAllNPCs().filter(npc => npc.relationshipLevel === level);
    }

    searchNPCs(query) {
        const lowerQuery = query.toLowerCase();
        return this.getAllNPCs().filter(npc => 
            npc.name.toLowerCase().includes(lowerQuery) ||
            npc.archetype.toLowerCase().includes(lowerQuery) ||
            npc.traits.some(trait => trait.toLowerCase().includes(lowerQuery))
        );
    }

    // NPC Registry for Work Computer
    getNPCRegistry() {
        return {
            total: this.gameState.data.npcs.customers.size,
            encountered: this.getEncounteredNPCs().length,
            byLevel: {
                stranger: this.getNPCsByRelationshipLevel('stranger').length,
                regular: this.getNPCsByRelationshipLevel('regular').length,
                friend: this.getNPCsByRelationshipLevel('friend').length,
                vip: this.getNPCsByRelationshipLevel('vip').length
            },
            recentEncounters: this.gameState.data.npcs.encounterHistory.slice(0, 10),
            topRelationships: this.getAllNPCs()
                .sort((a, b) => b.relationship - a.relationship)
                .slice(0, 10)
        };
    }

    // Handle enriched NPC data from AI enhancer
    onNPCEnriched(data) {
        const { npc } = data;
        console.log(`‚ú® NPC ${npc.name} has been enriched with AI data`);
        
        // Update Customer Relations app if open
        if (typeof customerRelationsApp !== 'undefined' && customerRelationsApp.isOpen) {
            customerRelationsApp.refreshNPCData();
        }
    }

    // Apply enrichment data (handles both old and new format)
    applyEnrichment(npc, enrichmentData) {
        if (!enrichmentData) return;

        // Handle new AI enhancer format
        if (enrichmentData.aiEnriched) {
            npc.backstory = enrichmentData.backstory || npc.backstory;
            npc.personalityTraits = enrichmentData.personalityTraits || {};
            npc.behaviorPatterns = enrichmentData.behaviorPatterns || {};
            npc.secrets = enrichmentData.secrets || [];
            npc.relationshipData = enrichmentData.relationshipData || {};
            npc.profileImagePrompt = enrichmentData.profileImagePrompt || '';
            npc.enrichmentData = enrichmentData;
            npc.isEnriched = true;
            npc.aiEnhanced = true;
        } else {
            // Handle legacy format
            npc.backstory = enrichmentData.backstory || npc.backstory;
            npc.personalityDetails = enrichmentData.personalityDetails || '';
            npc.secrets = enrichmentData.secrets || [];
            npc.historyWithPlayer = enrichmentData.historyWithPlayer || '';
            npc.appearance = enrichmentData.appearance || npc.appearance;
            npc.avatar = enrichmentData.avatar || npc.avatar;
            npc.isEnriched = true;
        }

        // Update timestamps
        npc.lastEnrichment = Date.now();
    }

    // Update NPC data (for external use by AI enhancer)
    updateNPC(updatedNPC) {
        if (!updatedNPC.id) return;
        
        const existingNPC = this.gameState.data.npcs.customers.get(updatedNPC.id);
        if (existingNPC) {
            // Merge the updates
            Object.assign(existingNPC, updatedNPC);
            console.log(`üìù Updated NPC: ${existingNPC.name}`);
        }
    }

    // Queue NPC for background enrichment
    queueNPCForEnrichment(npc) {
        if (this.npcAIEnhancer && !npc.isEnriched) {
            this.npcAIEnhancer.addToEnrichmentQueue(npc);
        } else if (!this.enrichmentQueue.includes(npc.id)) {
            this.enrichmentQueue.push(npc.id);
        }
    }

    // Generate profile image for NPC
    async generateNPCProfileImage(npc) {
        if (!this.aiHooks || npc.avatar) return npc.avatar;

        try {
            const prompt = npc.profileImagePrompt || this.buildAvatarPrompt(npc);
            const imageUrl = await this.aiHooks.generateImage(prompt, {
                style: 'portrait',
                quality: 'medium',
                aspectRatio: '1:1'
            });

            npc.avatar = imageUrl;
            return imageUrl;
        } catch (error) {
            console.error(`‚ùå Failed to generate profile image for ${npc.name}:`, error);
            return null;
        }
    }

    // Debug and Testing
    debugInfo() {
        return {
            totalNPCs: this.gameState.data.npcs.customers.size,
            enrichmentQueue: this.enrichmentQueue.length,
            encounterQueue: this.encounterQueue.length,
            isEnriching: this.isEnriching,
            archetypes: Object.keys(this.archetypeData)
        };
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = NPCSystem;
} else if (typeof window !== 'undefined') {
    window.NPCSystem = NPCSystem;
}


/* === scripts/systems/productSystem.js === */
/**
 * Product System - Manages product data, categories, and catalog
 * Handles product information, pricing, and product display mechanics
 */

class ProductSystem {
    constructor() {
        this.gameState = null;
        this.eventBus = null;
        this.products = new Map();
        this.categories = new Map();
        this.productCatalog = {
            featured: [],
            onSale: [],
            newArrivals: [],
            trending: []
        };
        this.priceModifiers = new Map();
        this.seasonalPricing = new Map();
    }

    initialize(gameState, eventBus) {
        this.gameState = gameState;
        this.eventBus = eventBus;
        
        // Initialize Product AI Generator if available
        if (typeof productAIGenerator !== 'undefined') {
            if (typeof aiHooks !== 'undefined') {
                productAIGenerator.initialize(aiHooks);
            }
            this.productAIGenerator = productAIGenerator;
            console.log('üéØ Product AI Generator connected to Product System');
        }
        
        // Listen for product events
        this.eventBus.on('product.create', (data) => this.createProduct(data));
        this.eventBus.on('product.update', (data) => this.updateProduct(data));
        this.eventBus.on('product.delete', (productId) => this.deleteProduct(productId));
        this.eventBus.on('product.search', (query) => this.searchProducts(query));
        this.eventBus.on('product.getPricing', (data) => this.calculateDynamicPricing(data));
        this.eventBus.on('product.getCatalog', (filters) => this.getProductCatalog(filters));
        this.eventBus.on('product.generateAI', (options) => this.generateAIProduct(options));
        
        // Initialize default categories and products
        this.initializeDefaultCategories();
        this.initializeDefaultProducts();
        this.setupPricingRules();
        
        console.log('üì¶ Product System initialized');
    }

    initializeDefaultCategories() {
        const defaultCategories = [
            {
                id: 'clothing',
                name: 'Clothing & Apparel',
                description: 'Fashion items, underwear, accessories',
                parentId: null,
                displayOrder: 1,
                isActive: true,
                ageRestriction: 18,
                metadata: {
                    icon: 'üëï',
                    color: '#e11d48',
                    tags: ['fashion', 'apparel', 'adult']
                }
            },
            {
                id: 'toys',
                name: 'Adult Toys & Accessories',
                description: 'Adult entertainment products and accessories',
                parentId: null,
                displayOrder: 2,
                isActive: true,
                ageRestriction: 18,
                metadata: {
                    icon: 'üé≠',
                    color: '#7c3aed',
                    tags: ['toys', 'accessories', 'entertainment']
                }
            },
            {
                id: 'media',
                name: 'Media & Entertainment',
                description: 'Books, magazines, digital content',
                parentId: null,
                displayOrder: 3,
                isActive: true,
                ageRestriction: 18,
                metadata: {
                    icon: 'üìö',
                    color: '#059669',
                    tags: ['media', 'books', 'digital']
                }
            },
            {
                id: 'wellness',
                name: 'Health & Wellness',
                description: 'Personal care and wellness products',
                parentId: null,
                displayOrder: 4,
                isActive: true,
                ageRestriction: 18,
                metadata: {
                    icon: 'üíä',
                    color: '#dc2626',
                    tags: ['health', 'wellness', 'care']
                }
            },
            {
                id: 'gifts',
                name: 'Gifts & Novelties',
                description: 'Special occasion gifts and novelty items',
                parentId: null,
                displayOrder: 5,
                isActive: true,
                ageRestriction: 18,
                metadata: {
                    icon: 'üéÅ',
                    color: '#d97706',
                    tags: ['gifts', 'novelty', 'special']
                }
            }
        ];

        // Add subcategories
        const subcategories = [
            // Clothing subcategories
            { id: 'lingerie', name: 'Lingerie', parentId: 'clothing', displayOrder: 1 },
            { id: 'costumes', name: 'Costumes & Roleplay', parentId: 'clothing', displayOrder: 2 },
            { id: 'accessories', name: 'Fashion Accessories', parentId: 'clothing', displayOrder: 3 },
            
            // Toys subcategories
            { id: 'vibrators', name: 'Vibrators', parentId: 'toys', displayOrder: 1 },
            { id: 'couples', name: 'Couples Items', parentId: 'toys', displayOrder: 2 },
            { id: 'novelty-toys', name: 'Novelty Items', parentId: 'toys', displayOrder: 3 },
            
            // Media subcategories
            { id: 'books', name: 'Adult Books', parentId: 'media', displayOrder: 1 },
            { id: 'magazines', name: 'Magazines', parentId: 'media', displayOrder: 2 },
            { id: 'digital', name: 'Digital Content', parentId: 'media', displayOrder: 3 },
            
            // Wellness subcategories
            { id: 'lubricants', name: 'Lubricants', parentId: 'wellness', displayOrder: 1 },
            { id: 'enhancement', name: 'Enhancement Products', parentId: 'wellness', displayOrder: 2 },
            { id: 'cleansers', name: 'Cleansers & Care', parentId: 'wellness', displayOrder: 3 },
            
            // Gifts subcategories
            { id: 'party', name: 'Party Supplies', parentId: 'gifts', displayOrder: 1 },
            { id: 'games', name: 'Adult Games', parentId: 'gifts', displayOrder: 2 },
            { id: 'kits', name: 'Gift Sets & Kits', parentId: 'gifts', displayOrder: 3 }
        ];

        // Create categories
        [...defaultCategories, ...subcategories].forEach(category => {
            this.createCategory(category);
        });
    }

    initializeDefaultProducts() {
        const defaultProducts = [
            // Lingerie
            {
                id: 'lg001',
                name: 'Silk Night Set',
                categoryId: 'lingerie',
                basePrice: 89.99,
                cost: 35.00,
                description: 'Luxurious silk nightwear set with delicate lace trim',
                brand: 'Intimate Elegance',
                tags: ['silk', 'luxury', 'nightwear', 'lace'],
                variants: [
                    { size: 'S', color: 'Black', sku: 'LG001-S-BLK' },
                    { size: 'M', color: 'Black', sku: 'LG001-M-BLK' },
                    { size: 'L', color: 'Black', sku: 'LG001-L-BLK' },
                    { size: 'S', color: 'Red', sku: 'LG001-S-RED' },
                    { size: 'M', color: 'Red', sku: 'LG001-M-RED' },
                    { size: 'L', color: 'Red', sku: 'LG001-L-RED' }
                ],
                features: ['Machine washable', 'Breathable fabric', 'Adjustable straps'],
                ageRestriction: 18,
                isDiscrete: true
            },
            {
                id: 'lg002',
                name: 'Romantic Lace Bodysuit',
                categoryId: 'lingerie',
                basePrice: 65.99,
                cost: 25.00,
                description: 'Romantic lace bodysuit with intricate patterns',
                brand: 'Passion Collection',
                tags: ['lace', 'bodysuit', 'romantic', 'stretchy'],
                variants: [
                    { size: 'S', color: 'White', sku: 'LG002-S-WHT' },
                    { size: 'M', color: 'White', sku: 'LG002-M-WHT' },
                    { size: 'L', color: 'White', sku: 'LG002-L-WHT' },
                    { size: 'XL', color: 'White', sku: 'LG002-XL-WHT' }
                ],
                features: ['Stretch fabric', 'Snap closure', 'Comfortable fit'],
                ageRestriction: 18,
                isDiscrete: true
            },

            // Wellness Products
            {
                id: 'wl001',
                name: 'Premium Personal Lubricant',
                categoryId: 'lubricants',
                basePrice: 24.99,
                cost: 8.00,
                description: 'Water-based personal lubricant for enhanced comfort',
                brand: 'TenderTouch',
                tags: ['water-based', 'safe', 'comfort', 'premium'],
                variants: [
                    { size: '50ml', type: 'Original', sku: 'WL001-50-ORG' },
                    { size: '100ml', type: 'Original', sku: 'WL001-100-ORG' },
                    { size: '50ml', type: 'Warming', sku: 'WL001-50-WRM' },
                    { size: '100ml', type: 'Warming', sku: 'WL001-100-WRM' }
                ],
                features: ['Dermatologist tested', 'Long-lasting', 'Easy cleanup'],
                ageRestriction: 18,
                isDiscrete: true
            },

            // Books & Media
            {
                id: 'bk001',
                name: 'The Art of Intimacy - Guide Book',
                categoryId: 'books',
                basePrice: 34.99,
                cost: 12.00,
                description: 'Educational guide for couples seeking to enhance their relationship',
                brand: 'Relationship Press',
                tags: ['educational', 'couples', 'guide', 'relationship'],
                variants: [
                    { format: 'Paperback', language: 'English', sku: 'BK001-PB-EN' },
                    { format: 'Hardcover', language: 'English', sku: 'BK001-HC-EN' },
                    { format: 'Digital', language: 'English', sku: 'BK001-DIG-EN' }
                ],
                features: ['Expert advice', 'Illustrated guide', 'Discrete packaging'],
                ageRestriction: 18,
                isDiscrete: true
            },

            // Adult Toys
            {
                id: 'ty001',
                name: 'Beginner-Friendly Massager',
                categoryId: 'vibrators',
                basePrice: 79.99,
                cost: 30.00,
                description: 'Gentle and quiet personal massager perfect for beginners',
                brand: 'SoftTouch Wellness',
                tags: ['beginner', 'quiet', 'rechargeable', 'waterproof'],
                variants: [
                    { color: 'Pink', material: 'Silicone', sku: 'TY001-PNK-SIL' },
                    { color: 'Purple', material: 'Silicone', sku: 'TY001-PUR-SIL' },
                    { color: 'Teal', material: 'Silicone', sku: 'TY001-TEL-SIL' }
                ],
                features: ['USB rechargeable', 'Waterproof', 'Multiple settings', 'Quiet operation'],
                ageRestriction: 18,
                isDiscrete: true
            },

            // Gifts & Games
            {
                id: 'gf001',
                name: 'Romantic Game for Couples',
                categoryId: 'games',
                basePrice: 45.99,
                cost: 18.00,
                description: 'Fun and intimate card game designed for couples',
                brand: 'PlayTime Games',
                tags: ['couples', 'game', 'cards', 'romantic', 'fun'],
                variants: [
                    { edition: 'Classic', level: 'Mild', sku: 'GF001-CLS-MLD' },
                    { edition: 'Adventurous', level: 'Spicy', sku: 'GF001-ADV-SPC' }
                ],
                features: ['100 cards', 'Multiple game modes', 'Relationship building'],
                ageRestriction: 18,
                isDiscrete: true
            },

            // Costumes
            {
                id: 'cs001',
                name: 'Professional Fantasy Costume',
                categoryId: 'costumes',
                basePrice: 69.99,
                cost: 25.00,
                description: 'High-quality costume for role-playing adventures',
                brand: 'Fantasy Wardrobe',
                tags: ['costume', 'roleplay', 'professional', 'quality'],
                variants: [
                    { theme: 'Nurse', size: 'S', sku: 'CS001-NRS-S' },
                    { theme: 'Nurse', size: 'M', sku: 'CS001-NRS-M' },
                    { theme: 'Nurse', size: 'L', sku: 'CS001-NRS-L' },
                    { theme: 'Teacher', size: 'S', sku: 'CS001-TCH-S' },
                    { theme: 'Teacher', size: 'M', sku: 'CS001-TCH-M' },
                    { theme: 'Teacher', size: 'L', sku: 'CS001-TCH-L' }
                ],
                features: ['Complete outfit', 'Comfortable fabric', 'Authentic styling'],
                ageRestriction: 18,
                isDiscrete: true
            }
        ];

        // Create products
        defaultProducts.forEach(product => {
            this.createProduct(product);
        });

        // Set up featured products and promotions
        this.updateProductCatalog();
    }

    setupPricingRules() {
        // Dynamic pricing modifiers based on various factors
        this.priceModifiers.set('bulk_discount', {
            name: 'Bulk Discount',
            type: 'quantity',
            conditions: [
                { minQuantity: 3, discount: 0.10 },
                { minQuantity: 5, discount: 0.15 },
                { minQuantity: 10, discount: 0.20 }
            ]
        });

        this.priceModifiers.set('loyalty_discount', {
            name: 'Loyalty Discount',
            type: 'customer',
            conditions: [
                { tier: 'regular', discount: 0.05 },
                { tier: 'vip', discount: 0.10 },
                { tier: 'premium', discount: 0.15 }
            ]
        });

        this.priceModifiers.set('seasonal_pricing', {
            name: 'Seasonal Pricing',
            type: 'seasonal',
            conditions: [
                { season: 'valentine', markup: 0.10, categories: ['lingerie', 'gifts'] },
                { season: 'summer', discount: 0.15, categories: ['wellness'] },
                { season: 'holiday', markup: 0.05, categories: ['gifts', 'games'] }
            ]
        });

        this.priceModifiers.set('clearance', {
            name: 'Clearance Sale',
            type: 'clearance',
            conditions: [
                { reason: 'overstock', discount: 0.30 },
                { reason: 'discontinued', discount: 0.50 },
                { reason: 'damaged_packaging', discount: 0.20 }
            ]
        });
    }

    createCategory(categoryData) {
        const category = {
            id: categoryData.id,
            name: categoryData.name,
            description: categoryData.description || '',
            parentId: categoryData.parentId || null,
            displayOrder: categoryData.displayOrder || 0,
            isActive: categoryData.isActive !== false,
            ageRestriction: categoryData.ageRestriction || 18,
            metadata: categoryData.metadata || {},
            createdAt: new Date(),
            updatedAt: new Date()
        };

        this.categories.set(category.id, category);
        
        this.eventBus.emit('product.categoryCreated', { category });
        return category;
    }

    createProduct(productData) {
        const product = {
            id: productData.id,
            name: productData.name,
            categoryId: productData.categoryId,
            basePrice: productData.basePrice,
            currentPrice: productData.basePrice,
            cost: productData.cost,
            margin: ((productData.basePrice - productData.cost) / productData.basePrice * 100).toFixed(2),
            description: productData.description,
            brand: productData.brand || 'Generic',
            tags: productData.tags || [],
            variants: productData.variants || [],
            features: productData.features || [],
            ageRestriction: productData.ageRestriction || 18,
            isDiscrete: typeof productData.isDiscrete === 'boolean' ? productData.isDiscrete : true,
            isActive: true,
            rating: 0,
            reviewCount: 0,
            salesCount: 0,
            createdAt: new Date(),
            updatedAt: new Date(),
            metadata: {
                supplier: productData.supplier || 'Default Supplier',
                barcode: productData.barcode || this.generateBarcode(),
                weight: productData.weight || 0,
                dimensions: productData.dimensions || { length: 0, width: 0, height: 0 },
                materials: productData.materials || [],
                careInstructions: productData.careInstructions || []
            }
        };

        this.products.set(product.id, product);
        
        this.eventBus.emit('product.created', { product });
        return product;
    }

    updateProduct(productId, updates) {
        const product = this.products.get(productId);
        if (!product) {
            throw new Error(`Product ${productId} not found`);
        }

        // Apply updates
        Object.keys(updates).forEach(key => {
            if (key !== 'id' && key !== 'createdAt') {
                product[key] = updates[key];
            }
        });

        // Recalculate margin if price or cost changed
        if (updates.basePrice || updates.cost) {
            product.margin = ((product.basePrice - product.cost) / product.basePrice * 100).toFixed(2);
        }

        product.updatedAt = new Date();
        
        this.eventBus.emit('product.updated', { product, updates });
        return product;
    }

    deleteProduct(productId) {
        const product = this.products.get(productId);
        if (!product) {
            throw new Error(`Product ${productId} not found`);
        }

        this.products.delete(productId);
        this.eventBus.emit('product.deleted', { productId, product });
        return true;
    }

    getProduct(productId) {
        return this.products.get(productId);
    }

    getCategory(categoryId) {
        return this.categories.get(categoryId);
    }

    searchProducts(query) {
        const searchTerms = query.toLowerCase().split(' ');
        const results = [];

        this.products.forEach(product => {
            if (!product.isActive) return;

            let score = 0;
            
            // Search in name
            searchTerms.forEach(term => {
                if (product.name.toLowerCase().includes(term)) score += 10;
                if (product.description.toLowerCase().includes(term)) score += 5;
                if (product.brand.toLowerCase().includes(term)) score += 3;
                product.tags.forEach(tag => {
                    if (tag.toLowerCase().includes(term)) score += 2;
                });
            });

            if (score > 0) {
                results.push({ product, score });
            }
        });

        // Sort by relevance score
        results.sort((a, b) => b.score - a.score);
        
        return results.map(result => result.product);
    }

    getProductsByCategory(categoryId, includeSubcategories = true) {
        const products = [];
        const targetCategories = new Set([categoryId]);

        if (includeSubcategories) {
            this.categories.forEach(category => {
                if (category.parentId === categoryId) {
                    targetCategories.add(category.id);
                }
            });
        }

        this.products.forEach(product => {
            if (product.isActive && targetCategories.has(product.categoryId)) {
                products.push(product);
            }
        });

        return products;
    }

    calculateDynamicPricing(data) {
        const { productId, quantity = 1, customerId = null, context = {} } = data;
        const product = this.getProduct(productId);
        
        if (!product) {
            throw new Error(`Product ${productId} not found`);
        }

        let finalPrice = product.basePrice;
        const appliedModifiers = [];

        // Apply quantity discounts
        const bulkDiscount = this.priceModifiers.get('bulk_discount');
        if (quantity >= 3) {
            const applicableDiscount = bulkDiscount.conditions
                .filter(condition => quantity >= condition.minQuantity)
                .sort((a, b) => b.discount - a.discount)[0];
            
            if (applicableDiscount) {
                finalPrice *= (1 - applicableDiscount.discount);
                appliedModifiers.push({
                    type: 'bulk_discount',
                    description: `${Math.round(applicableDiscount.discount * 100)}% bulk discount`,
                    value: -product.basePrice * applicableDiscount.discount
                });
            }
        }

        // Apply loyalty discounts
        if (customerId && this.gameState.npcs.has(customerId)) {
            const customer = this.gameState.npcs.get(customerId);
            const loyaltyDiscount = this.priceModifiers.get('loyalty_discount');
            const tier = customer.relationship?.tier || 'regular';
            
            const applicableDiscount = loyaltyDiscount.conditions.find(condition => condition.tier === tier);
            if (applicableDiscount) {
                const discountAmount = product.basePrice * applicableDiscount.discount;
                finalPrice -= discountAmount;
                appliedModifiers.push({
                    type: 'loyalty_discount',
                    description: `${Math.round(applicableDiscount.discount * 100)}% loyalty discount`,
                    value: -discountAmount
                });
            }
        }

        // Apply seasonal pricing
        const currentSeason = this.getCurrentSeason();
        if (currentSeason) {
            const seasonalPricing = this.priceModifiers.get('seasonal_pricing');
            const applicableSeasonalRule = seasonalPricing.conditions.find(condition => 
                condition.season === currentSeason && 
                condition.categories.includes(product.categoryId)
            );
            
            if (applicableSeasonalRule) {
                if (applicableSeasonalRule.discount) {
                    const discountAmount = product.basePrice * applicableSeasonalRule.discount;
                    finalPrice -= discountAmount;
                    appliedModifiers.push({
                        type: 'seasonal_discount',
                        description: `${Math.round(applicableSeasonalRule.discount * 100)}% seasonal discount`,
                        value: -discountAmount
                    });
                } else if (applicableSeasonalRule.markup) {
                    const markupAmount = product.basePrice * applicableSeasonalRule.markup;
                    finalPrice += markupAmount;
                    appliedModifiers.push({
                        type: 'seasonal_markup',
                        description: `${Math.round(applicableSeasonalRule.markup * 100)}% seasonal premium`,
                        value: markupAmount
                    });
                }
            }
        }

        // Apply clearance pricing if applicable
        if (product.metadata.clearanceReason) {
            const clearance = this.priceModifiers.get('clearance');
            const applicableDiscount = clearance.conditions.find(condition => 
                condition.reason === product.metadata.clearanceReason
            );
            
            if (applicableDiscount) {
                const discountAmount = product.basePrice * applicableDiscount.discount;
                finalPrice -= discountAmount;
                appliedModifiers.push({
                    type: 'clearance',
                    description: `${Math.round(applicableDiscount.discount * 100)}% clearance sale`,
                    value: -discountAmount
                });
            }
        }

        // Ensure minimum price (cost + small margin)
        const minimumPrice = product.cost * 1.05; // 5% minimum margin
        finalPrice = Math.max(finalPrice, minimumPrice);

        return {
            productId,
            basePrice: product.basePrice,
            finalPrice: Math.round(finalPrice * 100) / 100,
            totalPrice: Math.round(finalPrice * quantity * 100) / 100,
            quantity,
            appliedModifiers,
            savings: Math.round((product.basePrice - finalPrice) * 100) / 100
        };
    }

    getProductCatalog(filters = {}) {
        const {
            category = null,
            priceRange = null,
            sortBy = 'name',
            sortOrder = 'asc',
            featured = false,
            onSale = false,
            limit = null
        } = filters;

        let products = Array.from(this.products.values()).filter(product => product.isActive);

        // Apply category filter
        if (category) {
            products = this.getProductsByCategory(category);
        }

        // Apply price range filter
        if (priceRange) {
            products = products.filter(product => 
                product.currentPrice >= priceRange.min && 
                product.currentPrice <= priceRange.max
            );
        }

        // Apply featured filter
        if (featured) {
            products = products.filter(product => 
                this.productCatalog.featured.includes(product.id)
            );
        }

        // Apply on sale filter
        if (onSale) {
            products = products.filter(product => 
                this.productCatalog.onSale.includes(product.id)
            );
        }

        // Sort products
        products.sort((a, b) => {
            let aValue = a[sortBy];
            let bValue = b[sortBy];
            
            if (typeof aValue === 'string') {
                aValue = aValue.toLowerCase();
                bValue = bValue.toLowerCase();
            }
            
            if (sortOrder === 'desc') {
                return aValue < bValue ? 1 : -1;
            } else {
                return aValue > bValue ? 1 : -1;
            }
        });

        // Apply limit
        if (limit) {
            products = products.slice(0, limit);
        }

        return products;
    }

    updateProductCatalog() {
        // Update featured products (highest rated or best sellers)
        const allProducts = Array.from(this.products.values())
            .filter(product => product.isActive)
            .sort((a, b) => (b.rating * b.reviewCount + b.salesCount) - (a.rating * a.reviewCount + a.salesCount));
        
        this.productCatalog.featured = allProducts.slice(0, 8).map(p => p.id);

        // Update on sale products (those with active discounts)
        this.productCatalog.onSale = allProducts
            .filter(product => product.metadata.clearanceReason)
            .slice(0, 12)
            .map(p => p.id);

        // Update trending products (recent high sales)
        this.productCatalog.trending = allProducts
            .filter(product => product.salesCount > 0)
            .sort((a, b) => b.salesCount - a.salesCount)
            .slice(0, 10)
            .map(p => p.id);

        // Update new arrivals (recently added products)
        this.productCatalog.newArrivals = allProducts
            .sort((a, b) => b.createdAt - a.createdAt)
            .slice(0, 6)
            .map(p => p.id);

        this.eventBus.emit('product.catalogUpdated', { catalog: this.productCatalog });
    }

    getCurrentSeason() {
        const now = new Date();
        const month = now.getMonth() + 1;
        
        // Simple seasonal detection
        if (month === 2) return 'valentine';
        if (month >= 6 && month <= 8) return 'summer';
        if (month === 12) return 'holiday';
        
        return null;
    }

    generateBarcode() {
        return '80' + Math.random().toString().slice(2, 13);
    }

    getProductVariants(productId) {
        const product = this.getProduct(productId);
        return product ? product.variants : [];
    }

    getProductsByBrand(brand) {
        return Array.from(this.products.values())
            .filter(product => product.isActive && product.brand.toLowerCase() === brand.toLowerCase());
    }

    addProductReview(productId, rating, review) {
        const product = this.getProduct(productId);
        if (!product) return false;

        // Update rating (simple average for now)
        const totalRating = product.rating * product.reviewCount + rating;
        product.reviewCount++;
        product.rating = Math.round((totalRating / product.reviewCount) * 10) / 10;
        
        product.updatedAt = new Date();
        
        this.eventBus.emit('product.reviewAdded', { productId, rating, review });
        return true;
    }

    incrementSalesCount(productId, quantity = 1) {
        const product = this.getProduct(productId);
        if (!product) return false;

        product.salesCount += quantity;
        product.updatedAt = new Date();
        
        this.eventBus.emit('product.saleMade', { productId, quantity });
        return true;
    }

    getPopularProducts(limit = 10) {
        return Array.from(this.products.values())
            .filter(product => product.isActive)
            .sort((a, b) => b.salesCount - a.salesCount)
            .slice(0, limit);
    }

    getProductRecommendations(customerId, limit = 5) {
        // Simple recommendation based on purchase history and preferences
        const recommendations = [];
        const customer = this.gameState.npcs.get(customerId);
        
        if (customer && customer.preferences) {
            const preferredCategories = customer.preferences.productCategories || [];
            const preferredTags = customer.preferences.tags || [];
            
            this.products.forEach(product => {
                if (!product.isActive) return;
                
                let score = 0;
                
                // Category preference
                if (preferredCategories.includes(product.categoryId)) score += 5;
                
                // Tag preference
                product.tags.forEach(tag => {
                    if (preferredTags.includes(tag)) score += 2;
                });
                
                // Popular products get slight boost
                score += Math.min(product.salesCount * 0.1, 3);
                
                if (score > 0) {
                    recommendations.push({ product, score });
                }
            });
            
            recommendations.sort((a, b) => b.score - a.score);
            return recommendations.slice(0, limit).map(r => r.product);
        }
        
        // Fallback to popular products
        return this.getPopularProducts(limit);
    }

    // AI Product Generation Methods
    async generateAIProduct(options = {}) {
        if (!this.productAIGenerator) {
            console.warn('‚ö†Ô∏è Product AI Generator not available');
            return null;
        }

        try {
            const generatedProduct = await this.productAIGenerator.generateProduct(options);
            
            // Convert AI product format to system format
            const productData = this.convertAIProductToSystemFormat(generatedProduct);
            
            // Add to inventory
            const product = this.createProduct(productData);
            
            // Generate product image if needed
            if (generatedProduct.imagePrompt && !generatedProduct.image) {
                this.generateProductImage(product, generatedProduct.imagePrompt);
            }
            
            console.log(`‚ú® AI-generated product added: ${product.name}`);
            return product;
        } catch (error) {
            console.error('‚ùå Failed to generate AI product:', error);
            return null;
        }
    }

    // Convert AI-generated product to system format
    convertAIProductToSystemFormat(aiProduct) {
        return {
            id: aiProduct.id,
            name: aiProduct.name,
            categoryId: aiProduct.category,
            basePrice: aiProduct.price,
            cost: aiProduct.cost,
            description: aiProduct.description,
            brand: 'AI Generated',
            tags: aiProduct.tags || [],
            features: aiProduct.features || [],
            ageRestriction: aiProduct.ageRestriction || 18,
            isDiscrete: true,
            materials: aiProduct.materials || [],
            metadata: {
                aiGenerated: true,
                generationDate: aiProduct.generationDate,
                rarity: aiProduct.rarity,
                imagePrompt: aiProduct.imagePrompt,
                concept: aiProduct.concept,
                seasonal: aiProduct.seasonal,
                trending: aiProduct.trending
            }
        };
    }

    // Generate multiple AI products
    async generateMultipleAIProducts(count, options = {}) {
        const products = [];
        
        for (let i = 0; i < count; i++) {
            try {
                const product = await this.generateAIProduct(options);
                if (product) {
                    products.push(product);
                }
                
                // Brief pause between generations
                await new Promise(resolve => setTimeout(resolve, 1000));
            } catch (error) {
                console.error(`‚ùå Failed to generate product ${i + 1}:`, error);
            }
        }
        
        console.log(`‚úÖ Generated ${products.length} AI products`);
        return products;
    }

    // Generate seasonal product collection
    async generateSeasonalCollection(season, count = 5) {
        return this.generateMultipleAIProducts(count, {
            seasonal: true,
            trending: Math.random() > 0.5 // 50% chance of trending
        });
    }

    // Generate trending products
    async generateTrendingProducts(count = 3) {
        return this.generateMultipleAIProducts(count, {
            trending: true,
            rarity: Math.random() > 0.7 ? 'rare' : 'uncommon' // Higher rarity for trending
        });
    }

    // Generate product image using AI
    async generateProductImage(product, imagePrompt) {
        if (this.productAIGenerator) {
            try {
                const imageUrl = await this.productAIGenerator.generateProductImage({
                    ...product,
                    imagePrompt: imagePrompt || product.metadata?.imagePrompt
                });
                
                if (imageUrl) {
                    product.imageUrl = imageUrl;
                    product.metadata.hasAIImage = true;
                    this.eventBus.emit('product.imageGenerated', { product, imageUrl });
                }
                
                return imageUrl;
            } catch (error) {
                console.error(`‚ùå Failed to generate image for ${product.name}:`, error);
                return null;
            }
        }
        return null;
    }

    // Get AI generation statistics
    getAIGenerationStats() {
        const aiProducts = Array.from(this.products.values()).filter(p => p.metadata?.aiGenerated);
        
        return {
            totalAIProducts: aiProducts.length,
            totalProducts: this.products.size,
            aiPercentage: ((aiProducts.length / this.products.size) * 100).toFixed(1),
            byCategory: this.groupProductsByCategory(aiProducts),
            byRarity: this.groupProductsByRarity(aiProducts),
            seasonal: aiProducts.filter(p => p.metadata?.seasonal).length,
            trending: aiProducts.filter(p => p.metadata?.trending).length
        };
    }

    groupProductsByCategory(products) {
        const grouped = {};
        products.forEach(product => {
            const category = product.categoryId;
            grouped[category] = (grouped[category] || 0) + 1;
        });
        return grouped;
    }

    groupProductsByRarity(products) {
        const grouped = {};
        products.forEach(product => {
            const rarity = product.metadata?.rarity || 'common';
            grouped[rarity] = (grouped[rarity] || 0) + 1;
        });
        return grouped;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ProductSystem;
} else if (typeof window !== 'undefined') {
    window.ProductSystem = ProductSystem;
}


/* === scripts/systems/conversationSystem.js === */
/**
 * Conversation System - Handles dialogue trees and customer interactions
 * Manages player responses, AI dialogue generation, and conversation flow
 */

class ConversationSystem {
    constructor() {
        this.gameState = null;
        this.eventBus = null;
        this.aiHooks = null;
        this.npcSystem = null;
        this.dialogueAI = null; // Phase 4C: AI Dialogue Generator
        this.currentConversation = null;
        this.conversationHistory = [];
        this.dialogueOptions = null;
        this.conversationTimeout = null;
        this.isWaitingForResponse = false;
    }

    initialize(gameState, eventBus, aiHooks, npcSystem, dialogueAI = null) {
        this.gameState = gameState;
        this.eventBus = eventBus;
        this.aiHooks = aiHooks;
        this.npcSystem = npcSystem;
        this.dialogueAI = dialogueAI; // Phase 4C: Enhanced AI dialogue
        
        // Listen for conversation events
        this.eventBus.on('conversation.start', (data) => this.startConversation(data));
        this.eventBus.on('conversation.playerResponse', (data) => this.handlePlayerResponse(data));
        this.eventBus.on('conversation.end', () => this.endConversation());
        this.eventBus.on('customer.greet', (data) => this.handleGreeting(data));
        this.eventBus.on('customer.question', (data) => this.handleQuestion(data));
        this.eventBus.on('customer.complaint', (data) => this.handleComplaint(data));
        
        // Load dialogue templates
        this.loadDialogueTemplates();
        
        console.log('üí¨ Conversation System initialized');
    }

    loadDialogueTemplates() {
        // Pre-defined dialogue patterns for different scenarios
        this.dialogueTemplates = {
            greetings: {
                friendly: [
                    "Welcome to our store! How can I help you today?",
                    "Good [timeOfDay]! What brings you in today?",
                    "Hi there! Let me know if you need anything!",
                    "Welcome! I'm here if you have any questions."
                ],
                professional: [
                    "Good [timeOfDay]. How may I assist you?",
                    "Welcome to [storeName]. What can I help you find?",
                    "Hello. Please let me know if you need assistance.",
                    "Good [timeOfDay]. How can I be of service?"
                ],
                casual: [
                    "Hey! What's up?",
                    "Hi! Looking for anything specific?",
                    "What can I do for ya?",
                    "Hey there! Need any help?"
                ]
            },
            
            responses: {
                helpful: [
                    "I'd be happy to help you with that!",
                    "Let me see what I can do for you.",
                    "Absolutely! I can help you find that.",
                    "No problem at all! Let me assist you."
                ],
                apologetic: [
                    "I'm sorry about that. Let me make it right.",
                    "I apologize for the inconvenience.",
                    "That's my fault. How can I fix this?",
                    "I'm really sorry. Let me help resolve this."
                ],
                dismissive: [
                    "That's just how it is.",
                    "Nothing I can do about that.",
                    "Store policy is store policy.",
                    "Take it or leave it."
                ],
                flirty: [
                    "I'd love to help someone as lovely as you.",
                    "For you? I'll make an exception.",
                    "You have excellent taste... in stores.",
                    "I'll give you special attention."
                ]
            },
            
            questions: {
                product_inquiry: [
                    "What specific product are you looking for?",
                    "Can you tell me more about what you need?",
                    "What features are most important to you?",
                    "What's your budget range for this item?"
                ],
                recommendation: [
                    "Based on what you've told me, I'd recommend...",
                    "I think you'd really like this option...",
                    "This is our most popular item in that category...",
                    "Given your needs, this would be perfect..."
                ],
                upsell: [
                    "Would you be interested in our premium version?",
                    "Have you considered adding this accessory?",
                    "We have a bundle deal that might save you money...",
                    "This pairs really well with what you're buying..."
                ]
            }
        };
        
        // Response options for different personality types
        this.responseOptions = {
            friendly: {
                tone: "warm and helpful",
                relationshipBonus: 2,
                satisfactionBonus: 3
            },
            professional: {
                tone: "courteous and efficient",
                relationshipBonus: 1,
                satisfactionBonus: 2
            },
            casual: {
                tone: "relaxed and informal",
                relationshipBonus: 1,
                satisfactionBonus: 1
            },
            flirty: {
                tone: "charming and suggestive",
                relationshipBonus: 3,
                satisfactionBonus: 1,
                requiresRelationship: 20
            },
            rude: {
                tone: "dismissive and impatient",
                relationshipBonus: -3,
                satisfactionBonus: -5
            },
            apologetic: {
                tone: "sorry and accommodating",
                relationshipBonus: 1,
                satisfactionBonus: 4
            }
        };
    }

    // Conversation Management
    startConversation(data) {
        const { npc, scenario, context } = data;
        
        if (this.currentConversation) {
            this.endConversation();
        }
        
        this.currentConversation = {
            npc: npc,
            scenario: scenario, // greeting, question, complaint, purchase, etc.
            context: context,
            startTime: Date.now(),
            turnCount: 0,
            messages: [],
            playerSatisfaction: 50, // Start neutral
            npcMood: npc.mood,
            lastPlayerResponse: null
        };
        
        // Set conversation timeout based on NPC patience
        const timeoutDuration = this.calculateConversationTimeout(npc);
        this.conversationTimeout = setTimeout(() => {
            this.handleConversationTimeout();
        }, timeoutDuration);
        
        // Generate initial NPC dialogue
        this.generateNPCResponse(scenario, context);
        
        this.eventBus.emit('conversation.started', {
            conversation: this.currentConversation
        });
        
        console.log(`üí¨ Started conversation with ${npc.name} (${scenario})`);
    }

    async generateNPCResponse(scenario, context = null, playerInput = null) {
        if (!this.currentConversation) return;
        
        const npc = this.currentConversation.npc;
        
        try {
            let npcMessage;
            
            // Phase 4C: Use enhanced AI dialogue generator if available
            if (this.dialogueAI) {
                console.log('ü§ñ Using AI Dialogue Generator for', scenario);
                
                const dialogueContext = {
                    npc: npc,
                    scenario: scenario,
                    context: context,
                    ownerStatement: playerInput,
                    conversation: this.currentConversation
                };
                
                // Generate dialogue based on scenario type
                switch (scenario) {
                    case 'greeting':
                        npcMessage = await this.dialogueAI.generateGreeting(npc, dialogueContext);
                        break;
                    case 'response':
                        npcMessage = await this.dialogueAI.generateResponse(npc, playerInput, dialogueContext);
                        break;
                    case 'product_inquiry':
                        npcMessage = await this.dialogueAI.generateProductInquiry(npc, context.productCategory, dialogueContext);
                        break;
                    case 'negotiation':
                        npcMessage = await this.dialogueAI.generateNegotiation(npc, context.product, dialogueContext);
                        break;
                    case 'complaint':
                        npcMessage = await this.dialogueAI.generateComplaint(npc, context.problem, dialogueContext);
                        break;
                    case 'flirtation':
                        npcMessage = await this.dialogueAI.generateFlirtation(npc, dialogueContext);
                        break;
                    case 'small_talk':
                        npcMessage = await this.dialogueAI.generateSmallTalk(npc, dialogueContext);
                        break;
                    default:
                        npcMessage = await this.dialogueAI.generateResponse(npc, playerInput, dialogueContext);
                }
                
                // Structure the AI response
                const structuredMessage = {
                    text: npcMessage,
                    emotion: this.inferEmotionFromText(npcMessage, npc),
                    tone: this.inferToneFromText(npcMessage),
                    generatedBy: 'ai'
                };
                
                // Add message to conversation
                this.addMessage('npc', structuredMessage.text, structuredMessage.emotion);
                
            } else {
                // Fallback to original system
                console.log('üìù Using template-based dialogue system');
                
                // Build conversation prompt for AI
                const prompt = this.buildConversationPrompt(npc, scenario, context, playerInput);
                
                // Generate AI response
                const aiResponse = await this.aiHooks.generateText(prompt);
                const structuredMessage = this.parseAIResponse(aiResponse);
                
                // Add message to conversation
                this.addMessage('npc', structuredMessage.text, structuredMessage.emotion);
            }
            
            // Generate player response options
            this.generatePlayerOptions(scenario, context);
            
            this.eventBus.emit('conversation.npcResponse', {
                message: npcMessage,
                options: this.dialogueOptions,
                conversation: this.currentConversation
            });
            
        } catch (error) {
            console.error('Failed to generate NPC response:', error);
            // Fallback to template response
            this.generateTemplateResponse(scenario, context);
        }
    }

    buildConversationPrompt(npc, scenario, context, playerInput) {
        const archetype = npc.archetype;
        const mood = npc.mood;
        const relationship = npc.relationshipLevel;
        const conversationHistory = this.currentConversation.messages.slice(-4); // Last 4 messages
        
        let prompt = `You are ${npc.name}, a ${npc.age}-year-old ${npc.gender} ${archetype.replace('_', ' ')}. `;
        prompt += `You are currently ${mood} and your relationship with the store owner is "${relationship}". `;
        
        // Add personality context
        if (npc.personalityDetails) {
            prompt += `Your personality: ${npc.personalityDetails}. `;
        }
        
        // Add scenario context
        switch (scenario) {
            case 'greeting':
                prompt += `You just entered the store. Respond to the store owner's greeting. `;
                break;
            case 'question':
                prompt += `You have a question about a product or service. ${context || ''} `;
                break;
            case 'complaint':
                prompt += `You have a complaint about something. ${context || ''} `;
                break;
            case 'purchase':
                prompt += `You're ready to buy something and need to discuss it. `;
                break;
            case 'casual':
                prompt += `You're having a casual conversation with the store owner. `;
                break;
        }
        
        // Add conversation history
        if (conversationHistory.length > 0) {
            prompt += `\n\nConversation so far:\n`;
            conversationHistory.forEach(msg => {
                const speaker = msg.sender === 'npc' ? npc.name : 'Store Owner';
                prompt += `${speaker}: ${msg.text}\n`;
            });
        }
        
        // Add player input if provided
        if (playerInput) {
            prompt += `\nStore Owner just said: "${playerInput}"\n`;
        }
        
        prompt += `\nRespond as ${npc.name} in character. Keep your response to 1-2 sentences and match your mood (${mood}). `;
        
        // Add content guidelines
        if (this.gameState.data.meta.adultContentEnabled && relationship !== 'stranger') {
            prompt += `Feel free to be flirtatious if appropriate for your character and relationship level. `;
        } else {
            prompt += `Keep the conversation appropriate and business-focused. `;
        }
        
        return prompt;
    }

    parseAIResponse(aiResponse) {
        // Simple parsing - in production this would be more sophisticated
        let text = aiResponse.trim();
        let emotion = 'neutral';
        
        // Try to detect emotion from text
        if (text.includes('!') || text.toLowerCase().includes('great') || text.toLowerCase().includes('love')) {
            emotion = 'happy';
        } else if (text.includes('?')) {
            emotion = 'curious';
        } else if (text.toLowerCase().includes('sorry') || text.toLowerCase().includes('unfortunately')) {
            emotion = 'apologetic';
        } else if (text.toLowerCase().includes('angry') || text.toLowerCase().includes('frustrated')) {
            emotion = 'angry';
        }
        
        return {
            text: text,
            emotion: emotion
        };
    }

    generatePlayerOptions(npcMessage, scenario) {
        const npc = this.currentConversation.npc;
        const relationship = npc.relationshipLevel;
        
        // Base options available to all scenarios
        const baseOptions = [
            {
                id: 'helpful',
                text: "How can I help you with that?",
                tone: 'helpful',
                requiresRelationship: 0
            },
            {
                id: 'professional',
                text: "Let me assist you professionally.",
                tone: 'professional',
                requiresRelationship: 0
            }
        ];
        
        // Scenario-specific options
        const scenarioOptions = this.getScenarioOptions(scenario, npc);
        
        // Relationship-gated options
        const relationshipOptions = this.getRelationshipOptions(relationship, npc);
        
        // Combine and filter options
        this.dialogueOptions = [...baseOptions, ...scenarioOptions, ...relationshipOptions]
            .filter(option => this.canUseOption(option, npc))
            .slice(0, 4); // Limit to 4 options for UI
    }

    getScenarioOptions(scenario, npc) {
        switch (scenario) {
            case 'greeting':
                return [
                    {
                        id: 'friendly_greeting',
                        text: "Welcome! I'm so glad you're here!",
                        tone: 'friendly',
                        requiresRelationship: 0
                    },
                    {
                        id: 'casual_greeting',
                        text: "Hey! What brings you in today?",
                        tone: 'casual',
                        requiresRelationship: 0
                    }
                ];
                
            case 'question':
                return [
                    {
                        id: 'detailed_help',
                        text: "I'd be happy to explain everything about that.",
                        tone: 'helpful',
                        requiresRelationship: 0
                    },
                    {
                        id: 'quick_answer',
                        text: "Sure, here's what you need to know.",
                        tone: 'efficient',
                        requiresRelationship: 0
                    }
                ];
                
            case 'complaint':
                return [
                    {
                        id: 'apologetic',
                        text: "I'm so sorry about that. Let me make it right.",
                        tone: 'apologetic',
                        requiresRelationship: 0
                    },
                    {
                        id: 'defensive',
                        text: "That's not really how we do things here.",
                        tone: 'defensive',
                        requiresRelationship: 0
                    }
                ];
                
            case 'purchase':
                return [
                    {
                        id: 'upsell',
                        text: "Have you considered our premium option?",
                        tone: 'sales',
                        requiresRelationship: 0
                    },
                    {
                        id: 'discount',
                        text: "I might be able to give you a small discount.",
                        tone: 'generous',
                        requiresRelationship: 10
                    }
                ];
                
            default:
                return [];
        }
    }

    getRelationshipOptions(relationshipLevel, npc) {
        const options = [];
        
        if (relationshipLevel === 'regular' || relationshipLevel === 'friend' || relationshipLevel === 'vip') {
            options.push({
                id: 'personal',
                text: "How have you been? I always enjoy seeing you.",
                tone: 'personal',
                requiresRelationship: 20
            });
        }
        
        if (relationshipLevel === 'friend' || relationshipLevel === 'vip') {
            options.push({
                id: 'insider_info',
                text: "I have something special just for you.",
                tone: 'exclusive',
                requiresRelationship: 40
            });
        }
        
        // Flirty options (if adult content enabled and appropriate relationship)
        if (this.gameState.data.meta.adultContentEnabled && npc.relationship >= 30) {
            options.push({
                id: 'flirty',
                text: "You always brighten my day when you come in.",
                tone: 'flirty',
                requiresRelationship: 30
            });
        }
        
        return options;
    }

    canUseOption(option, npc) {
        // Check relationship requirement
        if (option.requiresRelationship && npc.relationship < option.requiresRelationship) {
            return false;
        }
        
        // Check if flirty options are appropriate
        if (option.tone === 'flirty' && !this.gameState.data.meta.adultContentEnabled) {
            return false;
        }
        
        return true;
    }

    handlePlayerResponse(data) {
        if (!this.currentConversation || this.isWaitingForResponse) return;
        
        const { optionId, customText } = data;
        let responseText, responseTone;
        
        if (customText) {
            // Player typed a custom response
            responseText = customText;
            responseTone = this.analyzeTone(customText);
        } else {
            // Player selected a pre-defined option
            const selectedOption = this.dialogueOptions.find(opt => opt.id === optionId);
            if (!selectedOption) return;
            
            responseText = selectedOption.text;
            responseTone = selectedOption.tone;
        }
        
        // Add player message to conversation
        this.addMessage('player', responseText, responseTone);
        
        // Calculate response impact
        const impact = this.calculateResponseImpact(responseTone, this.currentConversation.npc);
        this.applyResponseImpact(impact);
        
        // Store player response for AI context
        this.currentConversation.lastPlayerResponse = {
            text: responseText,
            tone: responseTone,
            impact: impact
        };
        
        this.isWaitingForResponse = true;
        
        // Generate NPC response to player input
        setTimeout(() => {
            this.generateNPCResponse('response', null, responseText);
            this.isWaitingForResponse = false;
        }, 1000 + Math.random() * 2000); // 1-3 second delay for realism
        
        this.eventBus.emit('conversation.playerResponseProcessed', {
            response: responseText,
            tone: responseTone,
            impact: impact
        });
    }

    analyzeTone(text) {
        const lowerText = text.toLowerCase();
        
        // Simple tone analysis
        if (lowerText.includes('sorry') || lowerText.includes('apologize')) {
            return 'apologetic';
        } else if (lowerText.includes('help') || lowerText.includes('assist')) {
            return 'helpful';
        } else if (lowerText.includes('beautiful') || lowerText.includes('lovely')) {
            return 'flirty';
        } else if (lowerText.includes('no') || lowerText.includes('can\'t')) {
            return 'dismissive';
        } else if (text.includes('!') || lowerText.includes('great')) {
            return 'enthusiastic';
        } else {
            return 'neutral';
        }
    }

    calculateResponseImpact(tone, npc) {
        const baseImpact = this.responseOptions[tone] || { relationshipBonus: 0, satisfactionBonus: 0 };
        
        let relationshipChange = baseImpact.relationshipBonus;
        let satisfactionChange = baseImpact.satisfactionBonus;
        
        // Modify based on NPC mood
        switch (npc.mood) {
            case 'happy':
                satisfactionChange *= 1.2;
                break;
            case 'irritated':
                satisfactionChange *= 0.5;
                relationshipChange *= 0.5;
                break;
            case 'stressed':
                if (tone === 'helpful' || tone === 'apologetic') {
                    satisfactionChange *= 1.5;
                }
                break;
        }
        
        // Modify based on archetype
        if (npc.archetype === 'business_executive' && tone === 'professional') {
            satisfactionChange *= 1.3;
        } else if (npc.archetype === 'retiree' && tone === 'friendly') {
            relationshipChange *= 1.2;
        }
        
        return {
            relationshipChange: Math.round(relationshipChange),
            satisfactionChange: Math.round(satisfactionChange)
        };
    }

    applyResponseImpact(impact) {
        if (!this.currentConversation) return;
        
        const npc = this.currentConversation.npc;
        
        // Apply relationship change
        if (impact.relationshipChange !== 0) {
            this.npcSystem.updateRelationship(
                npc.id,
                impact.relationshipChange,
                'Conversation interaction'
            );
        }
        
        // Apply satisfaction change
        this.currentConversation.playerSatisfaction = Math.max(0, Math.min(100,
            this.currentConversation.playerSatisfaction + impact.satisfactionChange
        ));
        
        this.eventBus.emit('conversation.impactApplied', {
            npc: npc,
            impact: impact,
            newSatisfaction: this.currentConversation.playerSatisfaction
        });
    }

    addMessage(sender, text, emotion = 'neutral') {
        if (!this.currentConversation) return;
        
        const message = {
            sender: sender, // 'player' or 'npc'
            text: text,
            emotion: emotion,
            timestamp: Date.now(),
            turn: this.currentConversation.turnCount
        };
        
        this.currentConversation.messages.push(message);
        this.currentConversation.turnCount++;
        
        this.eventBus.emit('conversation.messageAdded', { message });
    }

    // Specialized conversation handlers
    handleGreeting(data) {
        const { npc, greetingType } = data;
        
        this.startConversation({
            npc: npc,
            scenario: 'greeting',
            context: { greetingType: greetingType || 'neutral' }
        });
    }

    handleQuestion(data) {
        const { npc, question, category } = data;
        
        this.startConversation({
            npc: npc,
            scenario: 'question',
            context: { 
                question: question,
                category: category || 'general'
            }
        });
    }

    handleComplaint(data) {
        const { npc, complaint, severity } = data;
        
        this.startConversation({
            npc: npc,
            scenario: 'complaint',
            context: {
                complaint: complaint,
                severity: severity || 1
            }
        });
    }

    // Conversation flow control
    calculateConversationTimeout(npc) {
        let baseTimeout = 60000; // 1 minute base
        
        // Modify by patience
        baseTimeout = baseTimeout * (npc.patience / 50);
        
        // Modify by relationship
        if (npc.relationshipLevel === 'friend') baseTimeout *= 1.5;
        if (npc.relationshipLevel === 'vip') baseTimeout *= 2.0;
        
        return Math.max(30000, baseTimeout); // Minimum 30 seconds
    }

    handleConversationTimeout() {
        if (!this.currentConversation) return;
        
        console.log('üí¨ Conversation timed out');
        
        // Apply negative impact for ignoring customer
        this.applyResponseImpact({
            relationshipChange: -3,
            satisfactionChange: -10
        });
        
        this.endConversation('timeout');
    }

    endConversation(reason = 'completed') {
        if (!this.currentConversation) return;
        
        const conversation = this.currentConversation;
        const duration = Date.now() - conversation.startTime;
        
        // Clear timeout
        if (this.conversationTimeout) {
            clearTimeout(this.conversationTimeout);
            this.conversationTimeout = null;
        }
        
        // Calculate final satisfaction score
        const finalSatisfaction = this.calculateFinalSatisfaction(conversation, reason);
        
        // Add to conversation history
        this.conversationHistory.push({
            ...conversation,
            endTime: Date.now(),
            duration: duration,
            endReason: reason,
            finalSatisfaction: finalSatisfaction
        });
        
        // Keep history manageable
        if (this.conversationHistory.length > 50) {
            this.conversationHistory.shift();
        }
        
        console.log(`üí¨ Conversation ended with ${conversation.npc.name} (${reason}, satisfaction: ${finalSatisfaction})`);
        
        this.eventBus.emit('conversation.ended', {
            conversation: conversation,
            reason: reason,
            duration: duration,
            finalSatisfaction: finalSatisfaction
        });
        
        this.currentConversation = null;
        this.dialogueOptions = null;
        this.isWaitingForResponse = false;
    }

    calculateFinalSatisfaction(conversation, reason) {
        let satisfaction = conversation.playerSatisfaction;
        
        // Modify based on end reason
        switch (reason) {
            case 'completed':
                satisfaction += 5;
                break;
            case 'timeout':
                satisfaction -= 15;
                break;
            case 'dismissed':
                satisfaction -= 10;
                break;
            case 'successful_sale':
                satisfaction += 10;
                break;
            case 'complaint_resolved':
                satisfaction += 15;
                break;
        }
        
        // Modify based on conversation length
        const idealTurns = 4;
        const actualTurns = conversation.turnCount;
        if (actualTurns < idealTurns) {
            satisfaction -= (idealTurns - actualTurns) * 2; // Penalty for too short
        }
        
        return Math.max(0, Math.min(100, satisfaction));
    }

    // Phase 4C: Enhanced helper methods for AI dialogue integration
    inferEmotionFromText(text, npc) {
        const emotionKeywords = {
            happy: ['great', 'awesome', 'wonderful', 'perfect', 'love', 'excellent'],
            excited: ['amazing', 'fantastic', 'incredible', 'wow', '!'],
            angry: ['terrible', 'awful', 'horrible', 'disgusting', 'hate', 'furious'],
            frustrated: ['annoying', 'irritating', 'ridiculous', 'stupid'],
            sad: ['disappointed', 'upset', 'sorry', 'unfortunate'],
            nervous: ['um', 'uh', 'maybe', 'I guess', 'not sure'],
            confident: ['definitely', 'absolutely', 'certainly', 'sure', 'positive'],
            flirty: ['gorgeous', 'handsome', 'attractive', 'cute', 'charming']
        };
        
        const textLower = text.toLowerCase();
        
        for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
            if (keywords.some(keyword => textLower.includes(keyword))) {
                return emotion;
            }
        }
        
        // Default based on NPC personality
        const personalityEmotions = {
            friendly: 'happy',
            aggressive: 'confident',
            shy: 'nervous',
            confident: 'confident',
            quirky: 'excited'
        };
        
        return personalityEmotions[npc.personality] || 'neutral';
    }

    inferToneFromText(text) {
        if (text.includes('!')) return 'enthusiastic';
        if (text.includes('?')) return 'curious';
        if (text.includes('...')) return 'hesitant';
        if (text.length > 100) return 'talkative';
        if (text.length < 30) return 'brief';
        return 'normal';
    }

    // Enhanced player option generation with AI context
    generatePlayerOptions(scenario, context) {
        const npc = this.currentConversation.npc;
        const relationship = npc.relationshipLevel || 0;
        
        const options = [];
        
        // Base response options
        switch (scenario) {
            case 'greeting':
                options.push(
                    { text: "Welcome! How can I help you today?", tone: "friendly", relationshipChange: 1 },
                    { text: "Hi there. What do you need?", tone: "professional", relationshipChange: 0 },
                    { text: "Hey! Great to see you again!", tone: "enthusiastic", relationshipChange: 2, requiresRelationship: 20 }
                );
                break;
                
            case 'product_inquiry':
                options.push(
                    { text: "I'd be happy to help you find that.", tone: "helpful", relationshipChange: 1 },
                    { text: "Let me show you our options.", tone: "professional", relationshipChange: 0 },
                    { text: "What's your budget for this?", tone: "business", relationshipChange: 0 }
                );
                break;
                
            case 'negotiation':
                options.push(
                    { text: "I can work with you on the price.", tone: "accommodating", relationshipChange: 2 },
                    { text: "The price is firm, but it's worth it.", tone: "confident", relationshipChange: -1 },
                    { text: "Let me see what I can do...", tone: "considering", relationshipChange: 1 }
                );
                break;
                
            case 'complaint':
                options.push(
                    { text: "I'm so sorry about that. Let me fix this.", tone: "apologetic", relationshipChange: 3 },
                    { text: "That's our policy, but I understand your frustration.", tone: "firm", relationshipChange: -1 },
                    { text: "Tell me exactly what happened.", tone: "investigative", relationshipChange: 1 }
                );
                break;
                
            case 'flirtation':
                if (relationship >= 30) {
                    options.push(
                        { text: "You're pretty charming yourself.", tone: "flirty", relationshipChange: 3, requiresRelationship: 30 },
                        { text: "I appreciate the compliment.", tone: "gracious", relationshipChange: 1 },
                        { text: "Let's keep things professional.", tone: "professional", relationshipChange: -2 }
                    );
                } else {
                    options.push(
                        { text: "Thank you, that's very kind.", tone: "polite", relationshipChange: 1 },
                        { text: "I prefer to keep things professional.", tone: "professional", relationshipChange: 0 }
                    );
                }
                break;
                
            default:
                options.push(
                    { text: "I understand.", tone: "neutral", relationshipChange: 0 },
                    { text: "That makes sense.", tone: "agreeable", relationshipChange: 1 },
                    { text: "Interesting...", tone: "thoughtful", relationshipChange: 0 }
                );
        }
        
        // Add context-specific options
        if (context?.product) {
            options.push({ 
                text: `Tell me more about the ${context.product.name}.`, 
                tone: "interested", 
                relationshipChange: 1 
            });
        }
        
        // Filter options by relationship requirements
        this.dialogueOptions = options.filter(option => 
            !option.requiresRelationship || relationship >= option.requiresRelationship
        );
        
        console.log(`üí¨ Generated ${this.dialogueOptions.length} dialogue options for ${scenario}`);
    }

    // Template fallback responses
    generateTemplateResponse(scenario, context) {
        const templates = this.dialogueTemplates;
        let responses = [];
        
        switch (scenario) {
            case 'greeting':
                responses = templates.greetings.friendly;
                break;
            case 'question':
                responses = templates.responses.helpful;
                break;
            case 'complaint':
                responses = templates.responses.apologetic;
                break;
            default:
                responses = ["I understand. How can I help you?"];
        }
        
        const response = responses[Math.floor(Math.random() * responses.length)];
        this.addMessage('npc', response, 'neutral');
        
        // Generate basic options
        this.dialogueOptions = [
            { id: 'helpful', text: "How can I help you?", tone: 'helpful' },
            { id: 'professional', text: "What do you need?", tone: 'professional' }
        ];
        
        this.eventBus.emit('conversation.npcResponse', {
            message: { text: response, emotion: 'neutral' },
            options: this.dialogueOptions,
            conversation: this.currentConversation
        });
    }

    // Public interface
    getCurrentConversation() {
        return this.currentConversation;
    }

    isInConversation() {
        return this.currentConversation !== null;
    }

    getConversationHistory(npcId = null) {
        if (npcId) {
            return this.conversationHistory.filter(conv => conv.npc.id === npcId);
        }
        return this.conversationHistory;
    }

    getAvailableOptions() {
        return this.dialogueOptions;
    }

    forceEndConversation() {
        this.endConversation('dismissed');
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ConversationSystem;
} else if (typeof window !== 'undefined') {
    window.ConversationSystem = ConversationSystem;
}


/* === scripts/systems/checkoutSystem.js === */
/**
 * Checkout System - Handles point-of-sale transactions
 * Manages cart, pricing, payment processing, and sales completion
 */

class CheckoutSystem {
    constructor() {
        this.gameState = null;
        this.eventBus = null;
        this.conversationSystem = null;
        this.npcSystem = null;
        this.currentTransaction = null;
        this.cart = [];
        this.paymentMethods = ['cash', 'card', 'digital'];
        this.discountTypes = ['loyalty', 'bulk', 'clearance', 'employee'];
    }

    initialize(gameState, eventBus, conversationSystem, npcSystem) {
        this.gameState = gameState;
        this.eventBus = eventBus;
        this.conversationSystem = conversationSystem;
        this.npcSystem = npcSystem;
        
        // Listen for checkout events
        this.eventBus.on('checkout.start', (data) => this.startCheckout(data));
        this.eventBus.on('checkout.addItem', (data) => this.addItemToCart(data));
        this.eventBus.on('checkout.removeItem', (data) => this.removeItemFromCart(data));
        this.eventBus.on('checkout.applyDiscount', (data) => this.applyDiscount(data));
        this.eventBus.on('checkout.selectPayment', (data) => this.selectPaymentMethod(data));
        this.eventBus.on('checkout.process', () => this.processPayment());
        this.eventBus.on('checkout.cancel', () => this.cancelCheckout());
        
        console.log('üõí Checkout System initialized');
    }

    // Transaction Management
    startCheckout(data) {
        const { npc, items = [], context = {} } = data;
        
        if (this.currentTransaction) {
            this.cancelCheckout();
        }
        
        this.currentTransaction = {
            id: this.generateTransactionId(),
            npc: npc,
            startTime: Date.now(),
            status: 'active',
            context: context,
            
            // Cart and pricing
            cart: [],
            subtotal: 0,
            discounts: [],
            totalDiscount: 0,
            tax: 0,
            total: 0,
            
            // Payment
            paymentMethod: null,
            paymentDetails: {},
            
            // Customer interaction
            customerSatisfaction: 50,
            upsellAttempts: 0,
            negotiationAttempts: 0,
            
            // Analytics
            startedBy: context.startedBy || 'customer', // customer, player, or staff
            itemsAdded: 0,
            itemsRemoved: 0,
            timeToComplete: 0
        };
        
        // Add initial items if provided
        if (items.length > 0) {
            items.forEach(item => this.addItemToCart({ item, skipNotification: true }));
        }
        
        this.eventBus.emit('checkout.started', {
            transaction: this.currentTransaction
        });
        
        console.log(`üõí Started checkout for ${npc.name}`);
        return this.currentTransaction;
    }

    addItemToCart(data) {
        if (!this.currentTransaction) return false;
        
        const { item, quantity = 1, skipNotification = false } = data;
        
        // Validate item
        if (!this.validateItem(item)) {
            console.error('Invalid item for checkout:', item);
            return false;
        }
        
        // Check if item already in cart
        const existingIndex = this.currentTransaction.cart.findIndex(cartItem => 
            cartItem.id === item.id
        );
        
        if (existingIndex >= 0) {
            // Update quantity
            this.currentTransaction.cart[existingIndex].quantity += quantity;
        } else {
            // Add new item
            const cartItem = {
                id: item.id,
                name: item.name,
                category: item.category,
                basePrice: item.price,
                currentPrice: item.price,
                quantity: quantity,
                discounts: [],
                itemDiscount: 0,
                subtotal: item.price * quantity,
                addedAt: Date.now()
            };
            
            this.currentTransaction.cart.push(cartItem);
        }
        
        this.currentTransaction.itemsAdded++;
        this.recalculateTotal();
        
        if (!skipNotification) {
            this.eventBus.emit('checkout.itemAdded', {
                item: item,
                quantity: quantity,
                transaction: this.currentTransaction
            });
        }
        
        // Check for upsell opportunities
        this.checkUpsellOpportunities(item);
        
        return true;
    }

    removeItemFromCart(data) {
        if (!this.currentTransaction) return false;
        
        const { itemId, quantity = null } = data;
        
        const itemIndex = this.currentTransaction.cart.findIndex(item => item.id === itemId);
        if (itemIndex === -1) return false;
        
        const cartItem = this.currentTransaction.cart[itemIndex];
        
        if (quantity === null || quantity >= cartItem.quantity) {
            // Remove entire item
            this.currentTransaction.cart.splice(itemIndex, 1);
        } else {
            // Reduce quantity
            cartItem.quantity -= quantity;
            cartItem.subtotal = cartItem.currentPrice * cartItem.quantity;
        }
        
        this.currentTransaction.itemsRemoved++;
        this.recalculateTotal();
        
        this.eventBus.emit('checkout.itemRemoved', {
            itemId: itemId,
            quantity: quantity,
            transaction: this.currentTransaction
        });
        
        return true;
    }

    // Pricing and Discounts
    recalculateTotal() {
        if (!this.currentTransaction) return;
        
        const transaction = this.currentTransaction;
        
        // Calculate subtotal
        transaction.subtotal = transaction.cart.reduce((sum, item) => {
            item.subtotal = item.currentPrice * item.quantity;
            return sum + item.subtotal;
        }, 0);
        
        // Apply discounts
        transaction.totalDiscount = this.calculateDiscounts();
        
        // Calculate tax (simplified - 8.5% sales tax)
        const taxableAmount = transaction.subtotal - transaction.totalDiscount;
        transaction.tax = Math.round(taxableAmount * 0.085 * 100) / 100;
        
        // Calculate final total
        transaction.total = Math.max(0, transaction.subtotal - transaction.totalDiscount + transaction.tax);
        
        this.eventBus.emit('checkout.totalsUpdated', {
            transaction: transaction
        });
    }

    calculateDiscounts() {
        if (!this.currentTransaction) return 0;
        
        let totalDiscount = 0;
        const npc = this.currentTransaction.npc;
        
        // Clear existing discounts
        this.currentTransaction.discounts = [];
        
        // Loyalty discount
        const loyaltyDiscount = this.calculateLoyaltyDiscount(npc);
        if (loyaltyDiscount > 0) {
            this.currentTransaction.discounts.push({
                type: 'loyalty',
                amount: loyaltyDiscount,
                description: `${npc.relationshipLevel} customer discount`
            });
            totalDiscount += loyaltyDiscount;
        }
        
        // Bulk discount
        const bulkDiscount = this.calculateBulkDiscount();
        if (bulkDiscount > 0) {
            this.currentTransaction.discounts.push({
                type: 'bulk',
                amount: bulkDiscount,
                description: 'Bulk purchase discount'
            });
            totalDiscount += bulkDiscount;
        }
        
        // Employee discretion discount (player can manually apply)
        const employeeDiscount = this.currentTransaction.discounts
            .filter(d => d.type === 'employee')
            .reduce((sum, d) => sum + d.amount, 0);
        totalDiscount += employeeDiscount;
        
        return Math.round(totalDiscount * 100) / 100;
    }

    calculateLoyaltyDiscount(npc) {
        const subtotal = this.currentTransaction.subtotal;
        let discountPercent = 0;
        
        switch (npc.relationshipLevel) {
            case 'regular':
                discountPercent = 0.05; // 5%
                break;
            case 'friend':
                discountPercent = 0.10; // 10%
                break;
            case 'vip':
                discountPercent = 0.15; // 15%
                break;
        }
        
        return subtotal * discountPercent;
    }

    calculateBulkDiscount() {
        const cart = this.currentTransaction.cart;
        let discount = 0;
        
        // 5% off if buying 5+ of the same item
        cart.forEach(item => {
            if (item.quantity >= 5) {
                discount += item.subtotal * 0.05;
            }
        });
        
        // 3% off total if buying 10+ total items
        const totalItems = cart.reduce((sum, item) => sum + item.quantity, 0);
        if (totalItems >= 10) {
            discount += this.currentTransaction.subtotal * 0.03;
        }
        
        return discount;
    }

    applyDiscount(data) {
        if (!this.currentTransaction) return false;
        
        const { type, amount, description, percent = false } = data;
        
        let discountAmount = amount;
        if (percent) {
            discountAmount = this.currentTransaction.subtotal * (amount / 100);
        }
        
        // Validate discount
        if (discountAmount <= 0 || discountAmount > this.currentTransaction.subtotal) {
            return false;
        }
        
        // Add employee discretion discount
        this.currentTransaction.discounts.push({
            type: type || 'employee',
            amount: discountAmount,
            description: description || 'Manager discount',
            appliedBy: 'player',
            appliedAt: Date.now()
        });
        
        this.recalculateTotal();
        
        // Customer satisfaction boost for discounts
        this.adjustCustomerSatisfaction(5, 'discount_applied');
        
        this.eventBus.emit('checkout.discountApplied', {
            discount: {
                type: type,
                amount: discountAmount,
                description: description
            },
            transaction: this.currentTransaction
        });
        
        return true;
    }

    // Upselling and Customer Service
    checkUpsellOpportunities(item) {
        if (!this.currentTransaction || this.currentTransaction.upsellAttempts >= 2) return;
        
        const upsellItems = this.findUpsellItems(item);
        if (upsellItems.length > 0) {
            setTimeout(() => {
                this.eventBus.emit('checkout.upsellOpportunity', {
                    baseItem: item,
                    suggestedItems: upsellItems,
                    transaction: this.currentTransaction
                });
            }, 2000);
        }
    }

    findUpsellItems(baseItem) {
        // Simplified upsell logic - in full game this would check actual inventory
        const suggestions = [];
        
        // Category-based suggestions
        switch (baseItem.category) {
            case 'electronics':
                suggestions.push({
                    id: 'extended_warranty',
                    name: 'Extended Warranty',
                    price: baseItem.price * 0.15,
                    category: 'services'
                });
                break;
            case 'food':
                suggestions.push({
                    id: 'drink_combo',
                    name: 'Drink Combo',
                    price: 2.99,
                    category: 'drinks'
                });
                break;
            case 'clothing':
                suggestions.push({
                    id: 'accessory',
                    name: 'Matching Accessory',
                    price: baseItem.price * 0.3,
                    category: 'accessories'
                });
                break;
        }
        
        return suggestions;
    }

    attemptUpsell(data) {
        if (!this.currentTransaction) return false;
        
        const { items, approach = 'suggestion' } = data;
        this.currentTransaction.upsellAttempts++;
        
        // Success chance based on approach and relationship
        const npc = this.currentTransaction.npc;
        let successChance = 0.3; // Base 30%
        
        if (approach === 'gentle') successChance += 0.1;
        if (approach === 'aggressive') successChance -= 0.1;
        
        // Relationship modifier
        if (npc.relationshipLevel === 'regular') successChance += 0.1;
        if (npc.relationshipLevel === 'friend') successChance += 0.2;
        if (npc.relationshipLevel === 'vip') successChance += 0.3;
        
        const success = Math.random() < successChance;
        
        if (success) {
            // Add upsell items to cart
            const acceptedItems = items.slice(0, Math.ceil(items.length * Math.random()));
            acceptedItems.forEach(item => {
                this.addItemToCart({ item, skipNotification: true });
            });
            
            this.adjustCustomerSatisfaction(2, 'successful_upsell');
        } else {
            // Unsuccessful upsell may reduce satisfaction
            if (approach === 'aggressive') {
                this.adjustCustomerSatisfaction(-3, 'pushy_upsell');
            }
        }
        
        this.eventBus.emit('checkout.upsellResult', {
            success: success,
            items: success ? acceptedItems : [],
            approach: approach,
            transaction: this.currentTransaction
        });
        
        return success;
    }

    // Payment Processing
    selectPaymentMethod(data) {
        if (!this.currentTransaction) return false;
        
        const { method, details = {} } = data;
        
        if (!this.paymentMethods.includes(method)) {
            console.error('Invalid payment method:', method);
            return false;
        }
        
        this.currentTransaction.paymentMethod = method;
        this.currentTransaction.paymentDetails = details;
        
        this.eventBus.emit('checkout.paymentMethodSelected', {
            method: method,
            details: details,
            transaction: this.currentTransaction
        });
        
        return true;
    }

    processPayment() {
        if (!this.currentTransaction) return false;
        
        const transaction = this.currentTransaction;
        const npc = transaction.npc;
        
        // Validate payment
        if (!transaction.paymentMethod) {
            this.eventBus.emit('checkout.error', {
                error: 'No payment method selected',
                transaction: transaction
            });
            return false;
        }
        
        // Check if customer has enough money
        if (!this.validateCustomerPayment(npc, transaction.total)) {
            this.eventBus.emit('checkout.paymentFailed', {
                reason: 'insufficient_funds',
                transaction: transaction
            });
            return false;
        }
        
        // Process the payment
        const paymentResult = this.executePayment(transaction);
        
        if (paymentResult.success) {
            this.completeTransaction(paymentResult);
            return true;
        } else {
            this.eventBus.emit('checkout.paymentFailed', {
                reason: paymentResult.reason,
                transaction: transaction
            });
            return false;
        }
    }

    validateCustomerPayment(npc, amount) {
        // Check if NPC has enough money
        return npc.currentCash >= amount;
    }

    executePayment(transaction) {
        const method = transaction.paymentMethod;
        const amount = transaction.total;
        const npc = transaction.npc;
        
        // Simulate payment processing
        let success = true;
        let reason = '';
        
        switch (method) {
            case 'cash':
                if (npc.currentCash >= amount) {
                    npc.currentCash -= amount;
                } else {
                    success = false;
                    reason = 'insufficient_cash';
                }
                break;
                
            case 'card':
                // 2% chance of card decline
                if (Math.random() < 0.02) {
                    success = false;
                    reason = 'card_declined';
                } else {
                    // Assume card payment deducts from their available cash
                    npc.currentCash -= amount;
                }
                break;
                
            case 'digital':
                // 1% chance of digital payment failure
                if (Math.random() < 0.01) {
                    success = false;
                    reason = 'payment_service_error';
                } else {
                    npc.currentCash -= amount;
                }
                break;
        }
        
        return {
            success: success,
            reason: reason,
            amount: amount,
            method: method,
            timestamp: Date.now()
        };
    }

    completeTransaction(paymentResult) {
        if (!this.currentTransaction) return;
        
        const transaction = this.currentTransaction;
        const npc = transaction.npc;
        
        // Update transaction status
        transaction.status = 'completed';
        transaction.endTime = Date.now();
        transaction.timeToComplete = transaction.endTime - transaction.startTime;
        transaction.paymentResult = paymentResult;
        
        // Update game state finances
        this.updateFinances(transaction);
        
        // Update NPC spending history
        npc.totalSpent += transaction.total;
        
        // Update inventory (simplified)
        this.updateInventory(transaction.cart);
        
        // Calculate final satisfaction
        const finalSatisfaction = this.calculateFinalSatisfaction(transaction);
        transaction.finalSatisfaction = finalSatisfaction;
        
        // Relationship impact based on satisfaction
        let relationshipChange = 0;
        if (finalSatisfaction >= 80) relationshipChange = 3;
        else if (finalSatisfaction >= 60) relationshipChange = 1;
        else if (finalSatisfaction < 40) relationshipChange = -1;
        
        if (relationshipChange !== 0) {
            this.npcSystem.updateRelationship(
                npc.id,
                relationshipChange,
                `Purchase transaction (satisfaction: ${finalSatisfaction})`
            );
        }
        
        // Add to transaction history
        this.gameState.data.finances.transactions.push({
            id: transaction.id,
            type: 'sale',
            npcId: npc.id,
            npcName: npc.name,
            timestamp: transaction.endTime,
            amount: transaction.total,
            subtotal: transaction.subtotal,
            discounts: transaction.totalDiscount,
            tax: transaction.tax,
            paymentMethod: transaction.paymentMethod,
            itemCount: transaction.cart.reduce((sum, item) => sum + item.quantity, 0),
            satisfaction: finalSatisfaction,
            duration: transaction.timeToComplete
        });
        
        console.log(`üõí Transaction completed: ${npc.name} - ${transaction.total.toFixed(2)}`);
        
        this.eventBus.emit('checkout.completed', {
            transaction: transaction,
            npc: npc,
            satisfaction: finalSatisfaction,
            relationshipChange: relationshipChange
        });
        
        // End conversation if active
        if (this.conversationSystem.isInConversation()) {
            this.conversationSystem.endConversation('successful_sale');
        }
        
        // Clear current transaction
        this.currentTransaction = null;
        this.cart = [];
    }

    // System Updates
    updateFinances(transaction) {
        const finances = this.gameState.data.finances;
        
        // Add revenue
        finances.cash += transaction.total;
        finances.dailyStats.sales += transaction.total;
        finances.dailyStats.transactions++;
        
        // Update weekly/monthly totals
        const currentWeek = Math.floor(this.gameState.data.time.currentDay / 7);
        const currentMonth = Math.floor(this.gameState.data.time.currentDay / 30);
        
        if (!finances.weeklyStats[currentWeek]) {
            finances.weeklyStats[currentWeek] = { sales: 0, transactions: 0, profit: 0 };
        }
        if (!finances.monthlyStats[currentMonth]) {
            finances.monthlyStats[currentMonth] = { sales: 0, transactions: 0, profit: 0 };
        }
        
        finances.weeklyStats[currentWeek].sales += transaction.total;
        finances.weeklyStats[currentWeek].transactions++;
        finances.monthlyStats[currentMonth].sales += transaction.total;
        finances.monthlyStats[currentMonth].transactions++;
    }

    updateInventory(cartItems) {
        // Simplified inventory update - in full game this would interact with inventory system
        cartItems.forEach(item => {
            console.log(`üì¶ Sold ${item.quantity}x ${item.name}`);
        });
    }

    calculateFinalSatisfaction(transaction) {
        let satisfaction = transaction.customerSatisfaction;
        
        // Bonus for quick service
        if (transaction.timeToComplete < 30000) { // Under 30 seconds
            satisfaction += 5;
        } else if (transaction.timeToComplete > 120000) { // Over 2 minutes
            satisfaction -= 10;
        }
        
        // Bonus for discounts
        if (transaction.totalDiscount > 0) {
            satisfaction += Math.min(10, transaction.totalDiscount / transaction.subtotal * 20);
        }
        
        // Penalty for too many upsell attempts
        if (transaction.upsellAttempts > 1) {
            satisfaction -= (transaction.upsellAttempts - 1) * 3;
        }
        
        return Math.max(0, Math.min(100, Math.round(satisfaction)));
    }

    adjustCustomerSatisfaction(change, reason) {
        if (!this.currentTransaction) return;
        
        this.currentTransaction.customerSatisfaction = Math.max(0, Math.min(100,
            this.currentTransaction.customerSatisfaction + change
        ));
        
        this.eventBus.emit('checkout.satisfactionChanged', {
            change: change,
            newSatisfaction: this.currentTransaction.customerSatisfaction,
            reason: reason,
            transaction: this.currentTransaction
        });
    }

    // Checkout Control
    cancelCheckout() {
        if (!this.currentTransaction) return;
        
        const transaction = this.currentTransaction;
        transaction.status = 'cancelled';
        transaction.endTime = Date.now();
        
        console.log(`üõí Checkout cancelled for ${transaction.npc.name}`);
        
        this.eventBus.emit('checkout.cancelled', {
            transaction: transaction
        });
        
        this.currentTransaction = null;
        this.cart = [];
    }

    // Utility Methods
    validateItem(item) {
        return item && 
               typeof item.id === 'string' && 
               typeof item.name === 'string' && 
               typeof item.price === 'number' && 
               item.price > 0;
    }

    generateTransactionId() {
        return 'txn_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
    }

    // Public Interface
    getCurrentTransaction() {
        return this.currentTransaction;
    }

    isCheckoutActive() {
        return this.currentTransaction !== null;
    }

    getCart() {
        return this.currentTransaction ? this.currentTransaction.cart : [];
    }

    getTotal() {
        return this.currentTransaction ? this.currentTransaction.total : 0;
    }

    getTransactionHistory(npcId = null) {
        const transactions = this.gameState.data.finances.transactions;
        if (npcId) {
            return transactions.filter(txn => txn.npcId === npcId);
        }
        return transactions;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CheckoutSystem;
} else if (typeof window !== 'undefined') {
    window.CheckoutSystem = CheckoutSystem;
}


/* === scripts/ui/uiManager.js === */
// UI Manager - Controls all UI elements and screen transitions
class UIManager {
    constructor() {
        this.initialized = false;
        this.currentScreen = null;
        this.currentView = null;
        this.screens = new Map();
        this.views = new Map();
        this.modals = new Map();
        this.notifications = [];
        
        // Bind methods
        this.initialize = this.initialize.bind(this);
        this.showScreen = this.showScreen.bind(this);
        this.showView = this.showView.bind(this);
        this.showModal = this.showModal.bind(this);
        this.showNotification = this.showNotification.bind(this);
    }

    // Initialize UI manager
    initialize() {
        if (this.initialized) return;

        console.log('üñ•Ô∏è Initializing UI Manager...');

        try {
            // Cache screen and view elements
            this.cacheElements();
            
            // Set up event listeners
            this.setupEventListeners();
            
            // Initialize notification system
            this.initializeNotifications();
            
            // Set up keyboard shortcuts
            this.setupKeyboardShortcuts();

            this.initialized = true;
            console.log('‚úÖ UI Manager initialized');

        } catch (error) {
            console.error('‚ùå UI Manager initialization failed:', error);
            throw error;
        }
    }

    // Cache DOM elements
    cacheElements() {
        // Cache screens
        const screenElements = document.querySelectorAll('.screen');
        screenElements.forEach(screen => {
            this.screens.set(screen.id, screen);
        });

        // Cache views
        const viewElements = document.querySelectorAll('.view');
        viewElements.forEach(view => {
            this.views.set(view.id, view);
        });

        // Cache common elements
        this.elements = {
            notificationContainer: document.getElementById('notification-container'),
            modalContainer: document.getElementById('modal-container'),
            loadingScreen: document.getElementById('loading-screen')
        };

        console.log(`üì± Cached ${this.screens.size} screens and ${this.views.size} views`);
    }

    // Set up event listeners
    setupEventListeners() {
        // Listen for game state changes
        gameEventBus.on(GAME_EVENTS.VIEW_CHANGED, this.handleViewChange, this);
        gameEventBus.on('state:changed', this.handleStateChange, this);

        // Set up common button handlers
        this.setupCommonButtons();

        console.log('üëÇ UI event listeners setup');
    }

    // Convenience listeners so controllers can drive UI through the event bus
    // (call this after initialize if needed)
    wireUIEvents() {
        gameEventBus.on('ui.showScreen', (id) => this.showScreen(id), this);
        gameEventBus.on('ui.showView', (id) => this.showView(id), this);
        gameEventBus.on('ui.showModal', (config) => this.showModal(config), this);
        gameEventBus.on('ui.hideModal', (id = null) => {
            if (id) {
                this.closeModal(id);
            } else if (this.modals.size > 0) {
                const last = Array.from(this.modals.keys()).pop();
                this.closeModal(last);
            }
        }, this);
        gameEventBus.on('ui.showNotification', ({ message, type = 'info', duration = 3000 }) => this.showNotification(message, type, duration), this);
    }

    // Set up common button handlers
    setupCommonButtons() {
        // Computer button
        const computerBtn = document.getElementById('computer-btn');
        if (computerBtn) {
            computerBtn.addEventListener('click', () => {
                this.showView('computer');
                gameState.setView(GAME_CONSTANTS.VIEWS.COMPUTER);
                gameEventBus.emit(GAME_EVENTS.COMPUTER_OPENED);

                // Initialize work computer if not already done
                if (typeof workComputer !== 'undefined' && !workComputer.initialized) {
                    workComputer.initialize(gameEventBus, gameState);
                }
            });
        }

        // Note: Close computer is now handled by work computer system
        // Work computer handles its own close/exit functionality

        // Pause button
        const pauseBtn = document.getElementById('pause-btn');
        if (pauseBtn) {
            pauseBtn.addEventListener('click', () => {
                if (typeof app !== 'undefined') {
                    if (gameState.getState() === GAME_CONSTANTS.GAME_STATES.PLAYING) {
                        app.pause();
                    } else if (gameState.getState() === GAME_CONSTANTS.GAME_STATES.PAUSED) {
                        app.resume();
                    }
                }
            });
        }

        // End conversation button
        const endConversationBtn = document.getElementById('end-conversation');
        if (endConversationBtn) {
            endConversationBtn.addEventListener('click', () => {
                this.showView('store');
                gameState.setView(GAME_CONSTANTS.VIEWS.STORE);
                gameEventBus.emit(GAME_EVENTS.CONVERSATION_ENDED);
            });
        }
    }

    // Show a screen
    showScreen(screenId) {
        // Hide all screens first
        this.screens.forEach(screen => {
            screen.classList.add('hidden');
            screen.style.display = 'none';
            screen.style.visibility = 'hidden';
        });

        // Show target screen
        const targetScreen = this.screens.get(screenId) || this.screens.get(`${screenId}-screen`);
        if (targetScreen) {
            targetScreen.classList.remove('hidden');
            // Forcefully override Perchance wrappers
            targetScreen.style.display = 'flex';
            targetScreen.style.visibility = 'visible';
            targetScreen.style.opacity = '1';
            this.currentScreen = screenId;
            console.log(`üì± Showing screen: ${screenId}`);
        } else {
            console.warn(`‚ö†Ô∏è Screen not found: ${screenId}`);
        }
    }

    // Show a view within the game interface
    showView(viewId) {
        // Remove active class from all views
        this.views.forEach(view => {
            view.classList.remove('active');
            view.style.display = 'none';
            view.style.visibility = 'hidden';
        });

        // Show target view
        const targetView = this.views.get(viewId) || this.views.get(`${viewId}-view`);
        if (targetView) {
            targetView.classList.add('active');
            targetView.style.display = 'block';
            targetView.style.visibility = 'visible';
            targetView.style.opacity = '1';
            this.currentView = viewId;
            console.log(`üëÅÔ∏è Showing view: ${viewId}`);
        } else {
            console.warn(`‚ö†Ô∏è View not found: ${viewId}`);
        }
    }

    // Show a modal
    showModal(modalConfig) {
        if (!this.elements.modalContainer) {
            console.warn('‚ö†Ô∏è Modal container not found');
            return null;
        }

        const modalId = modalConfig.id || `modal_${Date.now()}`;
        
        // Create modal element
        const modal = this.createModal(modalConfig);
        modal.id = modalId;

        // Add to container
        this.elements.modalContainer.appendChild(modal);
        this.modals.set(modalId, modal);

        // Show modal
        setTimeout(() => {
            modal.classList.add('active');
        }, 10);

        // Emit event
        gameEventBus.emit(GAME_EVENTS.MODAL_OPENED, { id: modalId, config: modalConfig });

        console.log(`ü™ü Modal shown: ${modalId}`);
        return modalId;
    }

    // Create modal element
    createModal(config) {
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        
        modal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <h3>${config.title || 'Modal'}</h3>
                    <button class="modal-close" aria-label="Close">&times;</button>
                </div>
                <div class="modal-body">
                    ${config.content || ''}
                </div>
                <div class="modal-footer">
                    ${config.buttons ? this.createModalButtons(config.buttons) : ''}
                </div>
            </div>
        `;

        // Set up close functionality
        const closeBtn = modal.querySelector('.modal-close');
        const overlay = modal;

        const closeModal = () => this.closeModal(modal.id);

        closeBtn.addEventListener('click', closeModal);
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) closeModal();
        });

        return modal;
    }

    // Create modal buttons
    createModalButtons(buttons) {
        return buttons.map(button => 
            `<button class="btn ${button.class || 'btn-primary'}" 
                     onclick="${button.action || ''}">${button.text}</button>`
        ).join('');
    }

    // Close modal
    closeModal(modalId) {
        const modal = this.modals.get(modalId);
        if (modal) {
            modal.classList.remove('active');
            
            setTimeout(() => {
                if (modal.parentNode) {
                    modal.parentNode.removeChild(modal);
                }
                this.modals.delete(modalId);
            }, 300);

            gameEventBus.emit(GAME_EVENTS.MODAL_CLOSED, { id: modalId });
            console.log(`ü™ü Modal closed: ${modalId}`);
        }
    }

    // Show notification
    showNotification(message, type = 'info', duration = 3000) {
        if (!this.elements.notificationContainer) {
            console.warn('‚ö†Ô∏è Notification container not found');
            return;
        }

        const notificationId = `notification_${Date.now()}`;
        const notification = this.createNotification(message, type, notificationId);

        // Add to container
        this.elements.notificationContainer.appendChild(notification);
        this.notifications.push({ id: notificationId, element: notification });

        // Show notification
        setTimeout(() => {
            notification.classList.add('active');
        }, 10);

        // Auto-remove after duration
        if (duration > 0) {
            setTimeout(() => {
                this.removeNotification(notificationId);
            }, duration);
        }

        // Emit event
        gameEventBus.emit(GAME_EVENTS.NOTIFICATION_SHOWN, { 
            id: notificationId, 
            message, 
            type 
        });

        console.log(`üîî Notification shown: ${message}`);
        return notificationId;
    }

    // Create notification element
    createNotification(message, type, id) {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.id = id;

        const icon = this.getNotificationIcon(type);
        
        notification.innerHTML = `
            <div class="notification-content">
                <span class="notification-icon">${icon}</span>
                <span class="notification-message">${message}</span>
                <button class="notification-close" aria-label="Close">&times;</button>
            </div>
        `;

        // Set up close functionality
        const closeBtn = notification.querySelector('.notification-close');
        closeBtn.addEventListener('click', () => {
            this.removeNotification(id);
        });

        return notification;
    }

    // Get notification icon based on type
    getNotificationIcon(type) {
        const icons = {
            info: '‚ÑπÔ∏è',
            success: '‚úÖ',
            warning: '‚ö†Ô∏è',
            error: '‚ùå',
            money: 'üí∞',
            customer: 'üë§',
            time: 'üïê'
        };
        return icons[type] || icons.info;
    }

    // Remove notification
    removeNotification(notificationId) {
        const notificationIndex = this.notifications.findIndex(n => n.id === notificationId);
        if (notificationIndex >= 0) {
            const notification = this.notifications[notificationIndex];
            
            notification.element.classList.remove('active');
            
            setTimeout(() => {
                if (notification.element.parentNode) {
                    notification.element.parentNode.removeChild(notification.element);
                }
                this.notifications.splice(notificationIndex, 1);
            }, 300);
        }
    }

    // Initialize notification system
    initializeNotifications() {
        // Listen for common game events and show notifications
        gameEventBus.on(GAME_EVENTS.TRANSACTION_COMPLETED, (data) => {
            this.showNotification(`Sale completed: +${data.amount}`, 'money');
        });

        gameEventBus.on(GAME_EVENTS.CUSTOMER_ENTERED, (data) => {
            this.showNotification(`${data.name} entered your store`, 'customer');
        });

        gameEventBus.on(GAME_EVENTS.CASH_LOW, () => {
            this.showNotification('Warning: Cash is running low!', 'warning');
        });

        console.log('üîî Notification system initialized');
    }

    // Set up keyboard shortcuts
    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Only handle shortcuts when not typing in inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            switch (e.key) {
                case 'Escape':
                    // Close modals or return to store view
                    if (this.modals.size > 0) {
                        const lastModal = Array.from(this.modals.keys()).pop();
                        this.closeModal(lastModal);
                    } else if (this.currentView !== 'store') {
                        this.showView('store');
                        gameState.setView(GAME_CONSTANTS.VIEWS.STORE);
                    }
                    break;
                
                case 'c':
                case 'C':
                    // Open computer
                    if (this.currentView === 'store') {
                        this.showView('computer');
                        gameState.setView(GAME_CONSTANTS.VIEWS.COMPUTER);
                    }
                    break;
                
                case 'p':
                case 'P':
                    // Pause/unpause
                    if (typeof app !== 'undefined') {
                        if (gameState.getState() === GAME_CONSTANTS.GAME_STATES.PLAYING) {
                            app.pause();
                        } else if (gameState.getState() === GAME_CONSTANTS.GAME_STATES.PAUSED) {
                            app.resume();
                        }
                    }
                    break;
            }
        });

        console.log('‚å®Ô∏è Keyboard shortcuts setup');
    }

    // Handle view changes
    handleViewChange(data) {
        this.showView(data.newView);
    }

    // Handle state changes
    handleStateChange(data) {
        const { newState } = data;
        
        // Update UI based on state
        switch (newState) {
            case GAME_CONSTANTS.GAME_STATES.SETUP:
                this.showScreen('setup');
                break;
            case GAME_CONSTANTS.GAME_STATES.PLAYING:
                this.showScreen('game');
                break;
            case GAME_CONSTANTS.GAME_STATES.PAUSED:
                this.showNotification('Game Paused', 'info', 0);
                break;
        }
    }

    // Update game UI elements
    updateUI(data) {
        // Update cash display
        const cashElement = document.getElementById('current-cash');
        if (cashElement && data.cash !== undefined) {
            cashElement.textContent = `${data.cash.toLocaleString()}`;
        }

        // Update time display
        const timeElement = document.getElementById('current-time');
        if (timeElement && data.time) {
            timeElement.textContent = data.time;
        }

        // Update store name
        const storeNameElement = document.getElementById('store-name');
        if (storeNameElement && data.storeName) {
            storeNameElement.textContent = data.storeName;
        }
    }

    // Get current UI state
    getState() {
        return {
            currentScreen: this.currentScreen,
            currentView: this.currentView,
            activeModals: Array.from(this.modals.keys()),
            notificationCount: this.notifications.length
        };
    }

    // Clean up
    destroy() {
        // Remove event listeners
        gameEventBus.removeAllListeners();
        
        // Clear modals and notifications
        this.modals.clear();
        this.notifications = [];
        
        this.initialized = false;
        console.log('üßπ UI Manager destroyed');
    }
}

// Create global UI manager instance
const uiManager = new UIManager();

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { UIManager, uiManager };
}


/* === scripts/ui/components/dialogue.js === */
/**
 * Dialogue Component - UI for displaying conversations and player choices
 * Handles conversation interface, response options, and customer interaction display
 */

class DialogueComponent {
    constructor() {
        this.container = null;
        this.eventBus = null;
        this.currentConversation = null;
        this.isVisible = false;
        this.typingAnimation = null;
        this.responseTimeout = null;
    }

    initialize(eventBus) {
        this.eventBus = eventBus;
        this.createDialogueInterface();
        this.setupEventListeners();
        
        // Listen for conversation events
        this.eventBus.on('conversation.started', (data) => this.showConversation(data.conversation));
        this.eventBus.on('conversation.npcResponse', (data) => this.displayNPCMessage(data));
        this.eventBus.on('conversation.playerResponseProcessed', (data) => this.displayPlayerMessage(data));
        this.eventBus.on('conversation.ended', () => this.hideConversation());
        this.eventBus.on('customerService.customerEntered', (data) => this.showCustomerCard(data));
        this.eventBus.on('customerService.browsingOpportunity', (data) => this.showActionSuggestions(data));
        this.eventBus.on('customerService.questionOpportunity', (data) => this.showQuestionInterface(data));
        this.eventBus.on('customerService.complaintReceived', (data) => this.showComplaintInterface(data));
        
        console.log('üí¨ Dialogue Component initialized');
    }

    createDialogueInterface() {
        this.container = document.createElement('div');
        this.container.className = 'dialogue-container';
        this.container.style.display = 'none';
        
        this.container.innerHTML = `
            <div class="dialogue-overlay"></div>
            <div class="dialogue-panel">
                <div class="dialogue-header">
                    <div class="customer-info">
                        <div class="customer-avatar">
                            <img id="customer-avatar" src="" alt="Customer" />
                            <div class="customer-mood" id="customer-mood"></div>
                        </div>
                        <div class="customer-details">
                            <h3 id="customer-name">Customer Name</h3>
                            <div class="customer-status">
                                <span id="customer-relationship" class="relationship-badge">Stranger</span>
                                <span id="customer-satisfaction" class="satisfaction-meter">
                                    <span class="meter-fill"></span>
                                    <span class="meter-text">50%</span>
                                </span>
                            </div>
                        </div>
                    </div>
                    <div class="dialogue-controls">
                        <button id="end-conversation" class="control-btn">End Chat</button>
                        <button id="quick-checkout" class="control-btn checkout-btn">Quick Checkout</button>
                    </div>
                </div>
                
                <div class="dialogue-content">
                    <div class="conversation-area">
                        <div id="message-history" class="message-history"></div>
                        <div id="typing-indicator" class="typing-indicator" style="display: none;">
                            <span class="typing-dots">
                                <span></span><span></span><span></span>
                            </span>
                            <span class="typing-text">Customer is typing...</span>
                        </div>
                    </div>
                    
                    <div class="response-area">
                        <div id="response-options" class="response-options"></div>
                        <div class="custom-response">
                            <input type="text" id="custom-response-input" 
                                   placeholder="Type a custom response..." maxlength="200">
                            <button id="send-custom" class="send-btn">Send</button>
                        </div>
                    </div>
                </div>
                
                <div class="action-suggestions" id="action-suggestions" style="display: none;">
                    <h4>Suggested Actions:</h4>
                    <div class="suggestion-buttons" id="suggestion-buttons"></div>
                </div>
            </div>
        `;
        
        document.body.appendChild(this.container);
    }

    setupEventListeners() {
        // Response option clicks
        this.container.addEventListener('click', (e) => {
            if (e.target.matches('.response-option')) {
                this.selectResponseOption(e.target.dataset.optionId);
            } else if (e.target.matches('.suggestion-btn')) {
                this.executeSuggestion(e.target.dataset.action, e.target.dataset.data);
            } else if (e.target.id === 'end-conversation') {
                this.eventBus.emit('conversation.end');
            } else if (e.target.id === 'quick-checkout') {
                this.startQuickCheckout();
            }
        });
        
        // Custom response handling
        const customInput = this.container.querySelector('#custom-response-input');
        const sendButton = this.container.querySelector('#send-custom');
        
        sendButton.addEventListener('click', () => this.sendCustomResponse());
        customInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.sendCustomResponse();
        });
        
        // Close on overlay click
        this.container.querySelector('.dialogue-overlay').addEventListener('click', () => {
            this.hideConversation();
        });
    }

    // Main Display Methods
    showConversation(conversation) {
        this.currentConversation = conversation;
        this.isVisible = true;
        
        // Update customer info
        this.updateCustomerInfo(conversation.npc);
        
        // Clear message history
        const messageHistory = this.container.querySelector('#message-history');
        messageHistory.innerHTML = '';
        
        // Show the dialogue panel
        this.container.style.display = 'flex';
        this.container.classList.add('active');
        
        // Add initial system message if needed
        if (conversation.scenario === 'greeting') {
            this.addSystemMessage(`${conversation.npc.name} has entered your store.`);
        }
    }

    hideConversation() {
        this.isVisible = false;
        this.currentConversation = null;
        
        this.container.classList.remove('active');
        setTimeout(() => {
            this.container.style.display = 'none';
        }, 300);
        
        // Clear any ongoing animations
        if (this.typingAnimation) {
            clearTimeout(this.typingAnimation);
            this.typingAnimation = null;
        }
    }

    updateCustomerInfo(npc) {
        // Avatar
        const avatar = this.container.querySelector('#customer-avatar');
        if (npc.avatar) {
            avatar.src = npc.avatar;
            avatar.style.display = 'block';
        } else {
            avatar.style.display = 'none';
        }
        
        // Name
        this.container.querySelector('#customer-name').textContent = npc.name;
        
        // Relationship badge
        const relationshipBadge = this.container.querySelector('#customer-relationship');
        relationshipBadge.textContent = this.formatRelationshipLevel(npc.relationshipLevel);
        relationshipBadge.className = `relationship-badge ${npc.relationshipLevel}`;
        
        // Mood indicator
        const moodIndicator = this.container.querySelector('#customer-mood');
        moodIndicator.className = `customer-mood ${npc.mood}`;
        moodIndicator.title = `Customer is ${npc.mood}`;
        
        // Satisfaction meter (start at 50% if no conversation data)
        this.updateSatisfactionMeter(50);
    }

    updateSatisfactionMeter(satisfaction) {
        const meter = this.container.querySelector('#customer-satisfaction');
        const fill = meter.querySelector('.meter-fill');
        const text = meter.querySelector('.meter-text');
        
        fill.style.width = `${satisfaction}%`;
        text.textContent = `${satisfaction}%`;
        
        // Color coding
        meter.className = 'satisfaction-meter';
        if (satisfaction >= 80) meter.classList.add('excellent');
        else if (satisfaction >= 60) meter.classList.add('good');
        else if (satisfaction >= 40) meter.classList.add('neutral');
        else if (satisfaction >= 20) meter.classList.add('poor');
        else meter.classList.add('terrible');
    }

    // Message Display
    displayNPCMessage(data) {
        const { message, options, conversation } = data;
        
        // Show typing indicator first
        this.showTypingIndicator();
        
        // Delay before showing actual message (simulate typing)
        this.typingAnimation = setTimeout(() => {
            this.hideTypingIndicator();
            this.addMessage('npc', message.text, message.emotion);
            this.showResponseOptions(options);
            
            // Update satisfaction if available
            if (conversation && conversation.playerSatisfaction !== undefined) {
                this.updateSatisfactionMeter(conversation.playerSatisfaction);
            }
        }, 1000 + Math.random() * 1500); // 1-2.5 second delay
    }

    displayPlayerMessage(data) {
        const { response, tone, impact } = data;
        
        this.addMessage('player', response, tone);
        this.clearResponseOptions();
        
        // Show impact feedback briefly
        if (impact.relationshipChange !== 0 || impact.satisfactionChange !== 0) {
            this.showImpactFeedback(impact);
        }
    }

    addMessage(sender, text, emotion = 'neutral') {
        const messageHistory = this.container.querySelector('#message-history');
        
        const messageElement = document.createElement('div');
        messageElement.className = `message ${sender} ${emotion}`;
        
        const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        messageElement.innerHTML = `
            <div class="message-content">
                <div class="message-text">${this.escapeHtml(text)}</div>
                <div class="message-time">${time}</div>
            </div>
        `;
        
        messageHistory.appendChild(messageElement);
        
        // Auto-scroll to bottom
        messageHistory.scrollTop = messageHistory.scrollHeight;
        
        // Add message animation
        requestAnimationFrame(() => {
            messageElement.classList.add('visible');
        });
    }

    addSystemMessage(text) {
        const messageHistory = this.container.querySelector('#message-history');
        
        const systemElement = document.createElement('div');
        systemElement.className = 'message system';
        systemElement.innerHTML = `
            <div class="message-content">
                <div class="message-text">${this.escapeHtml(text)}</div>
            </div>
        `;
        
        messageHistory.appendChild(systemElement);
        messageHistory.scrollTop = messageHistory.scrollHeight;
    }

    showTypingIndicator() {
        const indicator = this.container.querySelector('#typing-indicator');
        indicator.style.display = 'flex';
        
        // Auto-scroll to show typing indicator
        const messageHistory = this.container.querySelector('#message-history');
        messageHistory.scrollTop = messageHistory.scrollHeight;
    }

    hideTypingIndicator() {
        const indicator = this.container.querySelector('#typing-indicator');
        indicator.style.display = 'none';
    }

    // Response Options
    showResponseOptions(options) {
        const container = this.container.querySelector('#response-options');
        container.innerHTML = '';
        
        if (!options || options.length === 0) {
            container.innerHTML = '<div class="no-options">Waiting for customer response...</div>';
            return;
        }
        
        options.forEach(option => {
            const button = document.createElement('button');
            button.className = `response-option ${option.tone || 'neutral'}`;
            button.dataset.optionId = option.id;
            button.innerHTML = `
                <span class="option-text">${this.escapeHtml(option.text)}</span>
                ${option.requiresRelationship ? `<span class="requirement">Requires: ${option.requiresRelationship} relationship</span>` : ''}
            `;
            
            // Disable if requirements not met
            if (option.requiresRelationship && this.currentConversation) {
                if (this.currentConversation.npc.relationship < option.requiresRelationship) {
                    button.disabled = true;
                    button.classList.add('disabled');
                }
            }
            
            container.appendChild(button);
        });
    }

    clearResponseOptions() {
        const container = this.container.querySelector('#response-options');
        container.innerHTML = '';
    }

    selectResponseOption(optionId) {
        this.eventBus.emit('conversation.playerResponse', { optionId });
        this.clearResponseOptions();
    }

    sendCustomResponse() {
        const input = this.container.querySelector('#custom-response-input');
        const text = input.value.trim();
        
        if (text) {
            this.eventBus.emit('conversation.playerResponse', { customText: text });
            input.value = '';
            this.clearResponseOptions();
        }
    }

    // Special Interfaces
    showCustomerCard(data) {
        const { customer, behavior, suggestedActions } = data;
        
        // Show floating customer card when they enter
        this.showActionSuggestions({
            customer: customer,
            suggestedActions: suggestedActions,
            context: 'customer_entered'
        });
    }

    showActionSuggestions(data) {
        const { suggestedActions, context } = data;
        const container = this.container.querySelector('#action-suggestions');
        const buttonsContainer = this.container.querySelector('#suggestion-buttons');
        
        buttonsContainer.innerHTML = '';
        
        suggestedActions.forEach(action => {
            const button = document.createElement('button');
            button.className = `suggestion-btn ${action.priority || 'medium'}`;
            button.dataset.action = action.action;
            button.dataset.data = JSON.stringify(action.data || {});
            button.innerHTML = `
                <span class="action-text">${action.text}</span>
                ${action.relationshipImpact ? `<span class="impact">${action.relationshipImpact}</span>` : ''}
            `;
            
            buttonsContainer.appendChild(button);
        });
        
        container.style.display = 'block';
        
        // Auto-hide after 10 seconds
        setTimeout(() => {
            container.style.display = 'none';
        }, 10000);
    }

    showQuestionInterface(data) {
        const { customer, question, suggestedResponses } = data;
        
        this.addSystemMessage(`${customer.name} has a question: "${question}"`);
        
        // Convert responses to dialogue options format
        const options = suggestedResponses.map(response => ({
            id: response.type,
            text: response.text,
            tone: response.type,
            impact: response.impact
        }));
        
        this.showResponseOptions(options);
    }

    showComplaintInterface(data) {
        const { customer, complaint, severity, suggestedResolutions } = data;
        
        this.addSystemMessage(`${customer.name} has a complaint: "${complaint}" (Severity: ${severity}/3)`);
        
        // Convert resolutions to dialogue options format
        const options = suggestedResolutions.map(resolution => ({
            id: resolution.type,
            text: resolution.text,
            tone: resolution.type,
            cost: resolution.cost,
            impact: resolution.impact
        }));
        
        this.showResponseOptions(options);
    }

    // Action Execution
    executeSuggestion(action, dataString) {
        const data = JSON.parse(dataString || '{}');
        
        switch (action) {
            case 'greet':
                this.eventBus.emit('player.greetCustomer', { quality: 'friendly' });
                break;
            case 'offer_help':
                this.eventBus.emit('player.helpCustomer', { approach: 'helpful' });
                break;
            case 'start_checkout':
                this.eventBus.emit('player.startCheckout', {});
                break;
            case 'personal_greeting':
                this.eventBus.emit('player.greetCustomer', { quality: 'personal' });
                break;
            case 'quick_service':
                this.eventBus.emit('player.helpCustomer', { approach: 'efficient' });
                break;
            default:
                console.log(`Unknown action: ${action}`);
        }
        
        // Hide suggestions after action
        this.container.querySelector('#action-suggestions').style.display = 'none';
    }

    startQuickCheckout() {
        if (this.currentConversation) {
            this.eventBus.emit('player.startCheckout', {
                approach: 'quick'
            });
        }
    }

    // Feedback and Effects
    showImpactFeedback(impact) {
        const feedback = document.createElement('div');
        feedback.className = 'impact-feedback';
        
        let feedbackText = '';
        if (impact.relationshipChange > 0) {
            feedbackText += `+${impact.relationshipChange} Relationship `;
        } else if (impact.relationshipChange < 0) {
            feedbackText += `${impact.relationshipChange} Relationship `;
        }
        
        if (impact.satisfactionChange > 0) {
            feedbackText += `+${impact.satisfactionChange} Satisfaction`;
        } else if (impact.satisfactionChange < 0) {
            feedbackText += `${impact.satisfactionChange} Satisfaction`;
        }
        
        feedback.textContent = feedbackText;
        
        // Position near customer info
        const customerInfo = this.container.querySelector('.customer-info');
        customerInfo.appendChild(feedback);
        
        // Animate and remove
        setTimeout(() => feedback.classList.add('visible'), 100);
        setTimeout(() => {
            feedback.classList.remove('visible');
            setTimeout(() => feedback.remove(), 300);
        }, 2000);
    }

    // Utility Methods
    formatRelationshipLevel(level) {
        const levels = {
            'stranger': 'Stranger',
            'regular': 'Regular',
            'friend': 'Friend',
            'vip': 'VIP'
        };
        return levels[level] || level;
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Public Interface
    isDialogueVisible() {
        return this.isVisible;
    }

    getCurrentConversation() {
        return this.currentConversation;
    }

    forceClose() {
        this.hideConversation();
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = DialogueComponent;
} else if (typeof window !== 'undefined') {
    window.DialogueComponent = DialogueComponent;
}


/* === scripts/ui/screens/setupScreen.js === */
/**
 * Setup Screen UI Controller - Handles the game setup flow interface
 */

class SetupScreenController {
    constructor() {
        this.gameState = null;
        this.eventBus = null;
        this.characterCreation = null;
        this.storeSetup = null;
        this.currentPhase = 'welcome'; // welcome, character, store, complete
        this.elements = {};
    }

    initialize(gameState, eventBus, characterCreation, storeSetup) {
        this.gameState = gameState;
        this.eventBus = eventBus;
        // Graceful fallbacks if subsystems are not present yet
        this.characterCreation = characterCreation || {
            startCharacterCreation: () => {},
            validateComplete: () => true,
            usePreset: () => {},
            finishCharacterCreation: () => {}
        };
        this.storeSetup = storeSetup || {
            startStoreSetup: () => {},
            validateComplete: () => true,
            selectStoreType: () => {},
            selectEnvironment: () => {},
            updateBasicInfo: () => {},
            finishStoreSetup: () => {}
        };
        
        this.bindElements();
        this.bindEvents();
        
        console.log('üéÆ Setup Screen Controller initialized');
    }

    bindElements() {
        // Main setup container
        this.elements.setupContainer = document.getElementById('setupContainer');
        this.elements.setupContent = document.getElementById('setupContent');
        this.elements.setupProgress = document.getElementById('setupProgress');
        
        // Navigation
        this.elements.prevButton = document.getElementById('setupPrevButton');
        this.elements.nextButton = document.getElementById('setupNextButton');
        this.elements.skipButton = document.getElementById('setupSkipButton');
    this.elements.navigationContainer = document.querySelector('.setup-navigation');
        
        // Phase containers
        this.elements.welcomePhase = document.getElementById('welcomePhase');
        this.elements.characterPhase = document.getElementById('characterPhase');
        this.elements.storePhase = document.getElementById('storePhase');
        this.elements.completePhase = document.getElementById('completePhase');
        
        // Welcome screen elements
        this.elements.newGameButton = document.getElementById('newGameButton');
        this.elements.loadGameButton = document.getElementById('loadGameButton');
        this.elements.adultContentToggle = document.getElementById('adultContentToggle');
        this.elements.difficultySelect = document.getElementById('difficultySelect');
        
        // Character creation elements
        this.elements.characterForm = document.getElementById('characterForm');
        this.elements.characterPreview = document.getElementById('characterPreview');
        this.elements.characterSteps = document.getElementById('characterSteps');
        
        // Store setup elements
        this.elements.storeForm = document.getElementById('storeForm');
        this.elements.storePreview = document.getElementById('storePreview');
        this.elements.storeSteps = document.getElementById('storeSteps');
        
        // Completion elements
        this.elements.gameStartButton = document.getElementById('gameStartButton');
        this.elements.setupSummary = document.getElementById('setupSummary');
    }

    bindEvents() {
        // Navigation events
        if (this.elements.prevButton) {
            this.elements.prevButton.addEventListener('click', () => this.previousStep());
        }
        
        if (this.elements.nextButton) {
            this.elements.nextButton.addEventListener('click', () => this.nextStep());
        }
        
        if (this.elements.skipButton) {
            this.elements.skipButton.addEventListener('click', () => this.skipPhase());
        }
        
        // Welcome screen events
        if (this.elements.newGameButton) {
            this.elements.newGameButton.addEventListener('click', () => this.startNewGame());
        }
        
        if (this.elements.loadGameButton) {
            this.elements.loadGameButton.addEventListener('click', () => this.loadGame());
        }
        
        if (this.elements.adultContentToggle) {
            this.elements.adultContentToggle.addEventListener('change', (e) => {
                this.toggleAdultContent(e.target.checked);
            });
        }
        
        if (this.elements.difficultySelect) {
            this.elements.difficultySelect.addEventListener('change', (e) => {
                this.setDifficulty(e.target.value);
            });
        }
        
        // Final start button
        if (this.elements.gameStartButton) {
            this.elements.gameStartButton.addEventListener('click', () => this.startGame());
        }
        
        // Listen for system events
        this.eventBus.on('setup.characterComplete', () => this.characterCompleted());
        this.eventBus.on('setup.storeComplete', () => this.storeCompleted());
        this.eventBus.on('character.stepChanged', (data) => this.updateCharacterStep(data));
        this.eventBus.on('store.stepChanged', (data) => this.updateStoreStep(data));
        this.eventBus.on('ui.showSetup', (phase) => this.show(phase));
        this.eventBus.on('ui.hideSetup', () => this.hide());
    }

    show(phase = 'welcome') {
        this.currentPhase = phase;
        
        if (this.elements.setupContainer) {
            this.elements.setupContainer.style.display = 'flex';
            this.elements.setupContainer.classList.add('active');
        }
    // Prefer UI manager screen switch if available
    this.eventBus.emit('ui.showScreen', 'setup');
        
        this.updatePhase();
        this.updateProgress();
        this.updateNavigation();
        
        console.log('üéÆ Setup screen shown, phase:', phase);
    }

    hide() {
        if (this.elements.setupContainer) {
            this.elements.setupContainer.style.display = 'none';
            this.elements.setupContainer.classList.remove('active');
        }
    // Prefer UI manager to switch to game screen when hiding setup
    this.eventBus.emit('ui.showScreen', 'game');
        
        console.log('üéÆ Setup screen hidden');
    }

    updatePhase() {
        // Hide all phases
        const phases = [this.elements.welcomePhase, this.elements.characterPhase, 
                       this.elements.storePhase, this.elements.completePhase];
        
        phases.forEach(phase => {
            if (phase) {
                phase.style.display = 'none';
                phase.classList.add('hidden');
                phase.classList.remove('active');
            }
        });
        
        // Show current phase
        let currentElement = null;
        switch (this.currentPhase) {
            case 'welcome':
                currentElement = this.elements.welcomePhase;
                break;
            case 'character':
                currentElement = this.elements.characterPhase;
                break;
            case 'store':
                currentElement = this.elements.storePhase;
                break;
            case 'complete':
                currentElement = this.elements.completePhase;
                break;
        }
        
        if (currentElement) {
            currentElement.classList.remove('hidden');
            currentElement.style.display = 'block';
            currentElement.classList.add('active');
        }
    }

    updateProgress() {
        if (!this.elements.setupProgress) return;
        
        const phases = ['welcome', 'character', 'store', 'complete'];
        const currentIndex = phases.indexOf(this.currentPhase);
        const progress = ((currentIndex + 1) / phases.length) * 100;
        
        this.elements.setupProgress.style.width = `${progress}%`;
        this.elements.setupProgress.setAttribute('aria-valuenow', progress);
    }

    updateNavigation() {
        // Update navigation buttons based on current phase
        const isFirst = this.currentPhase === 'welcome';
        const isLast = this.currentPhase === 'complete';
        // Toggle navigation container visibility to override CSS !important
        if (this.elements.navigationContainer) {
            this.elements.navigationContainer.classList.toggle('visible', !isFirst);
        }
        
        if (this.elements.prevButton) {
            this.elements.prevButton.style.display = isFirst ? 'none' : 'inline-block';
            this.elements.prevButton.disabled = isFirst;
        }
        
        if (this.elements.nextButton) {
            this.elements.nextButton.style.display = isLast ? 'none' : 'inline-block';
            this.elements.nextButton.disabled = isLast;
            
            // Update button text based on phase
            let buttonText = 'Next';
            if (this.currentPhase === 'character') {
                buttonText = 'Continue to Store Setup';
            } else if (this.currentPhase === 'store') {
                buttonText = 'Review & Complete';
            }
            this.elements.nextButton.textContent = buttonText;
        }
        
        if (this.elements.skipButton) {
            this.elements.skipButton.style.display = 
                (this.currentPhase === 'character' || this.currentPhase === 'store') ? 'inline-block' : 'none';
        }
    }

    startNewGame() {
        // Initialize new game data
        this.gameState.initializeNewGame();
        
        // Set up initial game settings
        const adultContent = this.elements.adultContentToggle?.checked || false;
        const difficulty = this.elements.difficultySelect?.value || 'normal';
        
        this.gameState.data.meta.adultContentEnabled = adultContent;
        this.gameState.data.meta.difficulty = difficulty;
        
    // Move to character creation
        this.currentPhase = 'character';
        this.updatePhase();
        this.updateProgress();
        this.updateNavigation();
        
        // Start character creation system
        this.characterCreation.startCharacterCreation();
        
        this.eventBus.emit('setup.newGameStarted', { adultContent, difficulty });
        console.log('üéÆ New game started');
    }

    loadGame() {
        // Trigger file input for save file
        this.eventBus.emit('save.requestLoad');
        console.log('üéÆ Load game requested');
    }

    toggleAdultContent(enabled) {
        if (enabled) {
            // Show confirmation dialog for adult content
            this.showAdultContentWarning();
        } else {
            this.gameState.data.meta.adultContentEnabled = false;
            this.eventBus.emit('settings.adultContentChanged', false);
        }
    }

    showAdultContentWarning() {
        const warning = `
            <div class="adult-content-warning">
                <h3>Adult Content Warning</h3>
                <p>This game may contain mature themes and adult content including:</p>
                <ul>
                    <li>Romantic and sexual scenarios</li>
                    <li>Mature dialogue and situations</li>
                    <li>Adult-oriented products and businesses</li>
                </ul>
                <p>By enabling this option, you confirm that you are 18+ years old and consent to viewing such content.</p>
                <p><strong>You can disable this at any time in the settings.</strong></p>
            </div>
        `;
        
        this.eventBus.emit('ui.showModal', {
            title: 'Adult Content Warning',
            content: warning,
            buttons: [
                {
                    text: 'I am 18+ and Agree',
                    class: 'btn-primary',
                    action: () => {
                        this.gameState.data.meta.adultContentEnabled = true;
                        this.eventBus.emit('settings.adultContentChanged', true);
                        this.eventBus.emit('ui.hideModal');
                    }
                },
                {
                    text: 'Cancel',
                    class: 'btn-secondary',
                    action: () => {
                        this.elements.adultContentToggle.checked = false;
                        this.eventBus.emit('ui.hideModal');
                    }
                }
            ]
        });
    }

    setDifficulty(difficulty) {
        this.gameState.data.meta.difficulty = difficulty;
        
        // Adjust starting conditions based on difficulty
        const difficultySettings = {
            easy: {
                cashMultiplier: 1.5,
                debtReduction: 0.5,
                customerPatience: 1.3
            },
            normal: {
                cashMultiplier: 1.0,
                debtReduction: 1.0,
                customerPatience: 1.0
            },
            hard: {
                cashMultiplier: 0.7,
                debtReduction: 1.3,
                customerPatience: 0.8
            }
        };
        
        const settings = difficultySettings[difficulty] || difficultySettings.normal;
        this.gameState.data.meta.difficultySettings = settings;
        
        this.eventBus.emit('settings.difficultyChanged', { difficulty, settings });
        console.log('üéÆ Difficulty set to:', difficulty);
    }

    nextStep() {
        const phases = ['welcome', 'character', 'store', 'complete'];
        const currentIndex = phases.indexOf(this.currentPhase);
        
        if (currentIndex < phases.length - 1) {
            // Validate current phase before moving
            if (this.validateCurrentPhase()) {
                const nextPhase = phases[currentIndex + 1];
                this.moveToPhase(nextPhase);
            }
        }
    }

    previousStep() {
        const phases = ['welcome', 'character', 'store', 'complete'];
        const currentIndex = phases.indexOf(this.currentPhase);
        
        if (currentIndex > 0) {
            const prevPhase = phases[currentIndex - 1];
            this.moveToPhase(prevPhase);
        }
    }

    moveToPhase(phase) {
        this.currentPhase = phase;
        this.updatePhase();
        this.updateProgress();
        this.updateNavigation();
        
        // Start appropriate system for the phase
        if (phase === 'character') {
            this.characterCreation.startCharacterCreation();
        } else if (phase === 'store') {
            this.storeSetup.startStoreSetup();
        } else if (phase === 'complete') {
            this.showCompletionSummary();
        }
        
        this.eventBus.emit('setup.phaseChanged', { phase });
    }

    validateCurrentPhase() {
        switch (this.currentPhase) {
            case 'welcome':
                return true; // Welcome phase has no validation
            case 'character':
                return this.characterCreation.validateComplete();
            case 'store':
                return this.storeSetup.validateComplete();
            case 'complete':
                return true;
            default:
                return false;
        }
    }

    skipPhase() {
        if (this.currentPhase === 'character') {
            // Use default character
            this.characterCreation.usePreset('friendly');
            this.characterCreation.finishCharacterCreation();
        } else if (this.currentPhase === 'store') {
            // Use default store setup
            this.storeSetup.selectStoreType('general');
            this.storeSetup.selectEnvironment('suburban');
            this.storeSetup.updateBasicInfo({
                name: 'My Store',
                description: 'A friendly neighborhood store serving the local community.'
            });
            this.storeSetup.finishStoreSetup();
        }
    }

    characterCompleted() {
        console.log('‚úÖ Character creation completed');
        this.moveToPhase('store');
    }

    storeCompleted() {
        console.log('‚úÖ Store setup completed');
        this.moveToPhase('complete');
    }

    updateCharacterStep(data) {
        // Update character creation step indicator
        if (this.elements.characterSteps) {
            this.updateStepIndicator(this.elements.characterSteps, data.step, 
                ['basic', 'appearance', 'personality', 'review']);
        }
    }

    updateStoreStep(data) {
        // Update store setup step indicator
        if (this.elements.storeSteps) {
            this.updateStepIndicator(this.elements.storeSteps, data.step, 
                ['type', 'environment', 'basic', 'products', 'review']);
        }
    }

    updateStepIndicator(container, currentStep, steps) {
        const stepElements = container.querySelectorAll('.step-indicator');
        const currentIndex = steps.indexOf(currentStep);
        
        stepElements.forEach((element, index) => {
            element.classList.remove('active', 'completed');
            
            if (index < currentIndex) {
                element.classList.add('completed');
            } else if (index === currentIndex) {
                element.classList.add('active');
            }
        });
    }

    showCompletionSummary() {
        if (!this.elements.setupSummary) return;
        
        const character = this.gameState.data.player;
        const store = this.gameState.data.store;
        const finances = this.gameState.data.finances;
        
        const summary = `
            <div class="setup-summary">
                <div class="summary-section">
                    <h3>Your Character</h3>
                    <div class="character-summary">
                        ${character.appearance.avatar ? 
                            `<img src="${character.appearance.avatar}" alt="Character Avatar" class="summary-avatar">` : 
                            '<div class="summary-avatar-placeholder">No Avatar</div>'}
                        <div class="character-details">
                            <h4>${character.name}</h4>
                            <p>${character.age} years old ‚Ä¢ ${character.pronouns}</p>
                            <p class="character-traits">${character.personality.traits.join(', ')}</p>
                        </div>
                    </div>
                </div>
                
                <div class="summary-section">
                    <h3>Your Store</h3>
                    <div class="store-summary">
                        ${store.background.image ? 
                            `<img src="${store.background.image}" alt="Store Background" class="summary-store-bg">` : 
                            '<div class="summary-store-placeholder">No Background</div>'}
                        <div class="store-details">
                            <h4>${store.name}</h4>
                            <p>${this.storeSetup.storeTypes[store.type].name} in ${this.storeSetup.environments[store.environment].name}</p>
                            <p class="store-products">${store.productCategories?.join(', ') || 'Various products'}</p>
                        </div>
                    </div>
                </div>
                
                <div class="summary-section">
                    <h3>Starting Finances</h3>
                    <div class="finance-summary">
                        <div class="finance-item">
                            <span class="label">Starting Cash:</span>
                            <span class="value positive">${finances.cash.toLocaleString()}</span>
                        </div>
                        <div class="finance-item">
                            <span class="label">Total Debt:</span>
                            <span class="value negative">${(finances.debt.bank.amount + finances.debt.mob.amount + finances.debt.supplier.amount).toLocaleString()}</span>
                        </div>
                        <div class="finance-item">
                            <span class="label">Daily Rent:</span>
                            <span class="value">${finances.dailyExpenses.rent}</span>
                        </div>
                        <div class="finance-item">
                            <span class="label">Inventory Value:</span>
                            <span class="value">${this.gameState.data.inventory.totalValue?.toLocaleString() || '0'}</span>
                        </div>
                    </div>
                </div>
                
                <div class="summary-section">
                    <h3>Ready to Begin!</h3>
                    <p class="setup-complete-message">
                        Your store is ready to open! You'll start on Day 1 with your character ${character.name} 
                        managing ${store.name}. Good luck building your retail empire!
                    </p>
                </div>
            </div>
        `;
        
        this.elements.setupSummary.innerHTML = summary;
    }

    startGame() {
        // Final validation
        if (!this.gameState.data.player.name || !this.gameState.data.store.name) {
            this.eventBus.emit('ui.showNotification', {
                message: 'Setup incomplete. Please finish character and store creation.',
                type: 'error'
            });
            return;
        }
        
        // Save the initial game state
        this.eventBus.emit('save.autoSave');
        
        // Hide setup screen
        this.hide();
        
        // Start the main game
    this.eventBus.emit('game.start');
    this.eventBus.emit('ui.showScreen', 'game');
    this.eventBus.emit('ui.showView', 'store');
        
        console.log('üéÆ Game started!');
    }

    // Reset setup to beginning
    reset() {
        this.currentPhase = 'welcome';
        this.characterCreation.reset();
        this.storeSetup.reset();
        this.updatePhase();
        this.updateProgress();
        this.updateNavigation();
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = SetupScreenController;
} else if (typeof window !== 'undefined') {
    window.SetupScreenController = SetupScreenController;
}


/* === scripts/ui/forms/characterCreation.js === */
class CharacterCreation {
    constructor() {
        this.gameState = null;
        this.eventBus = null;
        this.aiHooks = null;
        this.elements = { form: null, preview: null };
        this.currentStep = 0;
        this.steps = ['basic','facial','body','style','background','image','review'];
        this.data = {
            name: '', gender: 'female', age: 25,
            facial: { eyeShape: 'almond', eyeColor: 'brown', hairColor: 'brown', hairStyle: 'long', nose: 'straight', mouth: 'full', eyebrows: 'arched', piercings: [], complexion: [], skinTone: 'Medium' },
            body: { physique: 'athletic', chest: 'B-Cup', waist: 'average', hips: 'average', butt: 'average', legs: 'toned', tattoos: [], tattooStyles: [], penisSize: 'N/A' },
            style: { dressStyle: 'casual' },
            background: { upbringing: 'middle-class', bio: '' },
            demographics: { heritage: 'Western European' },
            image: { selected: null, gallery: [], framing: 'half-body' }
        };
    }

    initialize(gameState, eventBus, aiHooks) {
        this.gameState = gameState;
        this.eventBus = eventBus;
        this.aiHooks = aiHooks || (typeof window !== 'undefined' ? window.aiHooks : null);
        this.elements.form = document.getElementById('characterForm');
        this.elements.preview = document.getElementById('characterPreview');
        this.render();
    }

    startCharacterCreation() { this.currentStep = 0; this.render(); this.emitStep(); }
    validateComplete() { return Boolean(this.data.name && this.data.gender && this.data.age); }
    usePreset(name) { this.data.name = 'Alex'; this.data.gender = 'female'; this.data.age = 25; this.render(); }
    reset() { this.currentStep = 0; }

    finishCharacterCreation() {
        const gs = this.gameState;
        gs.data = gs.data || {};
        gs.data.player = gs.data.player || { appearance: {}, personality: { traits: [] } };
        gs.data.player.name = this.data.name || 'Player';
        gs.data.player.age = this.data.age;
        gs.data.player.gender = this.data.gender;
        gs.data.player.appearance = {
            eyeShape: this.data.facial.eyeShape, eyeColor: this.data.facial.eyeColor, hairColor: this.data.facial.hairColor, hairStyle: this.data.facial.hairStyle,
            nose: this.data.facial.nose, mouth: this.data.facial.mouth, eyebrows: this.data.facial.eyebrows, piercings: this.data.facial.piercings, complexion: this.data.facial.complexion,
            physique: this.data.body.physique, chest: this.data.body.chest, waist: this.data.body.waist, hips: this.data.body.hips, butt: this.data.body.butt, legs: this.data.body.legs,
            tattoos: this.data.body.tattoos, tattooStyles: this.data.body.tattooStyles,
            skinTone: this.data.facial.skinTone, heritage: this.data.demographics.heritage,
            nsfw: this.gameState?.data?.meta?.adultContentEnabled ? { penisSize: this.data.body.penisSize } : {}
        };
        gs.data.player.background = this.data.background;
        gs.data.player.style = this.data.style;
        if (this.data.image.selected) gs.data.player.appearance.avatar = this.data.image.selected;
        this.eventBus.emit('setup.characterComplete');
    }

    emitStep() { const step = this.steps[this.currentStep] || 'basic'; this.eventBus.emit('character.stepChanged', { step }); }
    nextStep() { if (this.currentStep < this.steps.length - 1) { this.currentStep++; this.render(); this.emitStep(); } }
    prevStep() { if (this.currentStep > 0) { this.currentStep--; this.render(); this.emitStep(); } }

    render() {
        if (!this.elements.form || !this.elements.preview) return;
        // Layout classes
        this.elements.form.parentElement?.classList.add('cc-container');
        this.elements.form.className = 'cc-form';
        this.elements.preview.className = 'cc-preview';
        const step = this.steps[this.currentStep];
        this.elements.form.innerHTML = this.renderStep(step) + this.renderStepNav();
        this.bindFormEvents();
        this.renderPreview();
    }

    renderStepNav() {
        const atStart = this.currentStep === 0;
        const atEnd = this.currentStep === this.steps.length - 1;
        return `<div class="cc-nav">
            <button class="cc-btn secondary" ${atStart ? 'disabled' : ''} id="ccPrev">‚Üê Back</button>
            ${!atEnd ? `<button class=\"cc-btn\" id=\"ccNext\">Next ‚Üí</button>` : `<button class=\"cc-btn\" id=\"ccFinish\">Complete Character</button>`}
        </div>`;
    }

    bindFormEvents() {
        const prev = document.getElementById('ccPrev');
        const next = document.getElementById('ccNext');
        const finish = document.getElementById('ccFinish');
        prev && prev.addEventListener('click', () => this.prevStep());
        next && next.addEventListener('click', () => this.nextStep());
        finish && finish.addEventListener('click', () => this.finishCharacterCreation());
        // Two-way binding
        this.elements.form.querySelectorAll('[data-model]').forEach(el => {
            el.addEventListener('input', () => {
                const path = el.getAttribute('data-model');
                this.setByPath(path, el.type === 'number' ? Number(el.value) : el.value);
                this.renderPreview();
            });
        });
        // Chip toggles
        this.elements.form.querySelectorAll('[data-chip]').forEach(el => {
            el.addEventListener('click', () => {
                const target = el.getAttribute('data-target');
                const val = el.getAttribute('data-chip');
                const list = this.getByPath(target);
                const idx = list.indexOf(val);
                if (idx === -1) list.push(val); else list.splice(idx, 1);
                el.classList.toggle('active');
                this.renderPreview();
            });
        });
        const genBtn = document.getElementById('ccGen');
        genBtn && genBtn.addEventListener('click', () => this.generateImages());
        const clearBtn = document.getElementById('ccClear');
        clearBtn && clearBtn.addEventListener('click', () => { this.data.image.gallery = []; this.data.image.selected = null; this.render(); });
        // Per-image regenerate buttons
        this.elements.form.querySelectorAll('[data-regen]').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                e.stopPropagation();
                const idx = Number(btn.getAttribute('data-regen'));
                await this.regenImageAt(idx);
            });
        });
    }

    setByPath(path, value) { const parts = path.split('.'); let o = this.data; for (let i=0;i<parts.length-1;i++) o = o[parts[i]]; o[parts[parts.length-1]] = value; }
    getByPath(path) { const parts = path.split('.'); let o = this.data; for (let i=0;i<parts.length;i++) o = o[parts[i]]; return o; }
    sel(label, model, options) { const val = this.getByPath(model); return `<div class="cc-field"><label>${label}</label><select data-model="${model}">${options.map(o=>`<option ${val===o?'selected':''}>${o}</option>`).join('')}</select></div>`; }
    selGroups(label, model, groups) {
        const val = this.getByPath(model);
        const opts = groups.map(g => `<optgroup label="${g.label}">${g.options.map(o=>`<option ${val===o?'selected':''}>${o}</option>`).join('')}</optgroup>`).join('');
        return `<div class="cc-field"><label>${label}</label><select data-model="${model}">${opts}</select></div>`;
    }

    renderStep(step) {
        const nsfw = !!this.gameState?.data?.meta?.adultContentEnabled;
        switch(step) {
            case 'basic': return `<div class="cc-section"><h4>Basic Info</h4><div class="cc-row">
                <div class="cc-field"><label>Name</label><input type="text" data-model="name" value="${this.escape(this.data.name)}" placeholder="Character name"></div>
                <div class="cc-field"><label>Gender</label><select data-model="gender">${['female','male','non-binary','other'].map(v=>`<option ${this.data.gender===v?'selected':''}>${v}</option>`).join('')}</select></div>
                <div class="cc-field"><label>Age</label><input type="number" min="18" max="99" data-model="age" value="${this.data.age}"></div>
            </div></div>`;
            case 'facial': return `<div class="cc-section"><h4>Facial Features</h4>
            <div class="cc-row">
                ${this.selGroups('Heritage / Region','demographics.heritage', [
                    { label: 'Real-world', options: ['Western European','Eastern European','Northern European','Southern European','North American','Central American','South American','East Asian','South Asian','Southeast Asian','Middle Eastern','North African','Sub-Saharan African','Pacific Islander','Indigenous','Mixed/Multiracial'] },
                    { label: 'Fantasy Options (may break immersion)', options: ['Elf','Dwarf','Orc','Vampire','Demon','Android','Alien','Fairy','Dragonborn'] }
                ])}
                ${this.selGroups('Skin Tone','facial.skinTone', [
                    { label: 'Real-world', options: ['Porcelain','Fair','Light','Light-medium','Medium','Olive','Tan','Bronze','Brown','Deep','Very deep'] },
                    { label: 'Fantasy Options (may break immersion)', options: ['Blue','Green','Pink','Purple','Gray','Red','Silver','Gold'] }
                ])}
            </div>
            <div class="cc-grid">
                ${this.sel('Eye Shape','facial.eyeShape',['Almond','Round','Hooded','Monolid','Upturned','Downturned',])}
                ${this.sel('Eye Color','facial.eyeColor',['Brown','Blue','Green','Hazel','Gray','Amber'])}
                ${this.sel('Hair Color','facial.hairColor',['Black','Brown','Blonde','Red','Gray','Blue','Green','Purple','Hombre'])}
                ${this.sel('Hair Style','facial.hairStyle',['Short','Medium','Long','Curly','Wavy','Straight','Buzzed',''])}
                ${this.sel('Nose Shape','facial.nose',['straight','aquiline','button','roman','snub','hooked'])}
                ${this.sel('Mouth Shape','facial.mouth',['full','thin','heart','wide','bow'])}
                ${this.sel('Eyebrows','facial.eyebrows',['arched','straight','thick','thin','angled'])}
            </div>
            <div class="cc-field"><label>Piercings</label><div class="cc-chips">${['Earlobes','Upper-Ear','Nose','Eyebrow','Lip','Tongue'].map(v=>`<div class=\"cc-chip ${this.data.facial.piercings.includes(v)?'active':''}\" data-chip=\"${v}\" data-target=\"facial.piercings\">${v}</div>`).join('')}</div></div>
            <div class="cc-field"><label>Complexion</label><div class="cc-chips">${['Blemishes', 'Light Freckles','Moderate freckles','Heavy Freckles','Light Scaring', 'Moderate Scarring','Heavy Scarring','Mole','Birthmark', ].map(v=>`<div class=\"cc-chip ${this.data.facial.complexion.includes(v)?'active':''}\" data-chip=\"${v}\" data-target=\"facial.complexion\">${v}</div>`).join('')}</div></div></div>`;
            case 'body': return `<div class="cc-section"><h4>Body Features</h4><div class="cc-grid">
                ${this.sel('Physique','body.physique',['Slim','Average','Athletic','Muscular','Curvy','Stocky'])}
                ${this.sel('Chest/Breast','body.chest',['Flat','A-Cup','B-Cup','C-Cup','D-Cup','DD+','Muscular','Flabby'])}
                ${this.sel('Waist','body.waist',['Slim','Average','Thick','Toned'])}
                ${this.sel('Hips','body.hips',['Slim','Average','Wide','Curvy'])}
                ${this.sel('Butt','body.butt',['Flat','Average','Round','Large','Curvy','Thicc'])}
                ${this.sel('Legs','body.legs',['Slim','Average','Toned','Muscular'])}
            </div>
            ${nsfw ? `<div class=\"cc-field\"><label>Penis Size (NSFW)</label><select data-model=\"body.penisSize\">${['N/A','Micro','Small','Average','Large','Extra-Large'].map(v=>`<option ${this.data.body.penisSize===v?'selected':''}>${v}</option>`).join('')}</select></div>` : ''}
            <div class="cc-field"><label>Tattoo Placement</label><div class="cc-chips">${['Arm (Patch)','Arm (Sleeve)','Back','Chest','Leg','Neck','Hand','Shoulder','Face','Butt'].map(v=>`<div class=\"cc-chip ${this.data.body.tattoos.includes(v)?'active':''}\" data-chip=\"${v}\" data-target=\"body.tattoos\">${v}</div>`).join('')}</div></div>
            <div class="cc-field"><label>Tattoo Styles</label><div class="cc-chips">${['Tribal','Minimal','Geometric','Realism','Watercolor','Script','Floral','Colorful'].map(v=>`<div class=\"cc-chip ${this.data.body.tattooStyles.includes(v)?'active':''}\" data-chip=\"${v}\" data-target=\"body.tattooStyles\">${v}</div>`).join('')}</div></div></div>`;
            case 'style': return `<div class="cc-section"><h4>Style of Dress</h4>${this.sel('Dress Style','style.dressStyle',['Casual','Formal','Street','Athleisure','Bohemian','Business','Goth','Preppy','Sexy','None (Nude)'])}</div>`;
            case 'background': return `<div class="cc-section"><h4>Upbringing & Background</h4>${this.sel('Upbringing','background.upbringing',['Working-class','Middle-class','Upper-class','Rural','Urban','Nomadic'])}
                <div class="cc-field"><label>Background Info</label><textarea data-model="background.bio" rows="4" placeholder="Write a short background...">${this.escape(this.data.background.bio)}</textarea></div></div>`;
            case 'image': return `<div class="cc-section"><h4>AI Profile Image</h4>
                <div class="cc-row" style="align-items:center !important; gap:8px !important;">
                    ${this.sel('Framing','image.framing',['headshot','half-body','three-quarter'])}
                    <span class="cc-status" id="ccStatus">${this._generating ? 'Generating‚Ä¶' : ''}</span>
                </div>
                <div class="cc-row" style="gap:8px !important;">
                    <button class="cc-btn" id="ccGen" ${this._generating ? 'disabled' : ''}>Generate Images</button>
                    <button class="cc-btn secondary" id="ccClear" ${this._generating ? 'disabled' : ''}>Clear All</button>
                </div>
                <div class="cc-gallery" id="ccGallery">${this.data.image.gallery.map((src,idx)=>`
                    <div class=\"cc-thumb-wrap\" data-index=\"${idx}\">
                        <img src=\"${src}\" class=\"cc-thumb ${this.data.image.selected===src?'selected':''}\" data-index=\"${idx}\">
                        ${(this._thumbGenerating?.[idx] || this._generating) ? '<div class=\\"cc-thumb-overlay\\">Generating‚Ä¶</div>' : ''}
                        <button class=\"cc-regen-btn\" title=\"Regenerate\" data-regen=\"${idx}\" ${this._generating ? 'disabled' : ''}>‚ü≤</button>
                    </div>`).join('')}</div>
            </div>`;
            case 'review': return `<div class="cc-section"><h4>Review</h4><p>Review your selections on the right, then click Complete Character to continue.</p></div>`;
        }
        return '';
    }

    renderPreview() {
        const d = this.data; const avatar = d.image.selected ? `<img src="${d.image.selected}" class="cc-image">` : `<div class="cc-image">No Image</div>`;
        this.elements.preview.innerHTML = `<h4 style="margin-bottom:8px !important;">Character Preview</h4>${avatar}
            <div style="margin-top:10px !important;"><div><strong>${this.escape(d.name || 'Unnamed')}</strong>, ${d.age}, ${d.gender}</div>
            <div>Heritage: ${d.demographics?.heritage || '‚Äî'}, Skin Tone: ${d.facial.skinTone || '‚Äî'}</div>
            <div>Eyes: ${d.facial.eyeShape} / ${d.facial.eyeColor}, Hair: ${d.facial.hairStyle} / ${d.facial.hairColor}</div>
            <div>Physique: ${d.body.physique}, Chest: ${d.body.chest}</div><div>Style: ${d.style.dressStyle}</div><div>Upbringing: ${d.background.upbringing}</div></div>`;
        const gallery = this.elements.form.querySelector('#ccGallery');
        if (gallery) { gallery.querySelectorAll('.cc-thumb').forEach((imgEl) => { imgEl.addEventListener('click', () => { const idx = Number(imgEl.getAttribute('data-index')); const src = this.data.image.gallery[idx]; this.data.image.selected = src; this.render(); }); }); }
    }

    async generateImages() {
        const d = this.data;
        const framing = d.image.framing || 'half-body';
        const urls = [];
        try {
            if (this.aiHooks && typeof this.aiHooks.generateImage === 'function') {
                this._generating = true; this._thumbGenerating = {}; this.render();
                const expressions = ['subtle friendly smile', 'neutral confident expression', 'soft warm smile'];
                const poses = ['facing camera', 'three-quarter view', 'slight head tilt'];
                for (let i = 0; i < 3; i++) {
                    const prompt = this.buildPortraitPrompt(framing, expressions[i % expressions.length], poses[i % poses.length]);
                    const url = await this.aiHooks.generateImage(prompt, { size: '512x512', skipCache: true });
                    if (url) urls.push(url);
                }
            }
        } catch (e) { console.warn('AI image gen failed, using placeholders:', e); }
        if (urls.length === 0) { urls.push('https://picsum.photos/seed/cc1/512'); urls.push('https://picsum.photos/seed/cc2/512'); urls.push('https://picsum.photos/seed/cc3/512'); }
        this.data.image.gallery = urls; this.data.image.selected = urls[0]; this._generating = false; this.render();
    }

    async regenImageAt(index) {
        if (!this.aiHooks || typeof this.aiHooks.generateImage !== 'function') return;
        const d = this.data; const framing = d.image.framing || 'half-body';
        this._thumbGenerating = this._thumbGenerating || {}; this._thumbGenerating[index] = true; this.render();
        try {
            const expressions = ['subtle friendly smile', 'neutral confident expression', 'soft warm smile'];
            const poses = ['facing camera', 'three-quarter view', 'slight head tilt'];
            const prompt = this.buildPortraitPrompt(framing, expressions[index % expressions.length], poses[index % poses.length]);
            const url = await this.aiHooks.generateImage(prompt, { size: '512x512', skipCache: true });
            if (url) {
                this.data.image.gallery[index] = url;
                if (!this.data.image.selected) this.data.image.selected = url;
            }
        } catch (e) { console.warn('Per-image regen failed:', e); }
        this._thumbGenerating[index] = false; this.render();
    }

    buildPortraitPrompt(framing = 'half-body', expression = 'neutral confident expression', pose = 'facing camera') {
        const d = this.data;
        const nsfw = !!this.gameState?.data?.meta?.adultContentEnabled;
        const piercings = (d.facial.piercings && d.facial.piercings.length) ? ` with ${d.facial.piercings.join(' and ')} piercings` : '';
        const complexion = (d.facial.complexion && d.facial.complexion.length) ? `, ${d.facial.complexion.join(', ')} on skin` : '';
        const clothing = this.clothingPhrase(d.style.dressStyle, nsfw);
        const lens = framing === 'headshot' ? '85mm lens' : (framing === 'half-body' ? '50mm lens' : '35mm lens');
        const framingText = framing === 'headshot' ? 'head-and-shoulders portrait' : (framing === 'three-quarter' ? 'three-quarter portrait from head to thighs' : 'half-length portrait from head to mid-torso');
        const subject = this.buildSubjectPhrase(d.gender, d.demographics?.heritage, d.facial?.skinTone);
        return [
            `Ultra-detailed professional ${framingText} of ${subject}, age ${d.age},`,
            `${d.facial.hairStyle} ${d.facial.hairColor} hair, ${d.facial.eyeColor} eyes, ${d.facial.eyeShape} eye shape${piercings}${complexion},`,
            `wearing ${clothing},`,
            `${pose}, ${expression},`,
            `neutral seamless background, soft diffused studio lighting, ${lens}, shallow depth of field,`,
            `natural skin texture, sharp focus, cinematic color grading`
        ].join(' ');
    }

    buildSubjectPhrase(gender, heritage, skinTone) {
        const genderWord = (gender || 'person').toString();
        const heritageLabel = this.formatHeritage(heritage);
        const skin = (skinTone ? ` with ${skinTone.toLowerCase()} skin` : '');
        const headWord = heritageLabel || genderWord;
        const article = this.articleFor(headWord);
        if (heritageLabel) return `${article} ${heritageLabel} ${genderWord}${skin}`;
        return `${article} ${genderWord}${skin}`;
    }

    formatHeritage(heritage) {
        if (!heritage) return '';
        if (heritage === 'Mixed/Multiracial') return 'mixed-heritage';
        return heritage.toString();
    }

    articleFor(word) {
        const w = (word || '').toString().trim();
        if (!w) return 'a';
        return /^[AEIOUaeiou]/.test(w) ? 'an' : 'a';
    }

    clothingPhrase(style, nsfw) {
        const normalized = (style ?? '').toString().trim().toLowerCase();

        // Flexible checks for common synonyms
        const isNude = ['nude', 'naked', 'none', 'no clothing', 'au naturel'].some(k => normalized.includes(k));
        const isSexy = ['sexy', 'lingerie', 'revealing'].some(k => normalized.includes(k));

        // If NSFW is OFF, sanitize any nude/sexy variants to a safe fallback
        if (!nsfw && (isNude || isSexy)) {
            return 'a tasteful outfit';
        }

        // If NSFW is ON and user chose nude/none, allow it explicitly
        if (nsfw && isNude) {
            return 'no clothing';
        }

        // Explicit map for supported styles (kept from your original)
        const styleMap = {
            casual: 'a casual outfit',
            formal: 'a formal outfit',
            street: 'a streetwear outfit',
            athleisure: 'an athleisure outfit',
            bohemian: 'a bohemian outfit',
            business: 'a smart business outfit',
            goth: 'a goth-inspired outfit',
            preppy: 'a preppy outfit',
            sexy: nsfw ? 'a revealing outfit' : 'a tasteful outfit',
        };

        // If it's explicitly one of our keys, return directly
        if (normalized in styleMap) {
            return styleMap[normalized];
        }

        // If it‚Äôs a ‚Äúsexy‚Äù synonym but not exactly the key
        if (isSexy) {
            return nsfw ? 'a revealing outfit' : 'a tasteful outfit';
        }

        // Lenient substring match (e.g., "business casual", "street style")
        for (const [key, val] of Object.entries(styleMap)) {
            if (normalized.includes(key)) return val;
        }

        // Fallback
        return 'a casual outfit';
    }


    escape(s){return (s||'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));}
}
if (typeof window !== 'undefined') window.CharacterCreation = CharacterCreation;

/* === src/scripts/systems/staffHiringSystem.js === */
/**
 * Staff Hiring System - Phase 5A Implementation
 * Comprehensive staff recruitment and hiring management
 * Handles job roles, applications, interviews, and onboarding
 */

class StaffHiringSystem {
    constructor() {
        this.gameState = null;
        this.eventBus = null;
        this.npcSystem = null;
        this.aiContentManager = null;
        
        // Job definitions and requirements
        this.jobRoles = new Map();
        this.applicantPool = [];
        this.activeApplications = new Map();
        this.interviewQueue = [];
        this.hiredStaff = new Map();
        
        // Hiring configuration
        this.hiringConfig = {
            maxApplicationsPerDay: 5,
            applicationProcessingTime: 24, // hours
            interviewDuration: 30, // minutes
            backgroundCheckTime: 48, // hours
            probationPeriod: 14, // days
            maxStaffSize: 10
        };
        
        // Performance tracking
        this.hiringMetrics = {
            totalApplications: 0,
            totalInterviews: 0,
            totalHires: 0,
            averageHireTime: 0,
            retentionRate: 0,
            performanceRating: 0
        };
    }

    initialize(gameState, eventBus, npcSystem, aiContentManager) {
        this.gameState = gameState;
        this.eventBus = eventBus;
        this.npcSystem = npcSystem;
        this.aiContentManager = aiContentManager;
        
        this.setupJobRoles();
        this.setupEventListeners();
        this.initializeHiringProcess();
        
        console.log('üëî Staff Hiring System initialized');
    }

    setupJobRoles() {
        // Define all available job roles with requirements and benefits
        this.jobRoles.set('cashier', {
            id: 'cashier',
            title: 'Cashier',
            icon: 'üí∞',
            department: 'sales',
            level: 'entry',
            dailyWage: 40,
            hourlyRate: 12,
            maxHours: 8,
            description: 'Handle customer transactions and provide front-line customer service',
            
            requirements: {
                experience: 'none', // none, some, experienced
                education: 'high_school',
                skills: ['customer_service', 'basic_math', 'communication'],
                personality: ['friendly', 'patient', 'honest'],
                availability: ['morning', 'afternoon', 'evening'],
                minAge: 16,
                backgroundCheck: false
            },
            
            benefits: {
                healthInsurance: false,
                paidTimeOff: 5, // days per year
                employeeDiscount: 10, // percentage
                bonusEligible: true,
                trainingProvided: true
            },
            
            responsibilities: [
                'Process customer transactions accurately',
                'Handle cash, credit, and digital payments',
                'Provide friendly customer service',
                'Maintain clean and organized checkout area',
                'Assist with basic product questions',
                'Follow store policies and procedures'
            ],
            
            performance: {
                transactionSpeed: 70, // target transactions per hour
                accuracyRate: 98, // minimum accuracy percentage
                customerSatisfaction: 80, // minimum satisfaction score
                upsellSuccess: 10 // target upsell percentage
            }
        });

        this.jobRoles.set('janitor', {
            id: 'janitor',
            title: 'Janitor',
            icon: 'üßπ',
            department: 'maintenance',
            level: 'entry',
            dailyWage: 30,
            hourlyRate: 10,
            maxHours: 6,
            description: 'Maintain store cleanliness and handle basic maintenance tasks',
            
            requirements: {
                experience: 'none',
                education: 'none',
                skills: ['cleaning', 'basic_maintenance', 'time_management'],
                personality: ['reliable', 'detail_oriented', 'independent'],
                availability: ['early_morning', 'late_evening'],
                minAge: 18,
                backgroundCheck: false
            },
            
            benefits: {
                healthInsurance: false,
                paidTimeOff: 3,
                employeeDiscount: 5,
                bonusEligible: false,
                trainingProvided: true
            },
            
            responsibilities: [
                'Clean floors, windows, and surfaces',
                'Empty trash and recycling bins',
                'Maintain restroom cleanliness',
                'Report maintenance issues',
                'Stock cleaning supplies',
                'Ensure safety compliance'
            ],
            
            performance: {
                cleanlinessScore: 85,
                taskCompletion: 95,
                punctuality: 90,
                safetyCompliance: 100
            }
        });

        this.jobRoles.set('stocker', {
            id: 'stocker',
            title: 'Stocker',
            icon: 'üì¶',
            department: 'inventory',
            level: 'entry',
            dailyWage: 35,
            hourlyRate: 11,
            maxHours: 8,
            description: 'Manage inventory, stock shelves, and organize products',
            
            requirements: {
                experience: 'none',
                education: 'high_school',
                skills: ['organization', 'physical_fitness', 'inventory_management'],
                personality: ['detail_oriented', 'efficient', 'team_player'],
                availability: ['morning', 'afternoon', 'evening'],
                minAge: 18,
                backgroundCheck: false
            },
            
            benefits: {
                healthInsurance: false,
                paidTimeOff: 5,
                employeeDiscount: 10,
                bonusEligible: true,
                trainingProvided: true
            },
            
            responsibilities: [
                'Receive and process inventory shipments',
                'Stock shelves and maintain product displays',
                'Track inventory levels and report shortages',
                'Organize stockroom and storage areas',
                'Assist customers with product location',
                'Perform inventory counts'
            ],
            
            performance: {
                stockingSpeed: 50, // items per hour
                organizationScore: 90,
                accuracyRate: 95,
                inventoryTurnover: 15 // days
            }
        });

        this.jobRoles.set('security', {
            id: 'security',
            title: 'Security Guard',
            icon: 'üõ°Ô∏è',
            department: 'security',
            level: 'experienced',
            dailyWage: 50,
            hourlyRate: 15,
            maxHours: 8,
            description: 'Provide security, loss prevention, and handle difficult situations',
            
            requirements: {
                experience: 'some',
                education: 'high_school',
                skills: ['security', 'conflict_resolution', 'observation'],
                personality: ['calm', 'authoritative', 'alert'],
                availability: ['morning', 'afternoon', 'evening', 'night'],
                minAge: 21,
                backgroundCheck: true
            },
            
            benefits: {
                healthInsurance: true,
                paidTimeOff: 7,
                employeeDiscount: 15,
                bonusEligible: true,
                trainingProvided: true
            },
            
            responsibilities: [
                'Monitor store for theft and suspicious activity',
                'Handle difficult or disruptive customers',
                'Respond to security incidents',
                'Conduct bag checks and loss prevention',
                'Maintain incident reports',
                'Coordinate with local law enforcement'
            ],
            
            performance: {
                incidentResponse: 95, // response time in seconds
                theftPrevention: 80, // reduction in theft incidents
                customerCompliance: 90,
                reportAccuracy: 95
            }
        });

        this.jobRoles.set('assistant_manager', {
            id: 'assistant_manager',
            title: 'Assistant Manager',
            icon: 'üë®‚Äçüíº',
            department: 'management',
            level: 'experienced',
            dailyWage: 60,
            hourlyRate: 18,
            maxHours: 8,
            description: 'Assist with store management and supervise staff operations',
            
            requirements: {
                experience: 'experienced',
                education: 'college_preferred',
                skills: ['leadership', 'management', 'customer_service', 'problem_solving'],
                personality: ['responsible', 'decisive', 'communicative'],
                availability: ['morning', 'afternoon', 'evening'],
                minAge: 21,
                backgroundCheck: true
            },
            
            benefits: {
                healthInsurance: true,
                paidTimeOff: 10,
                employeeDiscount: 20,
                bonusEligible: true,
                trainingProvided: true
            },
            
            responsibilities: [
                'Supervise daily store operations',
                'Train and mentor junior staff',
                'Handle complex customer issues',
                'Manage staff schedules and breaks',
                'Implement store policies',
                'Report to store owner on performance'
            ],
            
            performance: {
                leadershipScore: 85,
                problemResolution: 90,
                staffSatisfaction: 80,
                operationalEfficiency: 85
            }
        });

        console.log(`üíº Job roles configured: ${this.jobRoles.size} positions available`);
    }

    setupEventListeners() {
        // Listen for hiring-related events
        this.eventBus.on('hiring.postJob', (data) => this.postJobOpening(data));
        this.eventBus.on('hiring.receiveApplication', (data) => this.receiveApplication(data));
        this.eventBus.on('hiring.scheduleInterview', (data) => this.scheduleInterview(data));
        this.eventBus.on('hiring.conductInterview', (data) => this.conductInterview(data));
        this.eventBus.on('hiring.makeOffer', (data) => this.makeJobOffer(data));
        this.eventBus.on('hiring.onboardStaff', (data) => this.onboardNewStaff(data));
        
        // Listen for time-based events
        this.eventBus.on('time.newDay', () => this.processDailyHiring());
        this.eventBus.on('time.newWeek', () => this.processWeeklyHiring());
        
        console.log('üì° Hiring system event listeners configured');
    }

    initializeHiringProcess() {
        // Initialize staff data structure in game state
        if (!this.gameState.staff) {
            this.gameState.staff = {
                employees: [],
                openPositions: [],
                applications: [],
                totalHired: 0,
                hiringBudget: 1000, // weekly hiring budget
                lastHireDate: null
            };
        }
        
        // Generate initial applicant pool
        this.generateApplicantPool();
        
        console.log('üöÄ Hiring process initialized');
    }

    // Job posting and recruitment
    async postJobOpening(jobData) {
        const { roleId, urgency = 'normal', salaryOffer = null } = jobData;
        const role = this.jobRoles.get(roleId);
        
        if (!role) {
            console.error('‚ùå Unknown job role:', roleId);
            return null;
        }
        
        console.log(`üì¢ Posting job opening: ${role.title}`);
        
        const jobPosting = {
            id: this.generateJobId(),
            roleId: roleId,
            role: role,
            postedDate: Date.now(),
            urgency: urgency,
            salaryOffer: salaryOffer || role.dailyWage,
            status: 'active',
            applicationsReceived: 0,
            interviewsScheduled: 0
        };
        
        // Add to open positions
        this.gameState.staff.openPositions.push(jobPosting);
        
        // Generate applications based on urgency and market conditions
        const applicationCount = this.calculateExpectedApplications(role, urgency);
        await this.generateJobApplications(jobPosting, applicationCount);
        
        // Emit job posted event
        this.eventBus.emit('hiring.jobPosted', jobPosting);
        
        return jobPosting;
    }

    calculateExpectedApplications(role, urgency) {
        let baseApplications = 3; // Base number of applications
        
        // Adjust based on role difficulty
        switch (role.level) {
            case 'entry':
                baseApplications += 2;
                break;
            case 'experienced':
                baseApplications -= 1;
                break;
        }
        
        // Adjust based on urgency
        switch (urgency) {
            case 'urgent':
                baseApplications += 1;
                break;
            case 'low':
                baseApplications -= 1;
                break;
        }
        
        // Adjust based on store reputation
        const reputation = this.gameState.store?.reputation || 50;
        if (reputation > 70) baseApplications += 1;
        if (reputation < 30) baseApplications -= 1;
        
        // Random variation
        baseApplications += Math.floor(Math.random() * 3);
        
        return Math.max(1, Math.min(baseApplications, this.hiringConfig.maxApplicationsPerDay));
    }

    async generateJobApplications(jobPosting, count) {
        console.log(`üìÑ Generating ${count} applications for ${jobPosting.role.title}`);
        
        for (let i = 0; i < count; i++) {
            // Delay applications over time (1-6 hours)
            const delay = Math.random() * 6 * 60 * 60 * 1000;
            
            setTimeout(() => {
                this.generateSingleApplication(jobPosting);
            }, delay);
        }
    }

    async generateSingleApplication(jobPosting) {
        const role = jobPosting.role;
        
        // Generate applicant NPC
        const applicant = await this.generateApplicantNPC(role);
        
        // Create application
        const application = {
            id: this.generateApplicationId(),
            jobPostingId: jobPosting.id,
            applicant: applicant,
            submittedDate: Date.now(),
            status: 'submitted', // submitted, reviewed, interview_scheduled, interviewed, offer_made, hired, rejected
            qualificationScore: this.calculateQualificationScore(applicant, role),
            interviewScore: null,
            backgroundCheckResult: null,
            notes: []
        };
        
        // Add to applications
        this.gameState.staff.applications.push(application);
        this.activeApplications.set(application.id, application);
        
        // Update job posting
        jobPosting.applicationsReceived++;
        
        // Emit application received event
        this.eventBus.emit('hiring.applicationReceived', {
            application: application,
            jobPosting: jobPosting
        });
        
        console.log(`üìã Application received from ${applicant.name} for ${role.title}`);
        
        return application;
    }

    async generateApplicantNPC(role) {
        // Create a specialized NPC for job application
        const baseNPC = await this.npcSystem.generateNPC({
            archetype: this.selectApplicantArchetype(role),
            enhanceForRole: role.id
        });
        
        // Add job-specific attributes
        const applicant = {
            ...baseNPC,
            employment: {
                experience: this.generateWorkExperience(role),
                education: this.generateEducation(role),
                skills: this.generateSkills(role),
                references: this.generateReferences(),
                availability: this.generateAvailability(),
                salaryExpectation: this.generateSalaryExpectation(role),
                reasonForApplying: this.generateApplicationReason(role)
            },
            interview: {
                nervousness: Math.floor(Math.random() * 100),
                confidence: Math.floor(Math.random() * 100),
                honesty: Math.floor(Math.random() * 100),
                enthusiasm: Math.floor(Math.random() * 100)
            }
        };
        
        return applicant;
    }

    selectApplicantArchetype(role) {
        const archetypesByRole = {
            cashier: ['college_student', 'young_parent', 'retiree', 'teenager'],
            janitor: ['tradesperson', 'older_worker', 'part_timer'],
            stocker: ['college_student', 'tradesperson', 'young_adult'],
            security: ['ex_military', 'security_professional', 'bouncer'],
            assistant_manager: ['business_professional', 'retail_manager', 'supervisor']
        };
        
        const archetypes = archetypesByRole[role.id] || ['general_worker'];
        return archetypes[Math.floor(Math.random() * archetypes.length)];
    }

    generateWorkExperience(role) {
        const experience = [];
        const experienceLevel = role.requirements.experience;
        
        let jobCount = 0;
        switch (experienceLevel) {
            case 'none':
                jobCount = Math.random() < 0.3 ? 1 : 0;
                break;
            case 'some':
                jobCount = Math.floor(Math.random() * 3) + 1;
                break;
            case 'experienced':
                jobCount = Math.floor(Math.random() * 5) + 2;
                break;
        }
        
        for (let i = 0; i < jobCount; i++) {
            experience.push({
                position: this.generateJobTitle(role),
                company: this.generateCompanyName(),
                duration: Math.floor(Math.random() * 36) + 1, // 1-36 months
                responsibilities: this.generateJobResponsibilities(role),
                reasonForLeaving: this.generateLeavingReason()
            });
        }
        
        return experience;
    }

    generateSkills(role) {
        const allSkills = [
            'customer_service', 'communication', 'teamwork', 'problem_solving',
            'time_management', 'organization', 'leadership', 'sales',
            'computer_skills', 'cash_handling', 'inventory_management',
            'cleaning', 'maintenance', 'security', 'conflict_resolution'
        ];
        
        const requiredSkills = role.requirements.skills || [];
        const additionalSkills = allSkills.filter(skill => !requiredSkills.includes(skill));
        
        // Start with required skills (with varying proficiency)
        const skills = {};
        requiredSkills.forEach(skill => {
            skills[skill] = Math.floor(Math.random() * 80) + 20; // 20-100 proficiency
        });
        
        // Add some additional skills
        const additionalCount = Math.floor(Math.random() * 4);
        for (let i = 0; i < additionalCount; i++) {
            const skill = additionalSkills[Math.floor(Math.random() * additionalSkills.length)];
            if (!skills[skill]) {
                skills[skill] = Math.floor(Math.random() * 70) + 10; // 10-80 proficiency
            }
        }
        
        return skills;
    }

    calculateQualificationScore(applicant, role) {
        let score = 0;
        const requirements = role.requirements;
        
        // Experience score (30 points)
        const experienceLevel = applicant.employment.experience.length;
        switch (requirements.experience) {
            case 'none':
                score += 30; // No experience required
                break;
            case 'some':
                score += Math.min(experienceLevel * 10, 30);
                break;
            case 'experienced':
                score += Math.min(experienceLevel * 5, 30);
                break;
        }
        
        // Skills score (40 points)
        const requiredSkills = requirements.skills || [];
        let skillsScore = 0;
        requiredSkills.forEach(skill => {
            const proficiency = applicant.employment.skills[skill] || 0;
            skillsScore += proficiency;
        });
        const averageSkills = skillsScore / (requiredSkills.length || 1);
        score += (averageSkills / 100) * 40;
        
        // Personality match (20 points)
        const requiredPersonality = requirements.personality || [];
        let personalityScore = 0;
        requiredPersonality.forEach(trait => {
            if (applicant.personalityTraits && applicant.personalityTraits.includes(trait)) {
                personalityScore += 20 / requiredPersonality.length;
            }
        });
        score += personalityScore;
        
        // Availability score (10 points)
        if (this.checkAvailabilityMatch(applicant, requirements)) {
            score += 10;
        }
        
        return Math.round(score);
    }

    // Interview process
    async scheduleInterview(applicationData) {
        const { applicationId, interviewDate, interviewType = 'in_person' } = applicationData;
        const application = this.activeApplications.get(applicationId);
        
        if (!application) {
            console.error('‚ùå Application not found:', applicationId);
            return false;
        }
        
        console.log(`üìÖ Scheduling interview for ${application.applicant.name}`);
        
        application.status = 'interview_scheduled';
        application.interview = {
            scheduledDate: interviewDate || Date.now() + (24 * 60 * 60 * 1000), // Default: tomorrow
            type: interviewType,
            status: 'scheduled',
            questions: this.generateInterviewQuestions(application.jobPostingId),
            duration: this.hiringConfig.interviewDuration
        };
        
        // Add to interview queue
        this.interviewQueue.push(application);
        
        // Emit interview scheduled event
        this.eventBus.emit('hiring.interviewScheduled', {
            application: application,
            interviewDate: application.interview.scheduledDate
        });
        
        return true;
    }

    generateInterviewQuestions(jobPostingId) {
        const commonQuestions = [
            "Tell me about yourself and your work experience.",
            "Why are you interested in working here?",
            "What are your greatest strengths?",
            "Describe a challenging situation you've handled.",
            "Where do you see yourself in 5 years?",
            "Why did you leave your last job?",
            "What motivates you at work?",
            "How do you handle stress and pressure?",
            "Do you have any questions for us?"
        ];
        
        const jobPosting = this.gameState.staff.openPositions.find(job => job.id === jobPostingId);
        const roleSpecificQuestions = this.getRoleSpecificQuestions(jobPosting?.roleId);
        
        // Combine and select random questions
        const allQuestions = [...commonQuestions, ...roleSpecificQuestions];
        const selectedQuestions = [];
        
        // Select 5-7 questions randomly
        const questionCount = Math.floor(Math.random() * 3) + 5;
        for (let i = 0; i < questionCount; i++) {
            const questionIndex = Math.floor(Math.random() * allQuestions.length);
            const question = allQuestions[questionIndex];
            if (!selectedQuestions.includes(question)) {
                selectedQuestions.push(question);
            }
        }
        
        return selectedQuestions;
    }

    getRoleSpecificQuestions(roleId) {
        const questionsByRole = {
            cashier: [
                "How would you handle an angry customer?",
                "Describe your experience with cash handling.",
                "How do you ensure accuracy in transactions?",
                "What would you do if the register came up short?"
            ],
            janitor: [
                "Are you comfortable working alone?",
                "How do you prioritize cleaning tasks?",
                "Have you worked with cleaning chemicals before?",
                "What would you do if you found something valuable?"
            ],
            stocker: [
                "Are you comfortable lifting heavy objects?",
                "How do you stay organized?",
                "What's your experience with inventory systems?",
                "How would you handle a delivery during busy hours?"
            ],
            security: [
                "Describe your conflict resolution skills.",
                "Have you worked in security before?",
                "How would you handle a suspected shoplifter?",
                "What's your approach to de-escalation?"
            ],
            assistant_manager: [
                "Describe your leadership experience.",
                "How do you motivate team members?",
                "What's your management philosophy?",
                "How do you handle employee conflicts?"
            ]
        };
        
        return questionsByRole[roleId] || [];
    }

    async conductInterview(interviewData) {
        const { applicationId, responses, interviewerNotes = '' } = interviewData;
        const application = this.activeApplications.get(applicationId);
        
        if (!application || application.status !== 'interview_scheduled') {
            console.error('‚ùå Invalid interview attempt:', applicationId);
            return false;
        }
        
        console.log(`üé§ Conducting interview with ${application.applicant.name}`);
        
        // Calculate interview score based on responses and applicant traits
        const interviewScore = this.calculateInterviewScore(application, responses);
        
        application.status = 'interviewed';
        application.interview.status = 'completed';
        application.interview.conductedDate = Date.now();
        application.interview.responses = responses;
        application.interview.score = interviewScore;
        application.interview.notes = interviewerNotes;
        application.interviewScore = interviewScore;
        
        // Update hiring metrics
        this.hiringMetrics.totalInterviews++;
        
        // Emit interview completed event
        this.eventBus.emit('hiring.interviewCompleted', {
            application: application,
            score: interviewScore
        });
        
        return interviewScore;
    }

    calculateInterviewScore(application, responses) {
        const applicant = application.applicant;
        let score = 0;
        
        // Base score from applicant traits
        const confidence = applicant.interview?.confidence || 50;
        const enthusiasm = applicant.interview?.enthusiasm || 50;
        const honesty = applicant.interview?.honesty || 50;
        const nervousness = applicant.interview?.nervousness || 50;
        
        // Calculate base performance (nervousness reduces performance)
        const basePerformance = (confidence + enthusiasm + honesty) / 3;
        const nervousnessReduction = nervousness / 10; // 0-10 point reduction
        
        score = basePerformance - nervousnessReduction;
        
        // Adjust based on response quality (if provided)
        if (responses && responses.length > 0) {
            const responseQuality = this.evaluateResponses(responses, application);
            score = (score + responseQuality) / 2;
        }
        
        // Random variation
        score += (Math.random() - 0.5) * 10;
        
        return Math.max(0, Math.min(100, Math.round(score)));
    }

    evaluateResponses(responses, application) {
        // Simple response evaluation based on length and keywords
        let score = 50; // Base score
        
        responses.forEach(response => {
            const length = response.length;
            
            // Prefer moderate length responses
            if (length > 50 && length < 300) {
                score += 5;
            } else if (length < 20) {
                score -= 10; // Too short
            } else if (length > 500) {
                score -= 5; // Too long
            }
            
            // Look for positive keywords
            const positiveWords = ['experience', 'teamwork', 'customer', 'responsible', 'reliable'];
            positiveWords.forEach(word => {
                if (response.toLowerCase().includes(word)) {
                    score += 2;
                }
            });
        });
        
        return Math.max(0, Math.min(100, score));
    }

    // Job offer and hiring
    async makeJobOffer(offerData) {
        const { applicationId, salary, benefits = {}, startDate } = offerData;
        const application = this.activeApplications.get(applicationId);
        
        if (!application || application.status !== 'interviewed') {
            console.error('‚ùå Cannot make offer for application:', applicationId);
            return false;
        }
        
        console.log(`üíº Making job offer to ${application.applicant.name}`);
        
        const jobOffer = {
            applicationId: applicationId,
            salary: salary,
            benefits: benefits,
            startDate: startDate || Date.now() + (7 * 24 * 60 * 60 * 1000), // Default: 1 week
            offerDate: Date.now(),
            expiryDate: Date.now() + (3 * 24 * 60 * 60 * 1000), // 3 days to respond
            status: 'pending' // pending, accepted, rejected, expired
        };
        
        application.status = 'offer_made';
        application.jobOffer = jobOffer;
        
        // Simulate applicant decision-making
        setTimeout(() => {
            this.processOfferResponse(application);
        }, Math.random() * 24 * 60 * 60 * 1000); // Response within 24 hours
        
        // Emit offer made event
        this.eventBus.emit('hiring.offerMade', {
            application: application,
            offer: jobOffer
        });
        
        return jobOffer;
    }

    processOfferResponse(application) {
        const offer = application.jobOffer;
        const applicant = application.applicant;
        
        // Calculate acceptance probability
        let acceptanceProbability = 0.7; // Base 70% chance
        
        // Adjust based on salary compared to expectation
        const salaryRatio = offer.salary / applicant.employment.salaryExpectation;
        if (salaryRatio >= 1.1) acceptanceProbability += 0.2;
        else if (salaryRatio < 0.9) acceptanceProbability -= 0.3;
        
        // Adjust based on store reputation
        const reputation = this.gameState.store?.reputation || 50;
        acceptanceProbability += (reputation - 50) / 100;
        
        // Adjust based on desperation (lower qualification score = more desperate)
        if (application.qualificationScore < 50) acceptanceProbability += 0.2;
        
        // Random factor
        acceptanceProbability += (Math.random() - 0.5) * 0.2;
        
        // Make decision
        const accepted = Math.random() < acceptanceProbability;
        
        if (accepted) {
            this.acceptJobOffer(application);
        } else {
            this.rejectJobOffer(application);
        }
    }

    acceptJobOffer(application) {
        console.log(`‚úÖ ${application.applicant.name} accepted job offer`);
        
        application.status = 'hired';
        application.jobOffer.status = 'accepted';
        application.hireDate = Date.now();
        
        // Add to hired staff
        this.onboardNewStaff(application);
        
        // Update hiring metrics
        this.hiringMetrics.totalHires++;
        
        // Emit offer accepted event
        this.eventBus.emit('hiring.offerAccepted', {
            application: application,
            employee: application.applicant
        });
    }

    rejectJobOffer(application) {
        console.log(`‚ùå ${application.applicant.name} rejected job offer`);
        
        application.status = 'rejected';
        application.jobOffer.status = 'rejected';
        application.rejectionReason = this.generateRejectionReason();
        
        // Emit offer rejected event
        this.eventBus.emit('hiring.offerRejected', {
            application: application,
            reason: application.rejectionReason
        });
    }

    generateRejectionReason() {
        const reasons = [
            'Found a better opportunity',
            'Salary below expectations',
            'Schedule conflicts',
            'Changed career direction',
            'Personal circumstances',
            'Too far from home',
            'Benefits not competitive'
        ];
        
        return reasons[Math.floor(Math.random() * reasons.length)];
    }

    // Staff onboarding
    onboardNewStaff(application) {
        const employee = this.createEmployeeRecord(application);
        
        // Add to game state
        this.gameState.staff.employees.push(employee);
        this.hiredStaff.set(employee.id, employee);
        
        // Start probation period
        this.startProbationPeriod(employee);
        
        // Emit staff hired event
        this.eventBus.emit('staff.hired', {
            employee: employee,
            application: application
        });
        
        console.log(`üéâ ${employee.name} successfully onboarded as ${employee.role.title}`);
        
        return employee;
    }

    createEmployeeRecord(application) {
        const applicant = application.applicant;
        const role = this.jobRoles.get(application.jobPostingId);
        
        return {
            id: this.generateEmployeeId(),
            name: applicant.name,
            role: role,
            hireDate: Date.now(),
            salary: application.jobOffer.salary,
            benefits: application.jobOffer.benefits,
            
            // Performance tracking
            performance: {
                productivity: 50, // Will improve with experience
                reliability: applicant.interview?.honesty || 75,
                customerSatisfaction: 50,
                teamwork: 50,
                punctuality: 75,
                overallRating: 50
            },
            
            // Work tracking
            schedule: {
                hoursWorked: 0,
                shiftsCompleted: 0,
                overtime: 0,
                absences: 0,
                tardiness: 0
            },
            
            // Status
            status: 'probation', // probation, active, terminated
            probationEndDate: Date.now() + (this.hiringConfig.probationPeriod * 24 * 60 * 60 * 1000),
            
            // Development
            training: {
                completed: [],
                inProgress: [],
                required: this.getRequiredTraining(role)
            },
            
            // Personal info
            personalInfo: {
                age: applicant.age,
                personality: applicant.personalityTraits,
                availability: applicant.employment.availability,
                emergencyContact: this.generateEmergencyContact()
            }
        };
    }

    getRequiredTraining(role) {
        const trainingByRole = {
            cashier: ['register_operation', 'customer_service', 'cash_handling', 'store_policies'],
            janitor: ['safety_procedures', 'equipment_use', 'chemical_handling'],
            stocker: ['inventory_systems', 'lifting_safety', 'product_organization'],
            security: ['loss_prevention', 'incident_reporting', 'conflict_resolution'],
            assistant_manager: ['leadership', 'policy_enforcement', 'performance_management']
        };
        
        return trainingByRole[role.id] || ['basic_orientation'];
    }

    // Daily and weekly processing
    processDailyHiring() {
        // Process application deadlines
        this.processApplicationDeadlines();
        
        // Process interview schedules
        this.processScheduledInterviews();
        
        // Process offer deadlines
        this.processOfferDeadlines();
        
        // Generate new applicants for open positions
        this.generateDailyApplicants();
    }

    processWeeklyHiring() {
        // Update hiring metrics
        this.updateHiringMetrics();
        
        // Process probation periods
        this.processProbationPeriods();
        
        // Generate hiring reports
        this.generateHiringReport();
    }

    // Utility methods
    generateJobId() {
        return 'job_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    generateApplicationId() {
        return 'app_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    generateEmployeeId() {
        return 'emp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // Public API
    getJobRoles() {
        return Array.from(this.jobRoles.values());
    }

    getOpenPositions() {
        return this.gameState.staff.openPositions.filter(job => job.status === 'active');
    }

    getApplications(status = null) {
        if (status) {
            return this.gameState.staff.applications.filter(app => app.status === status);
        }
        return this.gameState.staff.applications;
    }

    getHiredStaff() {
        return this.gameState.staff.employees;
    }

    getHiringMetrics() {
        return { ...this.hiringMetrics };
    }

    // Manual hiring actions for player
    async requestJobPosting(roleId, urgency = 'normal') {
        return await this.postJobOpening({ roleId, urgency });
    }

    async reviewApplication(applicationId) {
        const application = this.activeApplications.get(applicationId);
        if (application) {
            application.status = 'reviewed';
            return application;
        }
        return null;
    }

    async approveForInterview(applicationId) {
        return await this.scheduleInterview({ applicationId });
    }

    async completeInterview(applicationId, responses, notes) {
        return await this.conductInterview({ applicationId, responses, interviewerNotes: notes });
    }

    async extendJobOffer(applicationId, salary, benefits) {
        return await this.makeJobOffer({ applicationId, salary, benefits });
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = StaffHiringSystem;
} else if (typeof window !== 'undefined') {
    window.StaffHiringSystem = StaffHiringSystem;
}


/* === src/scripts/interfaces/staffHiringInterface.js === */
/**
 * Staff Hiring Interface - Phase 5A UI Implementation
 * Complete hiring management interface for the workstation system
 * Handles job postings, applications, interviews, and hiring decisions
 */

class StaffHiringInterface {
    constructor() {
        this.hiringSystem = null;
        this.gameState = null;
        this.eventBus = null;
        
        // UI state
        this.currentView = 'overview'; // overview, postings, applications, interviews, employees
        this.selectedApplication = null;
        this.selectedJobPosting = null;
        this.interviewInProgress = false;
        
        // Filters and sorting
        this.applicationFilters = {
            status: 'all',
            role: 'all',
            qualificationScore: 0
        };
        
        this.sortOptions = {
            applications: 'submittedDate', // submittedDate, qualificationScore, name
            employees: 'hireDate' // hireDate, name, performance
        };
    }

    initialize(hiringSystem, gameState, eventBus) {
        this.hiringSystem = hiringSystem;
        this.gameState = gameState;
        this.eventBus = eventBus;
        
        this.setupEventListeners();
        console.log('üíº Staff Hiring Interface initialized');
    }

    setupEventListeners() {
        // Listen for hiring events to update UI
        this.eventBus.on('hiring.applicationReceived', () => this.refreshApplicationsList());
        this.eventBus.on('hiring.interviewCompleted', () => this.refreshApplicationsList());
        this.eventBus.on('hiring.offerAccepted', () => this.refreshEmployeesList());
        this.eventBus.on('staff.hired', () => this.refreshEmployeesList());
    }

    render() {
        return `
            <div class="staff-hiring-app">
                ${this.renderHeader()}
                ${this.renderNavigation()}
                ${this.renderMainContent()}
                ${this.renderModal()}
            </div>
        `;
    }

    renderHeader() {
        const metrics = this.hiringSystem.getHiringMetrics();
        const openPositions = this.hiringSystem.getOpenPositions().length;
        const pendingApplications = this.hiringSystem.getApplications('submitted').length;
        
        return `
            <div class="hiring-header">
                <div class="header-title">
                    <h2>üëî Staff Hiring Center</h2>
                    <p>Recruit and manage your store's workforce</p>
                </div>
                
                <div class="hiring-metrics">
                    <div class="metric-card">
                        <div class="metric-icon">üì¢</div>
                        <div class="metric-info">
                            <span class="metric-value">${openPositions}</span>
                            <span class="metric-label">Open Positions</span>
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <div class="metric-icon">üìÑ</div>
                        <div class="metric-info">
                            <span class="metric-value">${pendingApplications}</span>
                            <span class="metric-label">New Applications</span>
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <div class="metric-icon">üé§</div>
                        <div class="metric-info">
                            <span class="metric-value">${metrics.totalInterviews}</span>
                            <span class="metric-label">Total Interviews</span>
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <div class="metric-icon">‚úÖ</div>
                        <div class="metric-info">
                            <span class="metric-value">${metrics.totalHires}</span>
                            <span class="metric-label">Total Hires</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    renderNavigation() {
        const tabs = [
            { id: 'overview', label: 'Overview', icon: 'üìä' },
            { id: 'postings', label: 'Job Postings', icon: 'üì¢' },
            { id: 'applications', label: 'Applications', icon: 'üìÑ' },
            { id: 'interviews', label: 'Interviews', icon: 'üé§' },
            { id: 'employees', label: 'Employees', icon: 'üë•' }
        ];
        
        return `
            <div class="hiring-navigation">
                ${tabs.map(tab => `
                    <button 
                        class="nav-tab ${this.currentView === tab.id ? 'active' : ''}"
                        onclick="hiringInterface.switchView('${tab.id}')"
                    >
                        <span class="tab-icon">${tab.icon}</span>
                        <span class="tab-label">${tab.label}</span>
                    </button>
                `).join('')}
            </div>
        `;
    }

    renderMainContent() {
        switch (this.currentView) {
            case 'overview':
                return this.renderOverview();
            case 'postings':
                return this.renderJobPostings();
            case 'applications':
                return this.renderApplications();
            case 'interviews':
                return this.renderInterviews();
            case 'employees':
                return this.renderEmployees();
            default:
                return this.renderOverview();
        }
    }

    renderOverview() {
        const jobRoles = this.hiringSystem.getJobRoles();
        const openPositions = this.hiringSystem.getOpenPositions();
        const recentApplications = this.hiringSystem.getApplications()
            .sort((a, b) => b.submittedDate - a.submittedDate)
            .slice(0, 5);
        
        return `
            <div class="hiring-overview">
                <div class="overview-section">
                    <h3>üéØ Quick Actions</h3>
                    <div class="quick-actions">
                        <button class="action-btn primary" onclick="hiringInterface.showPostJobModal()">
                            <span class="btn-icon">üì¢</span>
                            Post New Job
                        </button>
                        <button class="action-btn" onclick="hiringInterface.switchView('applications')">
                            <span class="btn-icon">üìÑ</span>
                            Review Applications
                        </button>
                        <button class="action-btn" onclick="hiringInterface.switchView('interviews')">
                            <span class="btn-icon">üé§</span>
                            Schedule Interviews
                        </button>
                    </div>
                </div>
                
                <div class="overview-section">
                    <h3>üíº Available Positions</h3>
                    <div class="job-roles-grid">
                        ${jobRoles.map(role => this.renderJobRoleCard(role, openPositions)).join('')}
                    </div>
                </div>
                
                <div class="overview-section">
                    <h3>üìã Recent Applications</h3>
                    <div class="recent-applications">
                        ${recentApplications.length > 0 ? 
                            recentApplications.map(app => this.renderApplicationSummary(app)).join('') :
                            '<p class="no-data">No recent applications</p>'
                        }
                    </div>
                </div>
            </div>
        `;
    }

    renderJobRoleCard(role, openPositions) {
        const hasOpenPosition = openPositions.some(pos => pos.roleId === role.id);
        const currentEmployees = this.gameState.staff.employees.filter(emp => emp.role.id === role.id);
        
        return `
            <div class="job-role-card ${hasOpenPosition ? 'has-opening' : ''}">
                <div class="role-header">
                    <span class="role-icon">${role.icon}</span>
                    <h4>${role.title}</h4>
                </div>
                
                <div class="role-info">
                    <p class="role-description">${role.description}</p>
                    <div class="role-details">
                        <span class="detail-item">üí∞ ${role.dailyWage}/day</span>
                        <span class="detail-item">üë• ${currentEmployees.length} employed</span>
                        <span class="detail-item">‚è∞ ${role.maxHours}h max</span>
                    </div>
                </div>
                
                <div class="role-actions">
                    ${hasOpenPosition ? 
                        '<span class="status-badge active">Position Open</span>' :
                        `<button class="btn-small" onclick="hiringInterface.postJob('${role.id}')">Post Job</button>`
                    }
                </div>
            </div>
        `;
    }

    renderApplicationSummary(application) {
        const timeAgo = this.formatTimeAgo(application.submittedDate);
        const role = this.hiringSystem.getJobRoles().find(r => r.id === application.jobPostingId);
        
        return `
            <div class="application-summary" onclick="hiringInterface.viewApplication('${application.id}')">
                <div class="summary-info">
                    <span class="applicant-name">${application.applicant.name}</span>
                    <span class="applied-role">${role?.title || 'Unknown Role'}</span>
                </div>
                <div class="summary-details">
                    <span class="qualification-score">${application.qualificationScore}% match</span>
                    <span class="application-time">${timeAgo}</span>
                </div>
                <div class="summary-status">
                    <span class="status-badge ${application.status}">${this.formatStatus(application.status)}</span>
                </div>
            </div>
        `;
    }

    renderJobPostings() {
        const openPositions = this.hiringSystem.getOpenPositions();
        const jobRoles = this.hiringSystem.getJobRoles();
        
        return `
            <div class="job-postings-view">
                <div class="view-header">
                    <h3>üì¢ Job Postings</h3>
                    <button class="btn primary" onclick="hiringInterface.showPostJobModal()">
                        + Post New Job
                    </button>
                </div>
                
                <div class="postings-list">
                    ${openPositions.length > 0 ? 
                        openPositions.map(posting => this.renderJobPosting(posting)).join('') :
                        this.renderNoPostings()
                    }
                </div>
                
                <div class="available-roles">
                    <h4>üíº Available Roles to Post</h4>
                    <div class="roles-grid">
                        ${jobRoles.map(role => this.renderPostableRole(role, openPositions)).join('')}
                    </div>
                </div>
            </div>
        `;
    }

    renderJobPosting(posting) {
        const role = posting.role;
        const postedTime = this.formatTimeAgo(posting.postedDate);
        
        return `
            <div class="job-posting-card">
                <div class="posting-header">
                    <div class="posting-title">
                        <span class="role-icon">${role.icon}</span>
                        <h4>${role.title}</h4>
                        <span class="urgency-badge ${posting.urgency}">${posting.urgency}</span>
                    </div>
                    <div class="posting-actions">
                        <button class="btn-small" onclick="hiringInterface.editPosting('${posting.id}')">Edit</button>
                        <button class="btn-small danger" onclick="hiringInterface.closePosting('${posting.id}')">Close</button>
                    </div>
                </div>
                
                <div class="posting-info">
                    <p>${role.description}</p>
                    <div class="posting-details">
                        <span class="detail">üí∞ ${posting.salaryOffer}/day</span>
                        <span class="detail">üìÑ ${posting.applicationsReceived} applications</span>
                        <span class="detail">‚è∞ Posted ${postedTime}</span>
                    </div>
                </div>
                
                <div class="posting-requirements">
                    <h5>Requirements:</h5>
                    <ul>
                        <li>Experience: ${this.formatExperience(role.requirements.experience)}</li>
                        <li>Education: ${this.formatEducation(role.requirements.education)}</li>
                        <li>Skills: ${role.requirements.skills.join(', ')}</li>
                        ${role.requirements.backgroundCheck ? '<li>Background check required</li>' : ''}
                    </ul>
                </div>
            </div>
        `;
    }

    renderNoPostings() {
        return `
            <div class="no-postings">
                <div class="no-data-icon">üì¢</div>
                <h4>No Active Job Postings</h4>
                <p>Create your first job posting to start recruiting talent for your store.</p>
                <button class="btn primary" onclick="hiringInterface.showPostJobModal()">
                    Post Your First Job
                </button>
            </div>
        `;
    }

    renderPostableRole(role, openPositions) {
        const hasOpenPosition = openPositions.some(pos => pos.roleId === role.id);
        
        if (hasOpenPosition) return '';
        
        return `
            <div class="postable-role" onclick="hiringInterface.postJob('${role.id}')">
                <span class="role-icon">${role.icon}</span>
                <span class="role-title">${role.title}</span>
                <span class="role-wage">${role.dailyWage}/day</span>
            </div>
        `;
    }

    renderApplications() {
        const applications = this.getFilteredApplications();
        
        return `
            <div class="applications-view">
                <div class="view-header">
                    <h3>üìÑ Job Applications</h3>
                    ${this.renderApplicationFilters()}
                </div>
                
                <div class="applications-list">
                    ${applications.length > 0 ? 
                        applications.map(app => this.renderApplicationCard(app)).join('') :
                        '<div class="no-data">No applications match your filters</div>'
                    }
                </div>
            </div>
        `;
    }

    renderApplicationFilters() {
        const statuses = ['all', 'submitted', 'reviewed', 'interview_scheduled', 'interviewed', 'offer_made', 'hired', 'rejected'];
        const roles = ['all', ...this.hiringSystem.getJobRoles().map(r => r.id)];
        
        return `
            <div class="application-filters">
                <select onchange="hiringInterface.updateFilter('status', this.value)">
                    ${statuses.map(status => `
                        <option value="${status}" ${this.applicationFilters.status === status ? 'selected' : ''}>
                            ${this.formatStatus(status)}
                        </option>
                    `).join('')}
                </select>
                
                <select onchange="hiringInterface.updateFilter('role', this.value)">
                    ${roles.map(role => `
                        <option value="${role}" ${this.applicationFilters.role === role ? 'selected' : ''}>
                            ${role === 'all' ? 'All Roles' : this.formatRoleName(role)}
                        </option>
                    `).join('')}
                </select>
                
                <div class="score-filter">
                    <label>Min Score: ${this.applicationFilters.qualificationScore}%</label>
                    <input 
                        type="range" 
                        min="0" 
                        max="100" 
                        value="${this.applicationFilters.qualificationScore}"
                        onchange="hiringInterface.updateFilter('qualificationScore', this.value)"
                    >
                </div>
            </div>
        `;
    }

    renderApplicationCard(application) {
        const applicant = application.applicant;
        const timeAgo = this.formatTimeAgo(application.submittedDate);
        const role = this.hiringSystem.getJobRoles().find(r => r.id === application.jobPostingId);
        
        return `
            <div class="application-card" onclick="hiringInterface.viewApplication('${application.id}')">
                <div class="application-header">
                    <div class="applicant-info">
                        <h4>${applicant.name}</h4>
                        <p>Applied for ${role?.title || 'Unknown Role'}</p>
                    </div>
                    <div class="application-score">
                        <div class="score-circle ${this.getScoreClass(application.qualificationScore)}">
                            ${application.qualificationScore}%
                        </div>
                    </div>
                </div>
                
                <div class="application-details">
                    <div class="detail-row">
                        <span class="label">Experience:</span>
                        <span class="value">${this.formatExperience(applicant.employment.experience.length)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="label">Skills:</span>
                        <span class="value">${Object.keys(applicant.employment.skills).slice(0, 3).join(', ')}</span>
                    </div>
                    <div class="detail-row">
                        <span class="label">Applied:</span>
                        <span class="value">${timeAgo}</span>
                    </div>
                </div>
                
                <div class="application-footer">
                    <span class="status-badge ${application.status}">${this.formatStatus(application.status)}</span>
                    <div class="quick-actions">
                        ${this.renderApplicationQuickActions(application)}
                    </div>
                </div>
            </div>
        `;
    }

    renderApplicationQuickActions(application) {
        switch (application.status) {
            case 'submitted':
                return `
                    <button class="btn-small" onclick="hiringInterface.scheduleInterview('${application.id}'); event.stopPropagation();">
                        üìÖ Interview
                    </button>
                    <button class="btn-small danger" onclick="hiringInterface.rejectApplication('${application.id}'); event.stopPropagation();">
                        ‚ùå Reject
                    </button>
                `;
            case 'interview_scheduled':
                return `
                    <button class="btn-small" onclick="hiringInterface.conductInterview('${application.id}'); event.stopPropagation();">
                        üé§ Conduct
                    </button>
                `;
            case 'interviewed':
                return `
                    <button class="btn-small" onclick="hiringInterface.makeOffer('${application.id}'); event.stopPropagation();">
                        üíº Make Offer
                    </button>
                    <button class="btn-small danger" onclick="hiringInterface.rejectApplication('${application.id}'); event.stopPropagation();">
                        ‚ùå Reject
                    </button>
                `;
            default:
                return '';
        }
    }

    renderInterviews() {
        const scheduledInterviews = this.hiringSystem.getApplications('interview_scheduled');
        const completedInterviews = this.hiringSystem.getApplications('interviewed');
        
        return `
            <div class="interviews-view">
                <div class="view-header">
                    <h3>üé§ Interviews</h3>
                </div>
                
                <div class="interviews-section">
                    <h4>üìÖ Scheduled Interviews (${scheduledInterviews.length})</h4>
                    <div class="interviews-list">
                        ${scheduledInterviews.length > 0 ? 
                            scheduledInterviews.map(app => this.renderScheduledInterview(app)).join('') :
                            '<p class="no-data">No interviews scheduled</p>'
                        }
                    </div>
                </div>
                
                <div class="interviews-section">
                    <h4>‚úÖ Completed Interviews (${completedInterviews.length})</h4>
                    <div class="interviews-list">
                        ${completedInterviews.length > 0 ? 
                            completedInterviews.map(app => this.renderCompletedInterview(app)).join('') :
                            '<p class="no-data">No completed interviews</p>'
                        }
                    </div>
                </div>
            </div>
        `;
    }

    renderScheduledInterview(application) {
        const applicant = application.applicant;
        const interview = application.interview;
        const scheduleTime = new Date(interview.scheduledDate).toLocaleString();
        
        return `
            <div class="interview-card scheduled">
                <div class="interview-header">
                    <h4>${applicant.name}</h4>
                    <span class="interview-time">${scheduleTime}</span>
                </div>
                
                <div class="interview-info">
                    <p>Qualification Score: <strong>${application.qualificationScore}%</strong></p>
                    <p>Interview Type: <strong>${interview.type}</strong></p>
                    <p>Duration: <strong>${interview.duration} minutes</strong></p>
                </div>
                
                <div class="interview-actions">
                    <button class="btn primary" onclick="hiringInterface.conductInterview('${application.id}')">
                        üé§ Start Interview
                    </button>
                    <button class="btn" onclick="hiringInterface.rescheduleInterview('${application.id}')">
                        üìÖ Reschedule
                    </button>
                </div>
            </div>
        `;
    }

    renderCompletedInterview(application) {
        const applicant = application.applicant;
        const interview = application.interview;
        const completedTime = new Date(interview.conductedDate).toLocaleString();
        
        return `
            <div class="interview-card completed">
                <div class="interview-header">
                    <h4>${applicant.name}</h4>
                    <span class="interview-score ${this.getScoreClass(interview.score)}">${interview.score}%</span>
                </div>
                
                <div class="interview-details">
                    <p>Completed: ${completedTime}</p>
                    <p>Qualification: ${application.qualificationScore}% | Interview: ${interview.score}%</p>
                    ${interview.notes ? `<p class="interview-notes">"${interview.notes}"</p>` : ''}
                </div>
                
                <div class="interview-actions">
                    <button class="btn primary" onclick="hiringInterface.makeOffer('${application.id}')">
                        üíº Make Offer
                    </button>
                    <button class="btn danger" onclick="hiringInterface.rejectApplication('${application.id}')">
                        ‚ùå Reject
                    </button>
                </div>
            </div>
        `;
    }

    renderEmployees() {
        const employees = this.hiringSystem.getHiredStaff();
        
        return `
            <div class="employees-view">
                <div class="view-header">
                    <h3>üë• Current Employees (${employees.length})</h3>
                    <div class="employee-stats">
                        <span>Active: ${employees.filter(e => e.status === 'active').length}</span>
                        <span>Probation: ${employees.filter(e => e.status === 'probation').length}</span>
                    </div>
                </div>
                
                <div class="employees-list">
                    ${employees.length > 0 ? 
                        employees.map(emp => this.renderEmployeeCard(emp)).join('') :
                        '<div class="no-data">No employees hired yet</div>'
                    }
                </div>
            </div>
        `;
    }

    renderEmployeeCard(employee) {
        const hireDate = new Date(employee.hireDate).toLocaleDateString();
        const performance = employee.performance.overallRating;
        
        return `
            <div class="employee-card">
                <div class="employee-header">
                    <div class="employee-info">
                        <h4>${employee.name}</h4>
                        <p>${employee.role.icon} ${employee.role.title}</p>
                    </div>
                    <div class="employee-status">
                        <span class="status-badge ${employee.status}">${employee.status}</span>
                        <span class="performance-score ${this.getScoreClass(performance)}">${performance}%</span>
                    </div>
                </div>
                
                <div class="employee-details">
                    <div class="detail-row">
                        <span class="label">Hired:</span>
                        <span class="value">${hireDate}</span>
                    </div>
                    <div class="detail-row">
                        <span class="label">Salary:</span>
                        <span class="value">${employee.salary}/day</span>
                    </div>
                    <div class="detail-row">
                        <span class="label">Hours Worked:</span>
                        <span class="value">${employee.schedule.hoursWorked}</span>
                    </div>
                </div>
                
                <div class="employee-actions">
                    <button class="btn-small" onclick="hiringInterface.viewEmployee('${employee.id}')">
                        üëÅÔ∏è View Details
                    </button>
                    <button class="btn-small" onclick="hiringInterface.manageEmployee('${employee.id}')">
                        ‚öôÔ∏è Manage
                    </button>
                </div>
            </div>
        `;
    }

    renderModal() {
        return `
            <div id="hiringModal" class="modal-overlay" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 id="modalTitle">Modal Title</h3>
                        <button class="modal-close" onclick="hiringInterface.closeModal()">√ó</button>
                    </div>
                    <div class="modal-body" id="modalBody">
                        <!-- Dynamic content -->
                    </div>
                </div>
            </div>
        `;
    }

    // UI State Management
    switchView(view) {
        this.currentView = view;
        this.refreshUI();
    }

    updateFilter(filterType, value) {
        this.applicationFilters[filterType] = value;
        this.refreshUI();
    }

    refreshUI() {
        // Refresh the current view content
        const mainContent = document.querySelector('.staff-hiring-app .hiring-main');
        if (mainContent) {
            mainContent.innerHTML = this.renderMainContent();
        }
    }

    refreshApplicationsList() {
        if (this.currentView === 'applications') {
            this.refreshUI();
        }
    }

    refreshEmployeesList() {
        if (this.currentView === 'employees') {
            this.refreshUI();
        }
    }

    // Modal Management
    showModal(title, content) {
        document.getElementById('modalTitle').textContent = title;
        document.getElementById('modalBody').innerHTML = content;
        document.getElementById('hiringModal').style.display = 'flex';
    }

    closeModal() {
        document.getElementById('hiringModal').style.display = 'none';
    }

    // Action Handlers
    async showPostJobModal() {
        const roles = this.hiringSystem.getJobRoles();
        const openPositions = this.hiringSystem.getOpenPositions();
        const availableRoles = roles.filter(role => 
            !openPositions.some(pos => pos.roleId === role.id)
        );
        
        const modalContent = `
            <form onsubmit="hiringInterface.submitJobPosting(event)">
                <div class="form-group">
                    <label>Job Role:</label>
                    <select id="jobRole" required>
                        <option value="">Select a role...</option>
                        ${availableRoles.map(role => `
                            <option value="${role.id}">${role.icon} ${role.title} - ${role.dailyWage}/day</option>
                        `).join('')}
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Urgency:</label>
                    <select id="urgency">
                        <option value="normal">Normal</option>
                        <option value="urgent">Urgent</option>
                        <option value="low">Low Priority</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Salary Offer (optional):</label>
                    <input type="number" id="salaryOffer" placeholder="Leave empty for default wage">
                </div>
                
                <div class="form-actions">
                    <button type="button" onclick="hiringInterface.closeModal()">Cancel</button>
                    <button type="submit" class="btn primary">Post Job</button>
                </div>
            </form>
        `;
        
        this.showModal('üì¢ Post New Job', modalContent);
    }

    async submitJobPosting(event) {
        event.preventDefault();
        
        const roleId = document.getElementById('jobRole').value;
        const urgency = document.getElementById('urgency').value;
        const salaryOffer = document.getElementById('salaryOffer').value;
        
        if (!roleId) {
            alert('Please select a job role');
            return;
        }
        
        const jobData = {
            roleId: roleId,
            urgency: urgency,
            salaryOffer: salaryOffer ? parseInt(salaryOffer) : null
        };
        
        try {
            await this.hiringSystem.postJobOpening(jobData);
            this.closeModal();
            this.refreshUI();
            console.log('‚úÖ Job posted successfully');
        } catch (error) {
            console.error('‚ùå Error posting job:', error);
            alert('Failed to post job. Please try again.');
        }
    }

    async postJob(roleId) {
        try {
            await this.hiringSystem.requestJobPosting(roleId);
            this.refreshUI();
            console.log('‚úÖ Job posted for role:', roleId);
        } catch (error) {
            console.error('‚ùå Error posting job:', error);
        }
    }

    // Utility Methods
    getFilteredApplications() {
        let applications = this.hiringSystem.getApplications();
        
        if (this.applicationFilters.status !== 'all') {
            applications = applications.filter(app => app.status === this.applicationFilters.status);
        }
        
        if (this.applicationFilters.role !== 'all') {
            applications = applications.filter(app => app.jobPostingId === this.applicationFilters.role);
        }
        
        if (this.applicationFilters.qualificationScore > 0) {
            applications = applications.filter(app => app.qualificationScore >= this.applicationFilters.qualificationScore);
        }
        
        return applications.sort((a, b) => b.submittedDate - a.submittedDate);
    }

    formatTimeAgo(timestamp) {
        const now = Date.now();
        const diff = now - timestamp;
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        
        if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
        if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        return 'Just now';
    }

    formatStatus(status) {
        const statusMap = {
            'all': 'All Applications',
            'submitted': 'New Application',
            'reviewed': 'Under Review',
            'interview_scheduled': 'Interview Scheduled',
            'interviewed': 'Interview Complete',
            'offer_made': 'Offer Extended',
            'hired': 'Hired',
            'rejected': 'Rejected',
            'probation': 'On Probation',
            'active': 'Active'
        };
        
        return statusMap[status] || status;
    }

    formatExperience(experience) {
        if (typeof experience === 'string') {
            return experience === 'none' ? 'No experience required' : 
                   experience === 'some' ? 'Some experience preferred' : 
                   'Experienced candidate required';
        }
        
        if (typeof experience === 'number') {
            return experience === 0 ? 'No experience' : 
                   experience === 1 ? '1 previous job' : 
                   `${experience} previous jobs`;
        }
        
        return 'Unknown';
    }

    formatEducation(education) {
        const educationMap = {
            'none': 'No requirements',
            'high_school': 'High school diploma',
            'college_preferred': 'College preferred',
            'college_required': 'College degree required'
        };
        
        return educationMap[education] || education;
    }

    formatRoleName(roleId) {
        const role = this.hiringSystem.getJobRoles().find(r => r.id === roleId);
        return role ? role.title : roleId;
    }

    getScoreClass(score) {
        if (score >= 80) return 'excellent';
        if (score >= 70) return 'good';
        if (score >= 60) return 'average';
        if (score >= 50) return 'below-average';
        return 'poor';
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = StaffHiringInterface;
} else if (typeof window !== 'undefined') {
    window.StaffHiringInterface = StaffHiringInterface;
}


/* === src/scripts/systems/staffManagementSystem.js === */
/**
 * Staff Management & Scheduling System - Phase 5B Implementation
 * Comprehensive staff scheduling, performance management, and team coordination
 * Builds upon Phase 5A hiring system with advanced management features
 */

class StaffManagementSystem {
    constructor() {
        this.gameState = null;
        this.eventBus = null;
        this.hiringSystem = null;
        this.timeSystem = null;
        
        // Scheduling system
        this.schedules = new Map(); // employeeId -> schedule data
        this.shifts = new Map(); // shiftId -> shift data
        this.timeSlots = new Map(); // time -> assigned employees
        this.shiftTemplates = new Map(); // template management
        
        // Performance management
        this.performanceReviews = new Map();
        this.trainingPrograms = new Map();
        this.disciplinaryActions = new Map();
        this.employeeFeedback = new Map();
        
        // Team dynamics
        this.teamRelationships = new Map();
        this.teamMorale = new Map();
        this.workGroups = new Map();
        
        // Management configuration
        this.managementConfig = {
            maxHoursPerWeek: 40,
            overtimeThreshold: 8, // hours per day
            breakDuration: 30, // minutes
            minShiftLength: 4, // hours
            maxShiftLength: 10, // hours
            reviewPeriod: 90, // days
            probationPeriod: 14, // days
            minStaffing: 2, // minimum employees during open hours
            maxStaffing: 8 // maximum concurrent employees
        };
        
        // Performance metrics
        this.performanceMetrics = {
            productivity: new Map(),
            customerSatisfaction: new Map(),
            punctuality: new Map(),
            teamwork: new Map(),
            reliability: new Map(),
            overallPerformance: new Map()
        };
    }

    initialize(gameState, eventBus, hiringSystem, timeSystem) {
        this.gameState = gameState;
        this.eventBus = eventBus;
        this.hiringSystem = hiringSystem;
        this.timeSystem = timeSystem;
        
        this.setupShiftTemplates();
        this.setupTrainingPrograms();
        this.setupEventListeners();
        this.initializeSchedulingSystem();
        
        console.log('üìÖ Staff Management & Scheduling System initialized');
    }

    setupShiftTemplates() {
        // Define standard shift templates
        this.shiftTemplates.set('morning', {
            id: 'morning',
            name: 'Morning Shift',
            icon: 'üåÖ',
            startTime: '08:00',
            endTime: '16:00',
            duration: 8,
            breakTimes: ['10:00', '12:00', '14:00'],
            positions: {
                cashier: 2,
                stocker: 1,
                janitor: 0,
                security: 1,
                assistant_manager: 1
            },
            priority: 'high' // high customer traffic
        });

        this.shiftTemplates.set('afternoon', {
            id: 'afternoon',
            name: 'Afternoon Shift',
            icon: '‚òÄÔ∏è',
            startTime: '12:00',
            endTime: '20:00',
            duration: 8,
            breakTimes: ['14:00', '16:00', '18:00'],
            positions: {
                cashier: 3,
                stocker: 2,
                janitor: 0,
                security: 1,
                assistant_manager: 1
            },
            priority: 'high' // peak hours
        });

        this.shiftTemplates.set('evening', {
            id: 'evening',
            name: 'Evening Shift',
            icon: 'üåÜ',
            startTime: '16:00',
            endTime: '24:00',
            duration: 8,
            breakTimes: ['18:00', '20:00', '22:00'],
            positions: {
                cashier: 2,
                stocker: 1,
                janitor: 1,
                security: 2,
                assistant_manager: 1
            },
            priority: 'medium'
        });

        this.shiftTemplates.set('night', {
            id: 'night',
            name: 'Night Shift',
            icon: 'üåô',
            startTime: '22:00',
            endTime: '06:00',
            duration: 8,
            breakTimes: ['00:00', '02:00', '04:00'],
            positions: {
                cashier: 1,
                stocker: 2,
                janitor: 1,
                security: 2,
                assistant_manager: 0
            },
            priority: 'low',
            nightShiftBonus: 1.5 // 50% bonus for night work
        });

        this.shiftTemplates.set('weekend', {
            id: 'weekend',
            name: 'Weekend Shift',
            icon: 'üéâ',
            startTime: '10:00',
            endTime: '22:00',
            duration: 12,
            breakTimes: ['12:00', '15:00', '18:00'],
            positions: {
                cashier: 3,
                stocker: 2,
                janitor: 1,
                security: 2,
                assistant_manager: 1
            },
            priority: 'high',
            weekendBonus: 1.25 // 25% weekend bonus
        });

        console.log(`üìã Shift templates configured: ${this.shiftTemplates.size} templates`);
    }

    setupTrainingPrograms() {
        // Define comprehensive training programs for each role
        this.trainingPrograms.set('basic_orientation', {
            id: 'basic_orientation',
            name: 'Basic Store Orientation',
            icon: 'üìö',
            duration: 4, // hours
            cost: 50,
            description: 'Introduction to store policies, procedures, and safety',
            required: true,
            applicableRoles: ['all'],
            modules: [
                'Store Layout and Navigation',
                'Company Values and Mission',
                'Basic Safety Procedures',
                'Customer Service Standards',
                'Emergency Procedures'
            ],
            skillBoosts: {
                'communication': 10,
                'customer_service': 15,
                'safety_awareness': 20
            }
        });

        this.trainingPrograms.set('cashier_certification', {
            id: 'cashier_certification',
            name: 'Cashier Certification',
            icon: 'üí∞',
            duration: 6,
            cost: 100,
            description: 'Complete training for register operation and cash handling',
            required: true,
            applicableRoles: ['cashier', 'assistant_manager'],
            modules: [
                'POS System Operation',
                'Cash Handling Procedures',
                'Credit Card Processing',
                'Return and Exchange Policies',
                'Loss Prevention Basics',
                'Upselling Techniques'
            ],
            skillBoosts: {
                'cash_handling': 25,
                'computer_skills': 15,
                'sales': 20,
                'accuracy': 20
            }
        });

        this.trainingPrograms.set('inventory_management', {
            id: 'inventory_management',
            name: 'Inventory Management',
            icon: 'üì¶',
            duration: 8,
            cost: 150,
            description: 'Advanced inventory tracking and organization systems',
            required: true,
            applicableRoles: ['stocker', 'assistant_manager'],
            modules: [
                'Inventory Systems Operation',
                'Product Organization Standards',
                'Receiving and Processing Shipments',
                'Stock Level Management',
                'Product Rotation (FIFO)',
                'Warehouse Safety'
            ],
            skillBoosts: {
                'organization': 30,
                'inventory_management': 35,
                'efficiency': 20,
                'physical_fitness': 10
            }
        });

        this.trainingPrograms.set('security_training', {
            id: 'security_training',
            name: 'Security & Loss Prevention',
            icon: 'üõ°Ô∏è',
            duration: 12,
            cost: 300,
            description: 'Comprehensive security and loss prevention training',
            required: true,
            applicableRoles: ['security', 'assistant_manager'],
            modules: [
                'Theft Detection Techniques',
                'Conflict De-escalation',
                'Emergency Response Procedures',
                'Legal Aspects of Security',
                'Camera System Operation',
                'Incident Report Writing'
            ],
            skillBoosts: {
                'security': 40,
                'conflict_resolution': 35,
                'observation': 30,
                'communication': 15
            }
        });

        this.trainingPrograms.set('leadership_development', {
            id: 'leadership_development',
            name: 'Leadership Development',
            icon: 'üë®‚Äçüíº',
            duration: 16,
            cost: 500,
            description: 'Advanced leadership and management skills',
            required: true,
            applicableRoles: ['assistant_manager'],
            modules: [
                'Team Leadership Principles',
                'Performance Management',
                'Conflict Resolution',
                'Staff Scheduling',
                'Budget Management',
                'Training and Development'
            ],
            skillBoosts: {
                'leadership': 50,
                'management': 45,
                'communication': 25,
                'problem_solving': 30
            }
        });

        this.trainingPrograms.set('customer_service_excellence', {
            id: 'customer_service_excellence',
            name: 'Customer Service Excellence',
            icon: '‚≠ê',
            duration: 6,
            cost: 120,
            description: 'Advanced customer service and satisfaction techniques',
            required: false,
            applicableRoles: ['cashier', 'assistant_manager'],
            modules: [
                'Advanced Communication Skills',
                'Handling Difficult Customers',
                'Upselling and Cross-selling',
                'Customer Retention Strategies',
                'Service Recovery',
                'Building Customer Relationships'
            ],
            skillBoosts: {
                'customer_service': 35,
                'communication': 25,
                'sales': 30,
                'problem_solving': 20
            }
        });

        console.log(`üéì Training programs configured: ${this.trainingPrograms.size} programs`);
    }

    setupEventListeners() {
        // Listen for staff management events
        this.eventBus.on('staff.hired', (data) => this.onStaffHired(data));
        this.eventBus.on('staff.terminated', (data) => this.onStaffTerminated(data));
        this.eventBus.on('schedule.create', (data) => this.createSchedule(data));
        this.eventBus.on('schedule.update', (data) => this.updateSchedule(data));
        this.eventBus.on('performance.review', (data) => this.conductPerformanceReview(data));
        this.eventBus.on('training.assign', (data) => this.assignTraining(data));
        this.eventBus.on('training.complete', (data) => this.completeTraining(data));
        
        // Listen for time-based events
        this.eventBus.on('time.hourly', () => this.processHourlyUpdates());
        this.eventBus.on('time.daily', () => this.processDailyUpdates());
        this.eventBus.on('time.weekly', () => this.processWeeklyUpdates());
        
        // Listen for shift events
        this.eventBus.on('shift.start', (data) => this.startShift(data));
        this.eventBus.on('shift.end', (data) => this.endShift(data));
        this.eventBus.on('shift.break', (data) => this.takeBreak(data));
        
        console.log('üì° Staff management event listeners configured');
    }

    initializeSchedulingSystem() {
        // Initialize staff scheduling data structure
        if (!this.gameState.staffManagement) {
            this.gameState.staffManagement = {
                schedules: [],
                shifts: [],
                performances: [],
                training: [],
                teamDynamics: {
                    morale: 75,
                    productivity: 70,
                    teamwork: 80
                },
                metrics: {
                    averagePerformance: 75,
                    turnoverRate: 5,
                    customerSatisfaction: 80,
                    operational_efficiency: 70
                }
            };
        }
        
        // Generate initial schedules for existing employees
        this.generateInitialSchedules();
        
        console.log('üóìÔ∏è Scheduling system initialized');
    }

    // Scheduling Management
    async createWeeklySchedule(weekStartDate, options = {}) {
        const {
            autoAssign = true,
            considerPreferences = true,
            optimizeForCosts = false,
            minimumStaffing = true
        } = options;
        
        console.log(`üìÖ Creating weekly schedule starting ${new Date(weekStartDate).toDateString()}`);
        
        const schedule = {
            id: this.generateScheduleId(),
            weekStart: weekStartDate,
            weekEnd: weekStartDate + (7 * 24 * 60 * 60 * 1000),
            status: 'draft', // draft, published, active, completed
            shifts: [],
            totalHours: 0,
            totalCost: 0,
            staffingLevel: 0,
            createdDate: Date.now(),
            lastModified: Date.now()
        };
        
        // Get available employees
        const availableEmployees = this.getAvailableEmployees();
        if (availableEmployees.length === 0) {
            console.warn('‚ö†Ô∏è No available employees for scheduling');
            return null;
        }
        
        // Generate shifts for each day of the week
        for (let day = 0; day < 7; day++) {
            const dayDate = weekStartDate + (day * 24 * 60 * 60 * 1000);
            const dayShifts = await this.createDaySchedule(dayDate, availableEmployees, options);
            schedule.shifts.push(...dayShifts);
        }
        
        // Calculate schedule metrics
        this.calculateScheduleMetrics(schedule);
        
        // Auto-assign employees if requested
        if (autoAssign) {
            await this.autoAssignEmployees(schedule, considerPreferences);
        }
        
        // Store schedule
        this.schedules.set(schedule.id, schedule);
        this.gameState.staffManagement.schedules.push(schedule);
        
        // Emit schedule created event
        this.eventBus.emit('schedule.created', {
            schedule: schedule,
            weekStart: weekStartDate
        });
        
        return schedule;
    }

    async createDaySchedule(dayDate, availableEmployees, options) {
        const dayOfWeek = new Date(dayDate).getDay();
        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
        
        const shifts = [];
        let shiftTemplates = [];
        
        // Select appropriate shift templates
        if (isWeekend) {
            shiftTemplates = [this.shiftTemplates.get('weekend')];
        } else {
            // Regular weekday - use multiple overlapping shifts
            shiftTemplates = [
                this.shiftTemplates.get('morning'),
                this.shiftTemplates.get('afternoon'),
                this.shiftTemplates.get('evening')
            ];
            
            // Add night shift if store operates 24/7
            if (this.gameState.store?.operatingHours?.is24Hour) {
                shiftTemplates.push(this.shiftTemplates.get('night'));
            }
        }
        
        // Create shifts based on templates
        shiftTemplates.forEach(template => {
            if (template) {
                const shift = this.createShiftFromTemplate(template, dayDate);
                shifts.push(shift);
            }
        });
        
        return shifts;
    }

    createShiftFromTemplate(template, date) {
        const shift = {
            id: this.generateShiftId(),
            templateId: template.id,
            date: date,
            name: template.name,
            icon: template.icon,
            startTime: template.startTime,
            endTime: template.endTime,
            duration: template.duration,
            breakTimes: [...template.breakTimes],
            positions: { ...template.positions },
            assignedEmployees: [],
            status: 'scheduled', // scheduled, active, completed, cancelled
            priority: template.priority,
            bonusMultiplier: template.nightShiftBonus || template.weekendBonus || 1.0,
            requirements: this.calculateShiftRequirements(template),
            performance: {
                punctuality: 0,
                productivity: 0,
                customerSatisfaction: 0,
                teamwork: 0
            }
        };
        
        return shift;
    }

    calculateShiftRequirements(template) {
        const totalPositions = Object.values(template.positions).reduce((sum, count) => sum + count, 0);
        
        return {
            minEmployees: Math.max(2, Math.floor(totalPositions * 0.6)),
            maxEmployees: totalPositions,
            criticalRoles: Object.entries(template.positions)
                .filter(([role, count]) => count > 0 && ['cashier', 'security'].includes(role))
                .map(([role]) => role),
            preferredSkills: this.getPreferredSkillsForShift(template),
            experienceLevel: template.priority === 'high' ? 'experienced' : 'any'
        };
    }

    getPreferredSkillsForShift(template) {
        const skills = [];
        
        if (template.positions.cashier > 0) {
            skills.push('customer_service', 'cash_handling', 'communication');
        }
        if (template.positions.stocker > 0) {
            skills.push('organization', 'physical_fitness', 'inventory_management');
        }
        if (template.positions.security > 0) {
            skills.push('security', 'conflict_resolution', 'observation');
        }
        if (template.positions.assistant_manager > 0) {
            skills.push('leadership', 'management', 'problem_solving');
        }
        
        return [...new Set(skills)]; // Remove duplicates
    }

    async autoAssignEmployees(schedule, considerPreferences = true) {
        console.log('ü§ñ Auto-assigning employees to shifts...');
        
        const employees = this.getAvailableEmployees();
        let assignmentCount = 0;
        
        // Sort shifts by priority and requirements
        const sortedShifts = schedule.shifts.sort((a, b) => {
            const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
            return (priorityOrder[b.priority] || 0) - (priorityOrder[a.priority] || 0);
        });
        
        for (const shift of sortedShifts) {
            const assignments = await this.assignEmployeesToShift(shift, employees, considerPreferences);
            assignmentCount += assignments.length;
        }
        
        console.log(`‚úÖ Auto-assigned ${assignmentCount} employee shifts`);
        return assignmentCount;
    }

    async assignEmployeesToShift(shift, availableEmployees, considerPreferences = true) {
        const assignments = [];
        const roleNeeds = { ...shift.positions };
        
        // Filter employees based on availability and role compatibility
        const compatibleEmployees = availableEmployees.filter(employee => {
            return this.isEmployeeAvailableForShift(employee, shift) &&
                   this.isEmployeeCompatibleWithShift(employee, shift);
        });
        
        // Score and rank employees for this shift
        const rankedEmployees = this.rankEmployeesForShift(compatibleEmployees, shift, considerPreferences);
        
        // Assign employees to roles
        for (const employee of rankedEmployees) {
            const preferredRole = this.getPreferredRoleForEmployee(employee, roleNeeds);
            
            if (preferredRole && roleNeeds[preferredRole] > 0) {
                const assignment = {
                    employeeId: employee.id,
                    employeeName: employee.name,
                    role: preferredRole,
                    shiftId: shift.id,
                    startTime: shift.startTime,
                    endTime: shift.endTime,
                    status: 'assigned',
                    assignedDate: Date.now()
                };
                
                assignments.push(assignment);
                shift.assignedEmployees.push(assignment);
                roleNeeds[preferredRole]--;
                
                // Mark employee as scheduled for this time slot
                this.markEmployeeScheduled(employee.id, shift);
            }
            
            // Stop if all positions are filled
            if (Object.values(roleNeeds).every(count => count <= 0)) {
                break;
            }
        }
        
        return assignments;
    }

    isEmployeeAvailableForShift(employee, shift) {
        // Check if employee is not already scheduled for conflicting time
        const shiftStart = this.parseTime(shift.startTime);
        const shiftEnd = this.parseTime(shift.endTime);
        
        // Check availability preferences
        if (employee.personalInfo?.availability) {
            const shiftPeriod = this.getShiftPeriod(shift.startTime);
            if (!employee.personalInfo.availability.includes(shiftPeriod)) {
                return false;
            }
        }
        
        // Check maximum hours constraints
        const weeklyHours = this.calculateEmployeeWeeklyHours(employee.id, shift.date);
        if (weeklyHours + shift.duration > this.managementConfig.maxHoursPerWeek) {
            return false;
        }
        
        // Check if employee is active and not on leave
        return employee.status === 'active' || employee.status === 'probation';
    }

    isEmployeeCompatibleWithShift(employee, shift) {
        const employeeRole = employee.role.id;
        const shiftRoles = Object.keys(shift.positions).filter(role => shift.positions[role] > 0);
        
        // Check if employee's role is needed in this shift
        if (!shiftRoles.includes(employeeRole)) {
            // Allow assistant managers to fill any role
            return employeeRole === 'assistant_manager';
        }
        
        return true;
    }

    rankEmployeesForShift(employees, shift, considerPreferences) {
        return employees.map(employee => {
            let score = 0;
            
            // Base performance score (0-100)
            score += employee.performance?.overallRating || 50;
            
            // Role match bonus
            if (shift.positions[employee.role.id] > 0) {
                score += 20;
            }
            
            // Experience level bonus
            if (shift.requirements.experienceLevel === 'experienced') {
                score += employee.employment?.experience?.length * 5 || 0;
            }
            
            // Skill match bonus
            if (employee.employment?.skills) {
                const matchingSkills = shift.requirements.preferredSkills.filter(skill => 
                    employee.employment.skills[skill] && employee.employment.skills[skill] > 50
                );
                score += matchingSkills.length * 10;
            }
            
            // Availability preference bonus
            if (considerPreferences && employee.personalInfo?.availability) {
                const shiftPeriod = this.getShiftPeriod(shift.startTime);
                if (employee.personalInfo.availability.includes(shiftPeriod)) {
                    score += 15;
                }
            }
            
            // Reliability bonus
            score += (employee.performance?.reliability || 50) * 0.3;
            
            // Random factor for variety
            score += Math.random() * 10;
            
            return { employee, score };
        }).sort((a, b) => b.score - a.score).map(item => item.employee);
    }

    getPreferredRoleForEmployee(employee, roleNeeds) {
        const employeeRole = employee.role.id;
        
        // Prefer employee's primary role if available
        if (roleNeeds[employeeRole] > 0) {
            return employeeRole;
        }
        
        // Assistant managers can fill any role
        if (employeeRole === 'assistant_manager') {
            const availableRoles = Object.entries(roleNeeds)
                .filter(([role, count]) => count > 0)
                .map(([role]) => role);
            
            if (availableRoles.length > 0) {
                // Prefer higher-responsibility roles first
                const priorityOrder = ['assistant_manager', 'cashier', 'security', 'stocker', 'janitor'];
                for (const role of priorityOrder) {
                    if (availableRoles.includes(role)) {
                        return role;
                    }
                }
            }
        }
        
        return null;
    }

    // Performance Management
    async conductPerformanceReview(reviewData) {
        const { employeeId, reviewerId, period, metrics } = reviewData;
        const employee = this.getEmployeeById(employeeId);
        
        if (!employee) {
            console.error('‚ùå Employee not found for performance review:', employeeId);
            return null;
        }
        
        console.log(`üìä Conducting performance review for ${employee.name}`);
        
        const review = {
            id: this.generateReviewId(),
            employeeId: employeeId,
            reviewerId: reviewerId,
            period: period,
            conductedDate: Date.now(),
            metrics: {
                productivity: this.calculateProductivityScore(employee),
                reliability: this.calculateReliabilityScore(employee),
                customerSatisfaction: this.calculateCustomerSatisfactionScore(employee),
                teamwork: this.calculateTeamworkScore(employee),
                punctuality: this.calculatePunctualityScore(employee),
                qualityOfWork: this.calculateQualityScore(employee),
                initiative: this.calculateInitiativeScore(employee)
            },
            strengths: [],
            areasForImprovement: [],
            goals: [],
            rating: 'satisfactory', // outstanding, exceeds, satisfactory, needs_improvement, unsatisfactory
            recommendations: [],
            nextReviewDate: Date.now() + (90 * 24 * 60 * 60 * 1000), // 90 days
            salaryRecommendation: null,
            promotionRecommendation: null
        };
        
        // Calculate overall performance rating
        this.calculateOverallRating(review);
        
        // Generate AI-powered feedback and recommendations
        await this.generatePerformanceFeedback(review, employee);
        
        // Store performance review
        this.performanceReviews.set(review.id, review);
        
        // Update employee performance history
        if (!employee.performanceHistory) {
            employee.performanceHistory = [];
        }
        employee.performanceHistory.push(review);
        
        // Update current performance metrics
        this.updateEmployeePerformance(employee, review.metrics);
        
        // Emit performance review event
        this.eventBus.emit('performance.reviewCompleted', {
            review: review,
            employee: employee
        });
        
        return review;
    }

    calculateProductivityScore(employee) {
        // Base score from role-specific metrics
        let score = 50;
        
        // Add role-specific productivity calculations
        switch (employee.role.id) {
            case 'cashier':
                score += this.calculateCashierProductivity(employee);
                break;
            case 'stocker':
                score += this.calculateStockerProductivity(employee);
                break;
            case 'security':
                score += this.calculateSecurityProductivity(employee);
                break;
            case 'janitor':
                score += this.calculateJanitorProductivity(employee);
                break;
            case 'assistant_manager':
                score += this.calculateManagerProductivity(employee);
                break;
        }
        
        return Math.max(0, Math.min(100, score));
    }

    calculateCashierProductivity(employee) {
        // Simulate cashier-specific metrics
        const baseScore = employee.performance?.productivity || 50;
        const transactionSpeed = Math.random() * 40 + 60; // 60-100
        const accuracy = Math.random() * 20 + 80; // 80-100
        const upsellSuccess = Math.random() * 30 + 10; // 10-40
        
        return (baseScore + transactionSpeed + accuracy + upsellSuccess) / 4 - 50;
    }

    calculateStockerProductivity(employee) {
        const baseScore = employee.performance?.productivity || 50;
        const stockingSpeed = Math.random() * 30 + 70; // 70-100
        const organization = Math.random() * 25 + 75; // 75-100
        const accuracy = Math.random() * 20 + 80; // 80-100
        
        return (baseScore + stockingSpeed + organization + accuracy) / 4 - 50;
    }

    calculateSecurityProductivity(employee) {
        const baseScore = employee.performance?.productivity || 50;
        const vigilance = Math.random() * 30 + 70; // 70-100
        const incidentResponse = Math.random() * 25 + 75; // 75-100
        const preventionEffectiveness = Math.random() * 35 + 65; // 65-100
        
        return (baseScore + vigilance + incidentResponse + preventionEffectiveness) / 4 - 50;
    }

    // Training Management
    async assignTraining(trainingData) {
        const { employeeId, programId, priority = 'normal', deadline = null } = trainingData;
        const employee = this.getEmployeeById(employeeId);
        const program = this.trainingPrograms.get(programId);
        
        if (!employee || !program) {
            console.error('‚ùå Invalid employee or training program');
            return null;
        }
        
        console.log(`üìö Assigning training "${program.name}" to ${employee.name}`);
        
        const training = {
            id: this.generateTrainingId(),
            employeeId: employeeId,
            programId: programId,
            assignedDate: Date.now(),
            deadline: deadline || Date.now() + (7 * 24 * 60 * 60 * 1000), // 1 week default
            status: 'assigned', // assigned, in_progress, completed, failed, cancelled
            priority: priority,
            progress: 0,
            startDate: null,
            completionDate: null,
            score: null,
            cost: program.cost,
            notes: []
        };
        
        // Add to employee's training record
        if (!employee.training) {
            employee.training = {
                completed: [],
                inProgress: [],
                assigned: []
            };
        }
        employee.training.assigned.push(training);
        
        // Store training record
        this.gameState.staffManagement.training.push(training);
        
        // Emit training assigned event
        this.eventBus.emit('training.assigned', {
            training: training,
            employee: employee,
            program: program
        });
        
        return training;
    }

    async startTraining(trainingId) {
        const training = this.getTrainingById(trainingId);
        if (!training || training.status !== 'assigned') {
            console.error('‚ùå Cannot start training:', trainingId);
            return false;
        }
        
        const employee = this.getEmployeeById(training.employeeId);
        const program = this.trainingPrograms.get(training.programId);
        
        console.log(`üéì Starting training "${program.name}" for ${employee.name}`);
        
        training.status = 'in_progress';
        training.startDate = Date.now();
        
        // Move from assigned to in_progress
        employee.training.assigned = employee.training.assigned.filter(t => t.id !== trainingId);
        employee.training.inProgress.push(training);
        
        // Simulate training progress over time
        this.simulateTrainingProgress(training, program);
        
        return true;
    }

    async completeTraining(trainingData) {
        const { trainingId, score = null, notes = '' } = trainingData;
        const training = this.getTrainingById(trainingId);
        
        if (!training || training.status !== 'in_progress') {
            console.error('‚ùå Cannot complete training:', trainingId);
            return false;
        }
        
        const employee = this.getEmployeeById(training.employeeId);
        const program = this.trainingPrograms.get(training.programId);
        
        console.log(`‚úÖ Completing training "${program.name}" for ${employee.name}`);
        
        training.status = 'completed';
        training.completionDate = Date.now();
        training.progress = 100;
        training.score = score || this.calculateTrainingScore(employee, program);
        training.notes.push(notes);
        
        // Apply skill boosts from training
        this.applyTrainingBenefits(employee, program, training.score);
        
        // Move from in_progress to completed
        employee.training.inProgress = employee.training.inProgress.filter(t => t.id !== trainingId);
        employee.training.completed.push(training);
        
        // Emit training completed event
        this.eventBus.emit('training.completed', {
            training: training,
            employee: employee,
            program: program
        });
        
        return true;
    }

    applyTrainingBenefits(employee, program, score) {
        console.log(`üöÄ Applying training benefits for ${employee.name} (Score: ${score}%)`);
        
        // Calculate effectiveness based on score
        const effectiveness = Math.max(0.5, score / 100); // Minimum 50% effectiveness
        
        // Apply skill boosts
        if (program.skillBoosts && employee.employment?.skills) {
            Object.entries(program.skillBoosts).forEach(([skill, boost]) => {
                const currentLevel = employee.employment.skills[skill] || 0;
                const improvedLevel = Math.min(100, currentLevel + (boost * effectiveness));
                employee.employment.skills[skill] = Math.round(improvedLevel);
                
                console.log(`üìà ${skill}: ${currentLevel} ‚Üí ${improvedLevel}`);
            });
        }
        
        // Improve overall performance
        const performanceBoost = Math.round(5 * effectiveness);
        employee.performance.overallRating = Math.min(100, 
            employee.performance.overallRating + performanceBoost
        );
        
        // Add training certification
        if (!employee.certifications) {
            employee.certifications = [];
        }
        employee.certifications.push({
            programId: program.id,
            name: program.name,
            completedDate: Date.now(),
            score: score,
            validUntil: program.renewalRequired ? Date.now() + (365 * 24 * 60 * 60 * 1000) : null
        });
    }

    // Team Dynamics & Morale
    calculateTeamMorale() {
        const employees = this.gameState.staff?.employees || [];
        if (employees.length === 0) return 75; // Default
        
        let totalMorale = 0;
        let moraleFactors = {
            performance: 0,
            workload: 0,
            relationships: 0,
            recognition: 0,
            growth: 0
        };
        
        employees.forEach(employee => {
            // Performance satisfaction
            const performance = employee.performance?.overallRating || 50;
            moraleFactors.performance += performance > 75 ? 10 : performance < 50 ? -10 : 0;
            
            // Workload balance
            const weeklyHours = this.calculateEmployeeWeeklyHours(employee.id);
            moraleFactors.workload += weeklyHours > 35 ? -5 : weeklyHours < 20 ? -3 : 5;
            
            // Training and growth opportunities
            const recentTraining = employee.training?.completed?.filter(t => 
                Date.now() - t.completionDate < 30 * 24 * 60 * 60 * 1000
            ).length || 0;
            moraleFactors.growth += recentTraining * 5;
            
            // Individual morale calculation
            const individualMorale = 50 + 
                (performance - 50) * 0.3 +
                Math.random() * 20 - 10; // Random variation
            
            totalMorale += Math.max(0, Math.min(100, individualMorale));
        });
        
        const averageMorale = totalMorale / employees.length;
        
        // Update team morale in game state
        this.gameState.staffManagement.teamDynamics.morale = Math.round(averageMorale);
        
        return averageMorale;
    }

    // Utility Methods
    generateScheduleId() {
        return 'schedule_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    generateShiftId() {
        return 'shift_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    generateReviewId() {
        return 'review_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    generateTrainingId() {
        return 'training_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    getEmployeeById(employeeId) {
        return this.gameState.staff?.employees?.find(emp => emp.id === employeeId);
    }

    getAvailableEmployees() {
        return this.gameState.staff?.employees?.filter(emp => 
            emp.status === 'active' || emp.status === 'probation'
        ) || [];
    }

    parseTime(timeString) {
        const [hours, minutes] = timeString.split(':').map(Number);
        return hours * 60 + minutes; // Convert to minutes
    }

    getShiftPeriod(startTime) {
        const hour = parseInt(startTime.split(':')[0]);
        if (hour >= 6 && hour < 12) return 'morning';
        if (hour >= 12 && hour < 17) return 'afternoon';
        if (hour >= 17 && hour < 22) return 'evening';
        return 'night';
    }

    calculateEmployeeWeeklyHours(employeeId, weekStart = null) {
        // Calculate total scheduled hours for an employee in a given week
        const schedules = this.gameState.staffManagement?.schedules || [];
        const currentWeek = weekStart || this.getCurrentWeekStart();
        
        let totalHours = 0;
        schedules.forEach(schedule => {
            if (schedule.weekStart === currentWeek) {
                schedule.shifts.forEach(shift => {
                    const assignment = shift.assignedEmployees?.find(a => a.employeeId === employeeId);
                    if (assignment) {
                        totalHours += shift.duration;
                    }
                });
            }
        });
        
        return totalHours;
    }

    getCurrentWeekStart() {
        const now = new Date();
        const dayOfWeek = now.getDay();
        const weekStart = new Date(now);
        weekStart.setDate(now.getDate() - dayOfWeek);
        weekStart.setHours(0, 0, 0, 0);
        return weekStart.getTime();
    }

    // Public API Methods
    getShiftTemplates() {
        return Array.from(this.shiftTemplates.values());
    }

    getTrainingPrograms() {
        return Array.from(this.trainingPrograms.values());
    }

    getSchedules() {
        return this.gameState.staffManagement?.schedules || [];
    }

    getActiveShifts() {
        const now = Date.now();
        return this.gameState.staffManagement?.shifts?.filter(shift => 
            shift.status === 'active' && 
            shift.date <= now && 
            shift.date + (shift.duration * 60 * 60 * 1000) > now
        ) || [];
    }

    getEmployeePerformance(employeeId) {
        const employee = this.getEmployeeById(employeeId);
        return employee?.performance || null;
    }

    getTeamMetrics() {
        return {
            morale: this.calculateTeamMorale(),
            productivity: this.gameState.staffManagement?.teamDynamics?.productivity || 70,
            turnover: this.gameState.staffManagement?.metrics?.turnoverRate || 5,
            satisfaction: this.gameState.staffManagement?.metrics?.customerSatisfaction || 80
        };
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = StaffManagementSystem;
} else if (typeof window !== 'undefined') {
    window.StaffManagementSystem = StaffManagementSystem;
}


/* === src/scripts/interfaces/staffManagementInterface.js === */
/**
 * Staff Management Interface - Phase 5B UI Implementation
 * Advanced staff scheduling, performance management, and team coordination interface
 * Builds upon Phase 5A hiring interface with comprehensive management tools
 */

class StaffManagementInterface {
    constructor() {
        this.managementSystem = null;
        this.hiringSystem = null;
        this.gameState = null;
        this.eventBus = null;
        
        // UI state
        this.currentView = 'dashboard'; // dashboard, scheduling, performance, training, teams
        this.selectedEmployee = null;
        this.selectedWeek = null;
        this.selectedShift = null;
        this.calendarMode = 'week'; // week, month
        
        // Filters and settings
        this.filters = {
            role: 'all',
            status: 'all',
            performance: 'all',
            department: 'all'
        };
        
        this.viewPreferences = {
            showInactiveEmployees: false,
            autoRefresh: true,
            notificationsEnabled: true,
            compactView: false
        };
    }

    initialize(managementSystem, hiringSystem, gameState, eventBus) {
        this.managementSystem = managementSystem;
        this.hiringSystem = hiringSystem;
        this.gameState = gameState;
        this.eventBus = eventBus;
        
        this.setupEventListeners();
        this.initializeCalendar();
        
        console.log('üìä Staff Management Interface initialized');
    }

    setupEventListeners() {
        // Listen for management events to update UI
        this.eventBus.on('schedule.created', () => this.refreshSchedulingView());
        this.eventBus.on('performance.reviewCompleted', () => this.refreshPerformanceView());
        this.eventBus.on('training.completed', () => this.refreshTrainingView());
        this.eventBus.on('staff.hired', () => this.refreshDashboard());
        this.eventBus.on('shift.start', () => this.refreshActiveShifts());
        this.eventBus.on('shift.end', () => this.refreshActiveShifts());
    }

    initializeCalendar() {
        // Set initial week to current week
        this.selectedWeek = this.managementSystem.getCurrentWeekStart();
    }

    render() {
        return `
            <div class="staff-management-app">
                ${this.renderHeader()}
                ${this.renderNavigation()}
                ${this.renderMainContent()}
                ${this.renderQuickActions()}
                ${this.renderModal()}
            </div>
        `;
    }

    renderHeader() {
        const teamMetrics = this.managementSystem.getTeamMetrics();
        const employees = this.managementSystem.getAvailableEmployees();
        const activeShifts = this.managementSystem.getActiveShifts();
        
        return `
            <div class="management-header">
                <div class="header-title">
                    <h2>üìä Staff Management Center</h2>
                    <p>Comprehensive workforce management and scheduling</p>
                </div>
                
                <div class="team-metrics">
                    <div class="metric-card ${this.getMoraleClass(teamMetrics.morale)}">
                        <div class="metric-icon">üòä</div>
                        <div class="metric-info">
                            <span class="metric-value">${teamMetrics.morale}%</span>
                            <span class="metric-label">Team Morale</span>
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <div class="metric-icon">‚ö°</div>
                        <div class="metric-info">
                            <span class="metric-value">${teamMetrics.productivity}%</span>
                            <span class="metric-label">Productivity</span>
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <div class="metric-icon">üë•</div>
                        <div class="metric-info">
                            <span class="metric-value">${employees.length}</span>
                            <span class="metric-label">Active Staff</span>
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <div class="metric-icon">üîÑ</div>
                        <div class="metric-info">
                            <span class="metric-value">${activeShifts.length}</span>
                            <span class="metric-label">Active Shifts</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    renderNavigation() {
        const tabs = [
            { id: 'dashboard', label: 'Dashboard', icon: 'üìä' },
            { id: 'scheduling', label: 'Scheduling', icon: 'üìÖ' },
            { id: 'performance', label: 'Performance', icon: '‚≠ê' },
            { id: 'training', label: 'Training', icon: 'üéì' },
            { id: 'teams', label: 'Team Dynamics', icon: 'üë•' }
        ];
        
        return `
            <div class="management-navigation">
                ${tabs.map(tab => `
                    <button 
                        class="nav-tab ${this.currentView === tab.id ? 'active' : ''}"
                        onclick="staffManagementInterface.switchView('${tab.id}')"
                    >
                        <span class="tab-icon">${tab.icon}</span>
                        <span class="tab-label">${tab.label}</span>
                    </button>
                `).join('')}
            </div>
        `;
    }

    renderMainContent() {
        switch (this.currentView) {
            case 'dashboard':
                return this.renderDashboard();
            case 'scheduling':
                return this.renderScheduling();
            case 'performance':
                return this.renderPerformance();
            case 'training':
                return this.renderTraining();
            case 'teams':
                return this.renderTeamDynamics();
            default:
                return this.renderDashboard();
        }
    }

    renderDashboard() {
        const employees = this.managementSystem.getAvailableEmployees();
        const recentReviews = this.getRecentPerformanceReviews();
        const upcomingTraining = this.getUpcomingTraining();
        const todayShifts = this.getTodayShifts();
        
        return `
            <div class="management-dashboard">
                <div class="dashboard-section">
                    <h3>üéØ Today's Overview</h3>
                    <div class="today-overview">
                        <div class="overview-card">
                            <h4>üìÖ Today's Shifts</h4>
                            <div class="shift-list">
                                ${todayShifts.length > 0 ? 
                                    todayShifts.map(shift => this.renderTodayShift(shift)).join('') :
                                    '<p class="no-data">No shifts scheduled for today</p>'
                                }
                            </div>
                        </div>
                        
                        <div class="overview-card">
                            <h4>‚è∞ Quick Actions</h4>
                            <div class="quick-actions-grid">
                                <button class="action-card" onclick="staffManagementInterface.createWeeklySchedule()">
                                    <span class="action-icon">üìÖ</span>
                                    <span class="action-text">Create Schedule</span>
                                </button>
                                <button class="action-card" onclick="staffManagementInterface.conductPerformanceReviews()">
                                    <span class="action-icon">‚≠ê</span>
                                    <span class="action-text">Performance Reviews</span>
                                </button>
                                <button class="action-card" onclick="staffManagementInterface.assignTraining()">
                                    <span class="action-icon">üéì</span>
                                    <span class="action-text">Assign Training</span>
                                </button>
                                <button class="action-card" onclick="staffManagementInterface.viewTeamStats()">
                                    <span class="action-icon">üìä</span>
                                    <span class="action-text">Team Analytics</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="dashboard-section">
                    <h3>üë• Staff Overview</h3>
                    <div class="staff-overview">
                        ${employees.length > 0 ? 
                            employees.slice(0, 6).map(emp => this.renderEmployeeSummaryCard(emp)).join('') :
                            '<div class="no-employees">No active employees. <a href="#" onclick="hiringInterface.switchView(\'overview\')">Hire staff</a></div>'
                        }
                    </div>
                </div>
                
                <div class="dashboard-section">
                    <h3>üìã Recent Activity</h3>
                    <div class="activity-feed">
                        ${this.renderActivityFeed()}
                    </div>
                </div>
                
                <div class="dashboard-section">
                    <h3>‚ö†Ô∏è Attention Required</h3>
                    <div class="alerts-panel">
                        ${this.renderManagementAlerts()}
                    </div>
                </div>
            </div>
        `;
    }

    renderScheduling() {
        const schedules = this.managementSystem.getSchedules();
        const shiftTemplates = this.managementSystem.getShiftTemplates();
        
        return `
            <div class="scheduling-view">
                <div class="scheduling-header">
                    <h3>üìÖ Staff Scheduling</h3>
                    <div class="scheduling-controls">
                        <button class="btn primary" onclick="staffManagementInterface.showCreateScheduleModal()">
                            + Create Weekly Schedule
                        </button>
                        <select onchange="staffManagementInterface.changeWeek(this.value)">
                            ${this.renderWeekOptions()}
                        </select>
                        <button class="btn-small" onclick="staffManagementInterface.toggleCalendarMode()">
                            ${this.calendarMode === 'week' ? 'üìÖ Month View' : 'üìÖ Week View'}
                        </button>
                    </div>
                </div>
                
                <div class="scheduling-content">
                    <div class="schedule-calendar">
                        ${this.renderScheduleCalendar()}
                    </div>
                    
                    <div class="scheduling-sidebar">
                        <div class="sidebar-section">
                            <h4>üéØ Shift Templates</h4>
                            <div class="template-list">
                                ${shiftTemplates.map(template => this.renderShiftTemplate(template)).join('')}
                            </div>
                        </div>
                        
                        <div class="sidebar-section">
                            <h4>üë• Available Staff</h4>
                            <div class="available-staff">
                                ${this.renderAvailableStaff()}
                            </div>
                        </div>
                        
                        <div class="sidebar-section">
                            <h4>üìä Schedule Metrics</h4>
                            <div class="schedule-metrics">
                                ${this.renderScheduleMetrics()}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    renderScheduleCalendar() {
        if (this.calendarMode === 'week') {
            return this.renderWeeklyCalendar();
        } else {
            return this.renderMonthlyCalendar();
        }
    }

    renderWeeklyCalendar() {
        const weekStart = new Date(this.selectedWeek);
        const days = [];
        
        // Generate 7 days starting from selected week
        for (let i = 0; i < 7; i++) {
            const day = new Date(weekStart);
            day.setDate(weekStart.getDate() + i);
            days.push(day);
        }
        
        return `
            <div class="weekly-calendar">
                <div class="calendar-header">
                    ${days.map(day => `
                        <div class="day-header">
                            <div class="day-name">${day.toLocaleDateString([], { weekday: 'short' })}</div>
                            <div class="day-date">${day.getDate()}</div>
                        </div>
                    `).join('')}
                </div>
                
                <div class="calendar-body">
                    ${days.map(day => `
                        <div class="day-column" data-date="${day.getTime()}">
                            ${this.renderDayShifts(day)}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    renderDayShifts(date) {
        const dayShifts = this.getShiftsForDate(date);
        
        if (dayShifts.length === 0) {
            return `
                <div class="empty-day" onclick="staffManagementInterface.addShift('${date.getTime()}')">
                    <span class="add-shift-icon">+</span>
                    <span class="add-shift-text">Add Shift</span>
                </div>
            `;
        }
        
        return dayShifts.map(shift => `
            <div class="shift-block ${shift.status}" onclick="staffManagementInterface.editShift('${shift.id}')">
                <div class="shift-header">
                    <span class="shift-icon">${shift.icon}</span>
                    <span class="shift-name">${shift.name}</span>
                </div>
                <div class="shift-time">${shift.startTime} - ${shift.endTime}</div>
                <div class="shift-staff">
                    ${shift.assignedEmployees.length}/${Object.values(shift.positions).reduce((a, b) => a + b, 0)} staff
                </div>
                <div class="shift-status">${this.formatShiftStatus(shift.status)}</div>
            </div>
        `).join('');
    }

    renderPerformance() {
        const employees = this.managementSystem.getAvailableEmployees();
        const recentReviews = this.getRecentPerformanceReviews();
        
        return `
            <div class="performance-view">
                <div class="performance-header">
                    <h3>‚≠ê Performance Management</h3>
                    <div class="performance-controls">
                        <button class="btn primary" onclick="staffManagementInterface.showPerformanceReviewModal()">
                            + Conduct Review
                        </button>
                        <select onchange="staffManagementInterface.filterPerformance(this.value)">
                            <option value="all">All Employees</option>
                            <option value="outstanding">Outstanding</option>
                            <option value="exceeds">Exceeds Expectations</option>
                            <option value="satisfactory">Satisfactory</option>
                            <option value="needs_improvement">Needs Improvement</option>
                        </select>
                    </div>
                </div>
                
                <div class="performance-dashboard">
                    <div class="performance-metrics">
                        <div class="metric-summary">
                            <h4>üìä Team Performance Overview</h4>
                            ${this.renderTeamPerformanceChart()}
                        </div>
                        
                        <div class="performance-alerts">
                            <h4>‚ö†Ô∏è Performance Alerts</h4>
                            ${this.renderPerformanceAlerts()}
                        </div>
                    </div>
                    
                    <div class="employee-performance-list">
                        <h4>üë• Individual Performance</h4>
                        <div class="performance-grid">
                            ${employees.map(emp => this.renderEmployeePerformanceCard(emp)).join('')}
                        </div>
                    </div>
                    
                    <div class="recent-reviews">
                        <h4>üìã Recent Reviews</h4>
                        <div class="reviews-list">
                            ${recentReviews.length > 0 ? 
                                recentReviews.map(review => this.renderReviewSummary(review)).join('') :
                                '<p class="no-data">No recent performance reviews</p>'
                            }
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    renderTraining() {
        const trainingPrograms = this.managementSystem.getTrainingPrograms();
        const activeTraining = this.getActiveTraining();
        const employees = this.managementSystem.getAvailableEmployees();
        
        return `
            <div class="training-view">
                <div class="training-header">
                    <h3>üéì Training & Development</h3>
                    <div class="training-controls">
                        <button class="btn primary" onclick="staffManagementInterface.showAssignTrainingModal()">
                            + Assign Training
                        </button>
                        <button class="btn" onclick="staffManagementInterface.showTrainingReportsModal()">
                            üìä Training Reports
                        </button>
                    </div>
                </div>
                
                <div class="training-dashboard">
                    <div class="training-programs">
                        <h4>üìö Available Programs</h4>
                        <div class="programs-grid">
                            ${trainingPrograms.map(program => this.renderTrainingProgram(program)).join('')}
                        </div>
                    </div>
                    
                    <div class="active-training">
                        <h4>üéØ Active Training</h4>
                        <div class="training-list">
                            ${activeTraining.length > 0 ? 
                                activeTraining.map(training => this.renderActiveTraining(training)).join('') :
                                '<p class="no-data">No active training sessions</p>'
                            }
                        </div>
                    </div>
                    
                    <div class="training-progress">
                        <h4>üìà Progress Tracking</h4>
                        <div class="progress-grid">
                            ${employees.map(emp => this.renderEmployeeTrainingProgress(emp)).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    renderTeamDynamics() {
        const teamMetrics = this.managementSystem.getTeamMetrics();
        const employees = this.managementSystem.getAvailableEmployees();
        
        return `
            <div class="team-dynamics-view">
                <div class="dynamics-header">
                    <h3>üë• Team Dynamics</h3>
                    <p>Monitor team relationships, morale, and collaboration</p>
                </div>
                
                <div class="dynamics-dashboard">
                    <div class="team-health">
                        <h4>üíö Team Health Indicators</h4>
                        <div class="health-metrics">
                            <div class="health-card">
                                <div class="health-icon">üòä</div>
                                <div class="health-info">
                                    <span class="health-value">${teamMetrics.morale}%</span>
                                    <span class="health-label">Morale</span>
                                    <div class="health-bar">
                                        <div class="health-fill" style="width: ${teamMetrics.morale}%"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="health-card">
                                <div class="health-icon">‚ö°</div>
                                <div class="health-info">
                                    <span class="health-value">${teamMetrics.productivity}%</span>
                                    <span class="health-label">Productivity</span>
                                    <div class="health-bar">
                                        <div class="health-fill" style="width: ${teamMetrics.productivity}%"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="health-card">
                                <div class="health-icon">ü§ù</div>
                                <div class="health-info">
                                    <span class="health-value">85%</span>
                                    <span class="health-label">Collaboration</span>
                                    <div class="health-bar">
                                        <div class="health-fill" style="width: 85%"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="health-card">
                                <div class="health-icon">‚≠ê</div>
                                <div class="health-info">
                                    <span class="health-value">${teamMetrics.satisfaction}%</span>
                                    <span class="health-label">Satisfaction</span>
                                    <div class="health-bar">
                                        <div class="health-fill" style="width: ${teamMetrics.satisfaction}%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="team-structure">
                        <h4>üèóÔ∏è Team Structure</h4>
                        <div class="structure-chart">
                            ${this.renderTeamStructureChart(employees)}
                        </div>
                    </div>
                    
                    <div class="team-insights">
                        <h4>üí° Team Insights</h4>
                        <div class="insights-panel">
                            ${this.renderTeamInsights(teamMetrics, employees)}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    renderEmployeeSummaryCard(employee) {
        const performance = employee.performance?.overallRating || 50;
        const status = employee.status;
        
        return `
            <div class="employee-summary-card" onclick="staffManagementInterface.viewEmployeeDetails('${employee.id}')">
                <div class="employee-header">
                    <div class="employee-info">
                        <h4>${employee.name}</h4>
                        <p>${employee.role.icon} ${employee.role.title}</p>
                    </div>
                    <div class="employee-status">
                        <span class="status-badge ${status}">${this.formatStatus(status)}</span>
                    </div>
                </div>
                
                <div class="employee-metrics">
                    <div class="metric-item">
                        <span class="metric-label">Performance</span>
                        <div class="metric-bar">
                            <div class="metric-fill ${this.getPerformanceClass(performance)}" 
                                 style="width: ${performance}%"></div>
                        </div>
                        <span class="metric-value">${performance}%</span>
                    </div>
                </div>
                
                <div class="employee-quick-actions">
                    <button class="btn-small" onclick="staffManagementInterface.scheduleEmployee('${employee.id}'); event.stopPropagation();">
                        üìÖ Schedule
                    </button>
                    <button class="btn-small" onclick="staffManagementInterface.reviewEmployee('${employee.id}'); event.stopPropagation();">
                        ‚≠ê Review
                    </button>
                </div>
            </div>
        `;
    }

    renderShiftTemplate(template) {
        const totalPositions = Object.values(template.positions).reduce((sum, count) => sum + count, 0);
        
        return `
            <div class="shift-template" onclick="staffManagementInterface.useTemplate('${template.id}')">
                <div class="template-header">
                    <span class="template-icon">${template.icon}</span>
                    <span class="template-name">${template.name}</span>
                </div>
                <div class="template-details">
                    <span class="template-time">${template.startTime} - ${template.endTime}</span>
                    <span class="template-staff">${totalPositions} positions</span>
                    <span class="template-priority priority-${template.priority}">${template.priority}</span>
                </div>
            </div>
        `;
    }

    renderModal() {
        return `
            <div id="staffManagementModal" class="modal-overlay" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 id="modalTitle">Modal Title</h3>
                        <button class="modal-close" onclick="staffManagementInterface.closeModal()">√ó</button>
                    </div>
                    <div class="modal-body" id="modalBody">
                        <!-- Dynamic content -->
                    </div>
                </div>
            </div>
        `;
    }

    // UI State Management
    switchView(view) {
        this.currentView = view;
        this.refreshUI();
    }

    refreshUI() {
        const mainContent = document.querySelector('.staff-management-app .management-main');
        if (mainContent) {
            mainContent.innerHTML = this.renderMainContent();
        }
    }

    refreshDashboard() {
        if (this.currentView === 'dashboard') {
            this.refreshUI();
        }
    }

    refreshSchedulingView() {
        if (this.currentView === 'scheduling') {
            this.refreshUI();
        }
    }

    refreshPerformanceView() {
        if (this.currentView === 'performance') {
            this.refreshUI();
        }
    }

    refreshTrainingView() {
        if (this.currentView === 'training') {
            this.refreshUI();
        }
    }

    refreshActiveShifts() {
        // Update any active shift displays
        const activeShiftElements = document.querySelectorAll('.active-shift');
        activeShiftElements.forEach(element => {
            // Update shift status or information
        });
    }

    // Modal Management
    showModal(title, content) {
        document.getElementById('modalTitle').textContent = title;
        document.getElementById('modalBody').innerHTML = content;
        document.getElementById('staffManagementModal').style.display = 'flex';
    }

    closeModal() {
        document.getElementById('staffManagementModal').style.display = 'none';
    }

    // Action Handlers
    async createWeeklySchedule() {
        const weekStart = this.selectedWeek || this.managementSystem.getCurrentWeekStart();
        
        try {
            const schedule = await this.managementSystem.createWeeklySchedule(weekStart, {
                autoAssign: true,
                considerPreferences: true,
                optimizeForCosts: true
            });
            
            if (schedule) {
                this.refreshSchedulingView();
                console.log('‚úÖ Weekly schedule created successfully');
            }
        } catch (error) {
            console.error('‚ùå Error creating schedule:', error);
            alert('Failed to create schedule. Please try again.');
        }
    }

    async conductPerformanceReviews() {
        this.switchView('performance');
        // Could auto-select employees due for review
    }

    async assignTraining() {
        this.switchView('training');
        // Could show quick training assignment interface
    }

    viewTeamStats() {
        this.switchView('teams');
    }

    // Utility Methods
    formatStatus(status) {
        const statusMap = {
            'active': 'Active',
            'probation': 'Probation',
            'inactive': 'Inactive',
            'terminated': 'Terminated'
        };
        return statusMap[status] || status;
    }

    formatShiftStatus(status) {
        const statusMap = {
            'scheduled': 'Scheduled',
            'active': 'In Progress',
            'completed': 'Completed',
            'cancelled': 'Cancelled'
        };
        return statusMap[status] || status;
    }

    getMoraleClass(morale) {
        if (morale >= 80) return 'excellent';
        if (morale >= 60) return 'good';
        if (morale >= 40) return 'average';
        return 'poor';
    }

    getPerformanceClass(performance) {
        if (performance >= 80) return 'excellent';
        if (performance >= 70) return 'good';
        if (performance >= 60) return 'average';
        if (performance >= 50) return 'below-average';
        return 'poor';
    }

    // Data Helper Methods
    getTodayShifts() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        return this.getShiftsForDate(today);
    }

    getShiftsForDate(date) {
        const schedules = this.managementSystem.getSchedules();
        const shifts = [];
        
        schedules.forEach(schedule => {
            schedule.shifts.forEach(shift => {
                const shiftDate = new Date(shift.date);
                shiftDate.setHours(0, 0, 0, 0);
                
                if (shiftDate.getTime() === date.getTime()) {
                    shifts.push(shift);
                }
            });
        });
        
        return shifts.sort((a, b) => a.startTime.localeCompare(b.startTime));
    }

    getRecentPerformanceReviews() {
        // Mock implementation - would get from management system
        return [];
    }

    getUpcomingTraining() {
        // Mock implementation - would get from management system
        return [];
    }

    getActiveTraining() {
        // Mock implementation - would get from management system
        return [];
    }

    renderWeekOptions() {
        const options = [];
        const currentWeek = this.managementSystem.getCurrentWeekStart();
        
        // Generate options for current week and next 4 weeks
        for (let i = 0; i < 5; i++) {
            const weekStart = new Date(currentWeek + (i * 7 * 24 * 60 * 60 * 1000));
            const weekEnd = new Date(weekStart.getTime() + (6 * 24 * 60 * 60 * 1000));
            
            options.push(`
                <option value="${weekStart.getTime()}" ${this.selectedWeek === weekStart.getTime() ? 'selected' : ''}>
                    ${weekStart.toLocaleDateString()} - ${weekEnd.toLocaleDateString()}
                </option>
            `);
        }
        
        return options.join('');
    }

    renderActivityFeed() {
        // Mock activity feed - would be populated with real events
        return `
            <div class="activity-item">
                <span class="activity-icon">üë§</span>
                <span class="activity-text">John Smith completed Customer Service Training</span>
                <span class="activity-time">2 hours ago</span>
            </div>
            <div class="activity-item">
                <span class="activity-icon">üìÖ</span>
                <span class="activity-text">Weekly schedule published for next week</span>
                <span class="activity-time">5 hours ago</span>
            </div>
            <div class="activity-item">
                <span class="activity-icon">‚≠ê</span>
                <span class="activity-text">Performance review completed for Sarah Wilson</span>
                <span class="activity-time">1 day ago</span>
            </div>
        `;
    }

    renderManagementAlerts() {
        // Mock alerts - would be generated based on actual conditions
        return `
            <div class="alert-item warning">
                <span class="alert-icon">‚ö†Ô∏è</span>
                <span class="alert-text">3 employees need performance reviews this week</span>
                <button class="alert-action" onclick="staffManagementInterface.conductPerformanceReviews()">Review</button>
            </div>
            <div class="alert-item info">
                <span class="alert-icon">üìö</span>
                <span class="alert-text">New training programs available</span>
                <button class="alert-action" onclick="staffManagementInterface.viewTraining()">View</button>
            </div>
        `;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = StaffManagementInterface;
} else if (typeof window !== 'undefined') {
    window.StaffManagementInterface = StaffManagementInterface;
}


/* === systems/automationSystem.js === */
/**
 * Phase 5C: Automation Systems
 * Intelligent automation framework for Store Manager Simulator
 * Reduces manual tasks while maintaining quality and player control
 */

class AutomationSystem {
    constructor() {
        this.gameState = null;
        this.eventBus = null;
        this.staffSystem = null;
        this.customerSystem = null;
        this.inventorySystem = null;
        
        // Automation modules
        this.aiAssistant = new AIAssistantManager();
        this.automatedCashier = new AutomatedCashierSystem();
        this.maintenanceBot = new AutomatedMaintenanceSystem();
        this.inventoryBot = new AutomatedInventorySystem();
        this.securityMonitor = new AutomatedSecuritySystem();
        
        // Automation settings
        this.automationSettings = {
            customerService: {
                enabled: false,
                quality: 'standard',
                personalTouch: 0.3,
                escalationThreshold: 0.7
            },
            inventory: {
                enabled: false,
                autoRestock: true,
                reorderPoint: 0.2,
                overstock: false,
                budgetLimit: 1000
            },
            maintenance: {
                enabled: false,
                schedule: 'daily',
                thoroughness: 'standard',
                emergencyResponse: true
            },
            security: {
                enabled: false,
                surveillance: 'active',
                alertLevel: 'medium',
                autoResponse: false
            },
            aiAssistant: {
                enabled: false,
                autonomy: 'suggestions',
                decisionMaking: 'supervised',
                learningMode: true
            }
        };
        
        // Performance tracking
        this.automationMetrics = {
            efficiency: {
                timesSaved: 0,
                tasksAutomated: 0,
                errorRate: 0.02
            },
            quality: {
                customerSatisfaction: 0.85,
                taskCompletionRate: 0.95,
                qualityScore: 0.88
            },
            costs: {
                operationalSavings: 0,
                automationCosts: 0,
                roi: 0
            }
        };
        
        this.initialized = false;
    }
    
    async initialize(gameState, eventBus, staffSystem, customerSystem, inventorySystem) {
        console.log('ü§ñ Initializing Automation Systems...');
        
        this.gameState = gameState;
        this.eventBus = eventBus;
        this.staffSystem = staffSystem;
        this.customerSystem = customerSystem;
        this.inventorySystem = inventorySystem;
        
        // Initialize automation modules
        await this.aiAssistant.initialize(this);
        await this.automatedCashier.initialize(this);
        await this.maintenanceBot.initialize(this);
        await this.inventoryBot.initialize(this);
        await this.securityMonitor.initialize(this);
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Start automation loops
        this.startAutomationLoops();
        
        this.initialized = true;
        console.log('‚úÖ Automation Systems initialized successfully!');
        
        this.eventBus.emit('automation:initialized', {
            systems: this.getAvailableSystems(),
            settings: this.automationSettings
        });
    }
    
    setupEventListeners() {
        // Customer service automation triggers
        this.eventBus.on('customer:arrived', (customer) => {
            if (this.automationSettings.customerService.enabled) {
                this.automatedCashier.handleCustomer(customer);
            }
        });
        
        // Inventory automation triggers
        this.eventBus.on('inventory:lowStock', (product) => {
            if (this.automationSettings.inventory.enabled) {
                this.inventoryBot.handleLowStock(product);
            }
        });
        
        // Maintenance automation triggers
        this.eventBus.on('store:opened', () => {
            if (this.automationSettings.maintenance.enabled) {
                this.maintenanceBot.performDailyMaintenance();
            }
        });
        
        // Security automation triggers
        this.eventBus.on('security:incident', (incident) => {
            if (this.automationSettings.security.enabled) {
                this.securityMonitor.handleIncident(incident);
            }
        });
        
        // AI Assistant decision points
        this.eventBus.on('decision:required', (decision) => {
            if (this.automationSettings.aiAssistant.enabled) {
                this.aiAssistant.analyzeDecision(decision);
            }
        });
    }
    
    startAutomationLoops() {
        // AI Assistant monitoring (every 30 seconds)
        setInterval(() => {
            if (this.automationSettings.aiAssistant.enabled) {
                this.aiAssistant.performPeriodicAnalysis();
            }
        }, 30000);
        
        // Inventory monitoring (every 2 minutes)
        setInterval(() => {
            if (this.automationSettings.inventory.enabled) {
                this.inventoryBot.performInventoryCheck();
            }
        }, 120000);
        
        // Security monitoring (every 15 seconds)
        setInterval(() => {
            if (this.automationSettings.security.enabled) {
                this.securityMonitor.performSecuritySweep();
            }
        }, 15000);
        
        // Performance metrics update (every 5 minutes)
        setInterval(() => {
            this.updateAutomationMetrics();
        }, 300000);
    }
    
    // Automation Control Methods
    enableAutomation(systemType, settings = {}) {
        if (!this.automationSettings[systemType]) {
            throw new Error(`Unknown automation system: ${systemType}`);
        }
        
        this.automationSettings[systemType].enabled = true;
        Object.assign(this.automationSettings[systemType], settings);
        
        console.log(`ü§ñ ${systemType} automation enabled`);
        this.eventBus.emit('automation:enabled', { system: systemType, settings });
        
        return {
            success: true,
            system: systemType,
            message: `${systemType} automation is now active`
        };
    }
    
    disableAutomation(systemType) {
        if (!this.automationSettings[systemType]) {
            throw new Error(`Unknown automation system: ${systemType}`);
        }
        
        this.automationSettings[systemType].enabled = false;
        
        console.log(`üõë ${systemType} automation disabled`);
        this.eventBus.emit('automation:disabled', { system: systemType });
        
        return {
            success: true,
            system: systemType,
            message: `${systemType} automation is now inactive`
        };
    }
    
    configureAutomation(systemType, settings) {
        if (!this.automationSettings[systemType]) {
            throw new Error(`Unknown automation system: ${systemType}`);
        }
        
        Object.assign(this.automationSettings[systemType], settings);
        
        console.log(`‚öôÔ∏è ${systemType} automation configured:`, settings);
        this.eventBus.emit('automation:configured', { system: systemType, settings });
        
        return {
            success: true,
            system: systemType,
            settings: this.automationSettings[systemType]
        };
    }
    
    getAutomationStatus() {
        const activeAutomations = [];
        const inactiveAutomations = [];
        
        for (const [system, config] of Object.entries(this.automationSettings)) {
            if (config.enabled) {
                activeAutomations.push(system);
            } else {
                inactiveAutomations.push(system);
            }
        }
        
        return {
            active: activeAutomations,
            inactive: inactiveAutomations,
            totalSystems: Object.keys(this.automationSettings).length,
            efficiency: this.automationMetrics.efficiency,
            quality: this.automationMetrics.quality,
            costs: this.automationMetrics.costs
        };
    }
    
    getAvailableSystems() {
        return [
            {
                id: 'customerService',
                name: 'Automated Customer Service',
                description: 'AI-powered cashier handles routine transactions',
                icon: 'ü§ñ',
                category: 'customer',
                cost: 200,
                requirements: ['cashier_hired']
            },
            {
                id: 'inventory',
                name: 'Automated Inventory Management',
                description: 'Smart restocking and inventory optimization',
                icon: 'üì¶',
                category: 'operations',
                cost: 300,
                requirements: ['stocker_hired']
            },
            {
                id: 'maintenance',
                name: 'Automated Maintenance',
                description: 'Scheduled cleaning and equipment maintenance',
                icon: 'üîß',
                category: 'operations',
                cost: 150,
                requirements: ['janitor_hired']
            },
            {
                id: 'security',
                name: 'Automated Security Monitoring',
                description: 'AI surveillance and threat detection',
                icon: 'üõ°Ô∏è',
                category: 'security',
                cost: 500,
                requirements: ['security_hired']
            },
            {
                id: 'aiAssistant',
                name: 'AI Assistant Manager',
                description: 'Strategic decision support and analysis',
                icon: 'üß†',
                category: 'management',
                cost: 1000,
                requirements: ['manager_hired']
            }
        ];
    }
    
    updateAutomationMetrics() {
        // Calculate efficiency gains
        const automatedSystems = Object.values(this.automationSettings)
            .filter(config => config.enabled).length;
        
        this.automationMetrics.efficiency.tasksAutomated = automatedSystems * 10;
        this.automationMetrics.efficiency.timesSaved = automatedSystems * 2.5;
        
        // Calculate quality impact
        let qualitySum = 0;
        let enabledCount = 0;
        
        for (const [system, config] of Object.entries(this.automationSettings)) {
            if (config.enabled) {
                // Different systems have different quality impacts
                const qualityMap = {
                    customerService: 0.85,
                    inventory: 0.90,
                    maintenance: 0.88,
                    security: 0.92,
                    aiAssistant: 0.95
                };
                qualitySum += qualityMap[system] || 0.80;
                enabledCount++;
            }
        }
        
        this.automationMetrics.quality.qualityScore = enabledCount > 0 
            ? qualitySum / enabledCount 
            : 0.75;
        
        // Calculate cost impact
        const totalCosts = this.getAvailableSystems()
            .filter(system => this.automationSettings[system.id]?.enabled)
            .reduce((sum, system) => sum + system.cost, 0);
        
        this.automationMetrics.costs.automationCosts = totalCosts;
        this.automationMetrics.costs.operationalSavings = automatedSystems * 50;
        this.automationMetrics.costs.roi = totalCosts > 0 
            ? (this.automationMetrics.costs.operationalSavings / totalCosts) * 100 
            : 0;
        
        this.eventBus.emit('automation:metricsUpdated', this.automationMetrics);
    }
    
    // Emergency automation control
    emergencyShutdown(reason = 'Manual override') {
        console.log('üö® Emergency automation shutdown initiated:', reason);
        
        for (const systemType of Object.keys(this.automationSettings)) {
            this.automationSettings[systemType].enabled = false;
        }
        
        this.eventBus.emit('automation:emergencyShutdown', { reason });
        
        return {
            success: true,
            message: 'All automation systems have been shut down',
            reason
        };
    }
    
    getRecommendations() {
        const recommendations = [];
        const status = this.getAutomationStatus();
        
        // Recommend based on current state
        if (status.active.length === 0) {
            recommendations.push({
                type: 'enable',
                system: 'customerService',
                reason: 'Start with customer service automation for immediate efficiency gains',
                priority: 'high'
            });
        }
        
        if (status.efficiency.timesSaved < 10 && status.inactive.includes('inventory')) {
            recommendations.push({
                type: 'enable',
                system: 'inventory',
                reason: 'Inventory automation will reduce manual restocking time',
                priority: 'medium'
            });
        }
        
        if (this.automationMetrics.quality.qualityScore < 0.8) {
            recommendations.push({
                type: 'configure',
                system: 'all',
                reason: 'Consider adjusting automation quality settings for better performance',
                priority: 'medium'
            });
        }
        
        return recommendations;
    }
}

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.AutomationSystem = AutomationSystem;
} else if (typeof module !== 'undefined' && module.exports) {
    module.exports = AutomationSystem;
}


/* === systems/aiAssistantManager.js === */
/**
 * AI Assistant Manager
 * Strategic decision support and intelligent automation
 */

class AIAssistantManager {
    constructor() {
        this.automationSystem = null;
        this.gameState = null;
        this.eventBus = null;
        
        // AI decision-making parameters
        this.intelligence = {
            learningRate: 0.1,
            confidence: 0.7,
            riskTolerance: 0.3,
            creativityLevel: 0.5
        };
        
        // Decision history for learning
        this.decisionHistory = [];
        this.performanceTracker = {
            correctDecisions: 0,
            totalDecisions: 0,
            learningProgress: 0
        };
        
        // Strategic analysis modules
        this.analysisModules = {
            customerBehavior: new CustomerBehaviorAnalyzer(),
            marketTrends: new MarketTrendAnalyzer(),
            financialHealth: new FinancialHealthAnalyzer(),
            staffPerformance: new StaffPerformanceAnalyzer(),
            operationalEfficiency: new OperationalEfficiencyAnalyzer()
        };
        
        this.initialized = false;
    }
    
    async initialize(automationSystem) {
        console.log('üß† Initializing AI Assistant Manager...');
        
        this.automationSystem = automationSystem;
        this.gameState = automationSystem.gameState;
        this.eventBus = automationSystem.eventBus;
        
        // Initialize analysis modules
        for (const [name, module] of Object.entries(this.analysisModules)) {
            await module.initialize(this);
        }
        
        this.initialized = true;
        console.log('‚úÖ AI Assistant Manager initialized!');
    }
    
    async analyzeDecision(decision) {
        if (!this.initialized) return null;
        
        console.log('ü§î AI Assistant analyzing decision:', decision.type);
        
        const analysis = {
            decisionId: decision.id,
            type: decision.type,
            context: decision.context,
            timestamp: Date.now(),
            recommendations: [],
            confidence: 0,
            reasoning: []
        };
        
        // Analyze based on decision type
        switch (decision.type) {
            case 'pricing':
                analysis.recommendations = await this.analyzePricingDecision(decision);
                break;
            case 'hiring':
                analysis.recommendations = await this.analyzeHiringDecision(decision);
                break;
            case 'inventory':
                analysis.recommendations = await this.analyzeInventoryDecision(decision);
                break;
            case 'expansion':
                analysis.recommendations = await this.analyzeExpansionDecision(decision);
                break;
            case 'customer_service':
                analysis.recommendations = await this.analyzeCustomerServiceDecision(decision);
                break;
            default:
                analysis.recommendations = await this.analyzeGeneralDecision(decision);
        }
        
        // Calculate overall confidence
        analysis.confidence = this.calculateConfidence(analysis.recommendations);
        
        // Store decision for learning
        this.decisionHistory.push({
            decision,
            analysis,
            timestamp: Date.now(),
            outcome: null // Will be updated later
        });
        
        // Emit recommendation
        this.eventBus.emit('aiAssistant:recommendation', analysis);
        
        return analysis;
    }
    
    async analyzePricingDecision(decision) {
        const recommendations = [];
        
        // Market analysis
        const marketData = await this.analysisModules.marketTrends.getMarketData(decision.context.product);
        const customerBehavior = await this.analysisModules.customerBehavior.getPricingSensitivity();
        
        if (marketData.trend === 'rising' && customerBehavior.elasticity < 0.5) {
            recommendations.push({
                action: 'increase_price',
                amount: 0.15,
                reasoning: 'Market trend is rising and customers show low price sensitivity',
                confidence: 0.8,
                expectedOutcome: 'Increased profit margins with minimal sales impact'
            });
        } else if (marketData.competition === 'high') {
            recommendations.push({
                action: 'competitive_pricing',
                amount: -0.05,
                reasoning: 'High competition requires competitive pricing strategy',
                confidence: 0.7,
                expectedOutcome: 'Maintain market share and customer base'
            });
        }
        
        return recommendations;
    }
    
    async analyzeHiringDecision(decision) {
        const recommendations = [];
        const staffAnalysis = await this.analysisModules.staffPerformance.getCurrentStaffing();
        const financialHealth = await this.analysisModules.financialHealth.getHiringCapacity();
        
        if (staffAnalysis.workload > 0.8 && financialHealth.canAffordHiring) {
            recommendations.push({
                action: 'hire_recommended',
                position: decision.context.position,
                reasoning: 'High workload and financial capacity support hiring',
                confidence: 0.85,
                expectedOutcome: 'Improved efficiency and reduced staff burnout'
            });
        } else if (financialHealth.tightBudget) {
            recommendations.push({
                action: 'delay_hiring',
                reasoning: 'Current financial constraints suggest delaying new hires',
                confidence: 0.75,
                expectedOutcome: 'Maintain financial stability'
            });
        }
        
        return recommendations;
    }
    
    async analyzeInventoryDecision(decision) {
        const recommendations = [];
        const demandForecast = await this.analysisModules.customerBehavior.getDemandForecast();
        const cashFlow = await this.analysisModules.financialHealth.getCashFlowProjection();
        
        for (const product of decision.context.products) {
            const forecast = demandForecast[product.id];
            
            if (forecast && forecast.trend === 'increasing') {
                recommendations.push({
                    action: 'increase_stock',
                    product: product.id,
                    amount: Math.ceil(forecast.projected * 1.2),
                    reasoning: 'Demand forecast shows increasing trend',
                    confidence: forecast.confidence,
                    expectedOutcome: 'Meet increased demand and avoid stockouts'
                });
            }
        }
        
        return recommendations;
    }
    
    async analyzeExpansionDecision(decision) {
        const recommendations = [];
        const financialHealth = await this.analysisModules.financialHealth.getExpansionReadiness();
        const marketConditions = await this.analysisModules.marketTrends.getMarketConditions();
        
        if (financialHealth.ready && marketConditions.favorable) {
            recommendations.push({
                action: 'proceed_expansion',
                type: decision.context.expansionType,
                reasoning: 'Strong financial position and favorable market conditions',
                confidence: 0.8,
                expectedOutcome: 'Business growth and increased revenue potential'
            });
        } else {
            recommendations.push({
                action: 'defer_expansion',
                reasoning: 'Current conditions not optimal for expansion',
                confidence: 0.7,
                expectedOutcome: 'Maintain stability and build stronger foundation'
            });
        }
        
        return recommendations;
    }
    
    async analyzeCustomerServiceDecision(decision) {
        const recommendations = [];
        const customerSatisfaction = await this.analysisModules.customerBehavior.getSatisfactionMetrics();
        const operationalData = await this.analysisModules.operationalEfficiency.getServiceMetrics();
        
        if (customerSatisfaction.score < 0.7) {
            recommendations.push({
                action: 'improve_service',
                focus: 'training',
                reasoning: 'Customer satisfaction below target threshold',
                confidence: 0.9,
                expectedOutcome: 'Improved customer retention and reputation'
            });
        }
        
        return recommendations;
    }
    
    async analyzeGeneralDecision(decision) {
        // Fallback analysis for unknown decision types
        return [{
            action: 'manual_review',
            reasoning: 'Decision type requires human judgment',
            confidence: 0.5,
            expectedOutcome: 'Maintain control over unique situations'
        }];
    }
    
    calculateConfidence(recommendations) {
        if (!recommendations.length) return 0;
        
        const totalConfidence = recommendations.reduce((sum, rec) => sum + rec.confidence, 0);
        return totalConfidence / recommendations.length;
    }
    
    async performPeriodicAnalysis() {
        if (!this.initialized) return;
        
        console.log('üìä AI Assistant performing periodic analysis...');
        
        // Analyze current store state
        const storeAnalysis = {
            financial: await this.analysisModules.financialHealth.getOverallHealth(),
            operational: await this.analysisModules.operationalEfficiency.getEfficiencyReport(),
            customer: await this.analysisModules.customerBehavior.getCustomerInsights(),
            staff: await this.analysisModules.staffPerformance.getTeamAnalysis(),
            market: await this.analysisModules.marketTrends.getMarketOverview()
        };
        
        // Generate insights and alerts
        const insights = this.generateInsights(storeAnalysis);
        const alerts = this.generateAlerts(storeAnalysis);
        
        // Emit periodic analysis
        this.eventBus.emit('aiAssistant:periodicAnalysis', {
            analysis: storeAnalysis,
            insights,
            alerts,
            timestamp: Date.now()
        });
        
        return { storeAnalysis, insights, alerts };
    }
    
    generateInsights(analysis) {
        const insights = [];
        
        // Financial insights
        if (analysis.financial.trend === 'declining') {
            insights.push({
                type: 'warning',
                category: 'financial',
                message: 'Revenue trend showing decline - consider cost optimization',
                priority: 'high'
            });
        }
        
        // Operational insights
        if (analysis.operational.efficiency < 0.7) {
            insights.push({
                type: 'suggestion',
                category: 'operational',
                message: 'Operational efficiency below target - automation could help',
                priority: 'medium'
            });
        }
        
        // Customer insights
        if (analysis.customer.satisfaction > 0.9) {
            insights.push({
                type: 'positive',
                category: 'customer',
                message: 'Excellent customer satisfaction - opportunity for premium pricing',
                priority: 'low'
            });
        }
        
        return insights;
    }
    
    generateAlerts(analysis) {
        const alerts = [];
        
        // Critical financial alert
        if (analysis.financial.cashFlow < 0) {
            alerts.push({
                type: 'critical',
                message: 'Negative cash flow detected - immediate action required',
                actions: ['reduce_expenses', 'increase_sales', 'seek_financing']
            });
        }
        
        // Staff burnout alert
        if (analysis.staff.burnoutRisk > 0.8) {
            alerts.push({
                type: 'urgent',
                message: 'High staff burnout risk - consider additional hiring',
                actions: ['hire_staff', 'reduce_hours', 'improve_benefits']
            });
        }
        
        return alerts;
    }
    
    // Learning and improvement methods
    updateDecisionOutcome(decisionId, outcome) {
        const decision = this.decisionHistory.find(d => d.decision.id === decisionId);
        if (decision) {
            decision.outcome = outcome;
            this.performanceTracker.totalDecisions++;
            
            if (outcome.success) {
                this.performanceTracker.correctDecisions++;
            }
            
            // Update learning progress
            this.performanceTracker.learningProgress = 
                this.performanceTracker.correctDecisions / this.performanceTracker.totalDecisions;
            
            // Adjust intelligence parameters based on outcomes
            this.adjustIntelligence(decision, outcome);
        }
    }
    
    adjustIntelligence(decision, outcome) {
        const learningRate = this.intelligence.learningRate;
        
        if (outcome.success) {
            // Increase confidence in successful strategies
            this.intelligence.confidence = Math.min(1.0, 
                this.intelligence.confidence + (learningRate * 0.1));
        } else {
            // Decrease confidence and increase creativity for failed decisions
            this.intelligence.confidence = Math.max(0.1, 
                this.intelligence.confidence - (learningRate * 0.05));
            this.intelligence.creativityLevel = Math.min(1.0, 
                this.intelligence.creativityLevel + (learningRate * 0.1));
        }
    }
    
    getPerformanceReport() {
        return {
            decisionsMade: this.performanceTracker.totalDecisions,
            successRate: this.performanceTracker.learningProgress,
            intelligence: this.intelligence,
            recentDecisions: this.decisionHistory.slice(-10)
        };
    }
}

// Mock analyzer classes (to be implemented in separate files)
class CustomerBehaviorAnalyzer {
    async initialize(aiAssistant) { this.aiAssistant = aiAssistant; }
    async getPricingSensitivity() { return { elasticity: 0.3 }; }
    async getDemandForecast() { return {}; }
    async getSatisfactionMetrics() { return { score: 0.8 }; }
    async getCustomerInsights() { return { satisfaction: 0.8 }; }
}

class MarketTrendAnalyzer {
    async initialize(aiAssistant) { this.aiAssistant = aiAssistant; }
    async getMarketData(product) { return { trend: 'stable', competition: 'medium' }; }
    async getMarketConditions() { return { favorable: true }; }
    async getMarketOverview() { return { trend: 'growing' }; }
}

class FinancialHealthAnalyzer {
    async initialize(aiAssistant) { this.aiAssistant = aiAssistant; }
    async getHiringCapacity() { return { canAffordHiring: true, tightBudget: false }; }
    async getCashFlowProjection() { return { positive: true }; }
    async getExpansionReadiness() { return { ready: true }; }
    async getOverallHealth() { return { trend: 'stable', cashFlow: 1000 }; }
}

class StaffPerformanceAnalyzer {
    async initialize(aiAssistant) { this.aiAssistant = aiAssistant; }
    async getCurrentStaffing() { return { workload: 0.7 }; }
    async getTeamAnalysis() { return { burnoutRisk: 0.3 }; }
}

class OperationalEfficiencyAnalyzer {
    async initialize(aiAssistant) { this.aiAssistant = aiAssistant; }
    async getServiceMetrics() { return { efficiency: 0.8 }; }
    async getEfficiencyReport() { return { efficiency: 0.8 }; }
}

// Export for use in automation system
if (typeof window !== 'undefined') {
    window.AIAssistantManager = AIAssistantManager;
} else if (typeof module !== 'undefined' && module.exports) {
    module.exports = AIAssistantManager;
}


/* === systems/automatedCashierSystem.js === */
/**
 * Automated Cashier System
 * Handles routine customer transactions with AI assistance
 */

class AutomatedCashierSystem {
    constructor() {
        this.automationSystem = null;
        this.gameState = null;
        this.eventBus = null;
        
        // Cashier AI settings
        this.settings = {
            efficiency: 0.85,
            accuracy: 0.95,
            customerServiceLevel: 0.8,
            escalationThreshold: 0.7,
            personalityType: 'friendly'
        };
        
        // Transaction handling
        this.transactionQueue = [];
        this.activeTransactions = new Map();
        this.processedTransactions = [];
        
        // Performance metrics
        this.metrics = {
            transactionsProcessed: 0,
            averageTransactionTime: 45, // seconds
            customerSatisfactionRate: 0.82,
            errorRate: 0.03,
            escalationRate: 0.15
        };
        
        // AI conversation templates
        this.conversationTemplates = {
            greeting: [
                "Hello! Welcome to our store. How can I help you today?",
                "Good morning! What can I assist you with?",
                "Hi there! Ready to check out?",
                "Welcome! I'm here to help with your purchase."
            ],
            processing: [
                "Let me scan these items for you...",
                "Processing your purchase now...",
                "Just getting your total ready...",
                "Almost done with your transaction..."
            ],
            upselling: [
                "Would you like to add any batteries with that?",
                "We have a special offer on snacks today, interested?",
                "Can I interest you in our store loyalty program?",
                "Would you like a bag for your items?"
            ],
            completion: [
                "Your total comes to ${total}. Will that be cash or card?",
                "That'll be ${total}. How would you like to pay?",
                "Your purchase total is ${total}. Payment method?",
                "All set! That's ${total}. Cash or card today?"
            ],
            farewell: [
                "Thank you for shopping with us! Have a great day!",
                "Thanks for your purchase! Come back soon!",
                "Have a wonderful day, and thank you for choosing us!",
                "Thanks for visiting! See you next time!"
            ]
        };
        
        this.initialized = false;
    }
    
    async initialize(automationSystem) {
        console.log('ü§ñ Initializing Automated Cashier System...');
        
        this.automationSystem = automationSystem;
        this.gameState = automationSystem.gameState;
        this.eventBus = automationSystem.eventBus;
        
        // Set up transaction processing loop
        this.startTransactionProcessing();
        
        this.initialized = true;
        console.log('‚úÖ Automated Cashier System initialized!');
    }
    
    startTransactionProcessing() {
        // Process transactions every 5 seconds
        setInterval(() => {
            this.processTransactionQueue();
        }, 5000);
        
        // Update metrics every 30 seconds
        setInterval(() => {
            this.updateMetrics();
        }, 30000);
    }
    
    async handleCustomer(customer) {
        if (!this.initialized) return null;
        
        console.log('üõí Automated cashier handling customer:', customer.name);
        
        // Check if customer needs escalation
        if (this.needsEscalation(customer)) {
            return this.escalateToHuman(customer);
        }
        
        // Add to transaction queue
        const transaction = {
            id: `auto_trans_${Date.now()}`,
            customer: customer,
            items: customer.cart || [],
            startTime: Date.now(),
            status: 'queued',
            aiConversation: []
        };
        
        this.transactionQueue.push(transaction);
        this.activeTransactions.set(transaction.id, transaction);
        
        // Emit transaction started event
        this.eventBus.emit('cashier:transactionStarted', {
            transactionId: transaction.id,
            customer: customer.name,
            automated: true
        });
        
        return transaction;
    }
    
    needsEscalation(customer) {
        // Escalate for complex situations
        const escalationFactors = [
            customer.mood === 'angry',
            customer.hasComplaint === true,
            customer.specialRequest === true,
            customer.cart?.length > 20,
            customer.paymentIssue === true,
            customer.isVIP === true
        ];
        
        const escalationScore = escalationFactors.filter(factor => factor).length / escalationFactors.length;
        return escalationScore >= this.settings.escalationThreshold;
    }
    
    escalateToHuman(customer) {
        console.log('üë§ Escalating customer to human cashier:', customer.name);
        
        this.eventBus.emit('cashier:escalation', {
            customer: customer,
            reason: 'Requires human attention',
            timestamp: Date.now()
        });
        
        this.metrics.escalationRate += 0.01;
        
        return {
            escalated: true,
            reason: 'Customer situation requires human cashier',
            customer: customer
        };
    }
    
    processTransactionQueue() {
        if (this.transactionQueue.length === 0) return;
        
        // Process up to 3 transactions simultaneously
        const maxConcurrent = 3;
        const processing = Array.from(this.activeTransactions.values())
            .filter(t => t.status === 'processing').length;
        
        if (processing >= maxConcurrent) return;
        
        // Start processing next transaction
        const nextTransaction = this.transactionQueue.shift();
        if (nextTransaction) {
            this.processTransaction(nextTransaction);
        }
    }
    
    async processTransaction(transaction) {
        console.log('üí≥ Processing automated transaction:', transaction.id);
        
        transaction.status = 'processing';
        transaction.processingStartTime = Date.now();
        
        try {
            // Step 1: Greeting
            await this.addConversationStep(transaction, 'greeting');
            await this.simulateDelay(1000, 2000);
            
            // Step 2: Scan items
            await this.scanItems(transaction);
            await this.simulateDelay(2000, 4000);
            
            // Step 3: Upselling (optional)
            if (Math.random() < 0.3) { // 30% chance of upselling
                await this.addConversationStep(transaction, 'upselling');
                await this.simulateDelay(1000, 2000);
            }
            
            // Step 4: Calculate total and request payment
            await this.calculateTotal(transaction);
            await this.addConversationStep(transaction, 'completion', { total: transaction.total });
            await this.simulateDelay(2000, 3000);
            
            // Step 5: Process payment
            await this.processPayment(transaction);
            await this.simulateDelay(2000, 4000);
            
            // Step 6: Farewell
            await this.addConversationStep(transaction, 'farewell');
            await this.simulateDelay(500, 1000);
            
            // Complete transaction
            this.completeTransaction(transaction);
            
        } catch (error) {
            console.error('‚ùå Error processing automated transaction:', error);
            this.failTransaction(transaction, error);
        }
    }
    
    async addConversationStep(transaction, type, data = {}) {
        const templates = this.conversationTemplates[type];
        if (!templates) return;
        
        let message = templates[Math.floor(Math.random() * templates.length)];
        
        // Replace placeholders
        if (data.total) {
            message = message.replace('${total}', `${data.total.toFixed(2)}`);
        }
        
        const conversationStep = {
            type: type,
            message: message,
            timestamp: Date.now(),
            speaker: 'cashier_ai'
        };
        
        transaction.aiConversation.push(conversationStep);
        
        // Emit conversation update
        this.eventBus.emit('cashier:conversation', {
            transactionId: transaction.id,
            step: conversationStep
        });
    }
    
    async scanItems(transaction) {
        let totalItems = 0;
        let totalValue = 0;
        
        for (const item of transaction.items) {
            // Simulate scanning time per item
            await this.simulateDelay(500, 1500);
            
            totalItems += item.quantity || 1;
            totalValue += (item.price || 5) * (item.quantity || 1);
            
            // Chance of scanning error
            if (Math.random() < this.metrics.errorRate) {
                console.log('‚ö†Ô∏è Scanning error detected, requesting manual verification');
                await this.simulateDelay(2000, 3000); // Extra time for error handling
            }
        }
        
        transaction.totalItems = totalItems;
        transaction.subtotal = totalValue;
        
        await this.addConversationStep(transaction, 'processing');
    }
    
    async calculateTotal(transaction) {
        const subtotal = transaction.subtotal || 0;
        const tax = subtotal * 0.08; // 8% tax rate
        const total = subtotal + tax;
        
        transaction.tax = tax;
        transaction.total = total;
        
        // Record transaction details
        this.eventBus.emit('transaction:calculated', {
            transactionId: transaction.id,
            subtotal: subtotal,
            tax: tax,
            total: total,
            items: transaction.totalItems
        });
    }
    
    async processPayment(transaction) {
        // Simulate payment processing
        const paymentMethods = ['card', 'cash', 'mobile'];
        const selectedMethod = paymentMethods[Math.floor(Math.random() * paymentMethods.length)];
        
        transaction.paymentMethod = selectedMethod;
        
        // Different processing times for different methods
        const processingTime = {
            card: { min: 3000, max: 6000 },
            cash: { min: 2000, max: 4000 },
            mobile: { min: 1000, max: 3000 }
        };
        
        const times = processingTime[selectedMethod];
        await this.simulateDelay(times.min, times.max);
        
        // Small chance of payment failure
        if (Math.random() < 0.02) { // 2% payment failure rate
            throw new Error('Payment processing failed');
        }
        
        transaction.paymentProcessed = true;
        transaction.paymentTime = Date.now();
    }
    
    completeTransaction(transaction) {
        transaction.status = 'completed';
        transaction.endTime = Date.now();
        transaction.duration = transaction.endTime - transaction.startTime;
        
        // Remove from active transactions
        this.activeTransactions.delete(transaction.id);
        
        // Add to processed transactions
        this.processedTransactions.push(transaction);
        
        // Update metrics
        this.metrics.transactionsProcessed++;
        
        // Calculate customer satisfaction based on transaction
        const satisfaction = this.calculateCustomerSatisfaction(transaction);
        transaction.customerSatisfaction = satisfaction;
        
        // Update game state
        if (this.gameState.store) {
            this.gameState.store.revenue = (this.gameState.store.revenue || 0) + transaction.total;
            this.gameState.store.transactionsToday = (this.gameState.store.transactionsToday || 0) + 1;
        }
        
        // Emit completion event
        this.eventBus.emit('cashier:transactionCompleted', {
            transactionId: transaction.id,
            customer: transaction.customer.name,
            total: transaction.total,
            duration: transaction.duration,
            satisfaction: satisfaction,
            automated: true
        });
        
        console.log(`‚úÖ Automated transaction completed: ${transaction.id} - ${transaction.total.toFixed(2)}`);
    }
    
    failTransaction(transaction, error) {
        transaction.status = 'failed';
        transaction.endTime = Date.now();
        transaction.error = error.message;
        
        // Remove from active transactions
        this.activeTransactions.delete(transaction.id);
        
        // Escalate to human cashier
        this.escalateToHuman(transaction.customer);
        
        console.log(`‚ùå Automated transaction failed: ${transaction.id} - ${error.message}`);
    }
    
    calculateCustomerSatisfaction(transaction) {
        let satisfaction = 0.8; // Base satisfaction
        
        // Adjust based on transaction duration
        const expectedDuration = 30000; // 30 seconds expected
        if (transaction.duration < expectedDuration) {
            satisfaction += 0.1; // Bonus for quick service
        } else if (transaction.duration > expectedDuration * 2) {
            satisfaction -= 0.2; // Penalty for slow service
        }
        
        // Adjust based on conversation quality
        if (transaction.aiConversation.length >= 4) {
            satisfaction += 0.05; // Bonus for good interaction
        }
        
        // Random variation for realism
        satisfaction += (Math.random() - 0.5) * 0.1;
        
        return Math.max(0, Math.min(1, satisfaction));
    }
    
    updateMetrics() {
        if (this.processedTransactions.length === 0) return;
        
        // Calculate average transaction time
        const totalTime = this.processedTransactions.reduce((sum, t) => sum + t.duration, 0);
        this.metrics.averageTransactionTime = totalTime / this.processedTransactions.length / 1000; // Convert to seconds
        
        // Calculate customer satisfaction rate
        const satisfactionSum = this.processedTransactions.reduce((sum, t) => sum + (t.customerSatisfaction || 0), 0);
        this.metrics.customerSatisfactionRate = satisfactionSum / this.processedTransactions.length;
        
        // Update error rate based on recent performance
        const recentTransactions = this.processedTransactions.slice(-20); // Last 20 transactions
        const errors = recentTransactions.filter(t => t.status === 'failed').length;
        this.metrics.errorRate = errors / recentTransactions.length;
        
        // Emit metrics update
        this.eventBus.emit('cashier:metricsUpdated', this.metrics);
    }
    
    async simulateDelay(min, max) {
        const delay = Math.random() * (max - min) + min;
        return new Promise(resolve => setTimeout(resolve, delay));
    }
    
    getPerformanceReport() {
        return {
            metrics: this.metrics,
            activeTransactions: this.activeTransactions.size,
            queueLength: this.transactionQueue.length,
            recentTransactions: this.processedTransactions.slice(-10),
            settings: this.settings
        };
    }
    
    updateSettings(newSettings) {
        Object.assign(this.settings, newSettings);
        console.log('‚öôÔ∏è Automated cashier settings updated:', newSettings);
    }
}

// Export for use in automation system
if (typeof window !== 'undefined') {
    window.AutomatedCashierSystem = AutomatedCashierSystem;
} else if (typeof module !== 'undefined' && module.exports) {
    module.exports = AutomatedCashierSystem;
}


/* === systems/automatedInventorySystem.js === */
/**
 * Automated Inventory System
 * Smart restocking and inventory optimization
 */

class AutomatedInventorySystem {
    constructor() {
        this.automationSystem = null;
        this.gameState = null;
        this.eventBus = null;
        
        // Inventory AI settings
        this.settings = {
            autoRestock: true,
            reorderPoint: 0.2, // Reorder when 20% stock remaining
            safetyStock: 0.3, // Maintain 30% safety buffer
            maxOrderQuantity: 100,
            budgetLimit: 1000,
            demandForecastDays: 7,
            seasonalAdjustment: true
        };
        
        // Inventory tracking
        this.inventoryData = new Map();
        this.pendingOrders = new Map();
        this.orderHistory = [];
        this.demandForecasts = new Map();
        
        // Performance metrics
        this.metrics = {
            stockoutsPreventedToday: 0,
            overorderCost: 0,
            inventoryTurnover: 0,
            accuracyRate: 0.92,
            costSavings: 0
        };
        
        // Demand patterns
        this.demandPatterns = {
            daily: new Map(),
            weekly: new Map(),
            seasonal: new Map()
        };
        
        this.initialized = false;
    }
    
    async initialize(automationSystem) {
        console.log('üì¶ Initializing Automated Inventory System...');
        
        this.automationSystem = automationSystem;
        this.gameState = automationSystem.gameState;
        this.eventBus = automationSystem.eventBus;
        
        // Initialize inventory tracking
        await this.initializeInventoryTracking();
        
        // Start monitoring loops
        this.startInventoryMonitoring();
        this.startDemandAnalysis();
        
        this.initialized = true;
        console.log('‚úÖ Automated Inventory System initialized!');
    }
    
    async initializeInventoryTracking() {
        // Get current inventory from game state
        const inventory = this.gameState.inventory || {};
        
        for (const [productId, productData] of Object.entries(inventory)) {
            this.inventoryData.set(productId, {
                id: productId,
                name: productData.name,
                currentStock: productData.quantity || 0,
                lastRestockDate: productData.lastRestock || Date.now(),
                averageDailySales: this.calculateAverageDailySales(productId),
                reorderPoint: Math.max(1, Math.floor(productData.maxStock * this.settings.reorderPoint)),
                maxStock: productData.maxStock || 50,
                cost: productData.cost || 5,
                supplier: productData.supplier || 'default',
                leadTime: productData.leadTime || 2 // days
            });
        }
        
        console.log(`üìä Tracking ${this.inventoryData.size} products`);
    }
    
    startInventoryMonitoring() {
        // Check inventory levels every 2 minutes
        setInterval(() => {
            this.performInventoryCheck();
        }, 120000);
        
        // Update demand forecasts every hour
        setInterval(() => {
            this.updateDemandForecasts();
        }, 3600000);
        
        // Daily inventory analysis
        setInterval(() => {
            this.performDailyAnalysis();
        }, 86400000); // 24 hours
    }
    
    startDemandAnalysis() {
        // Analyze sales patterns every 30 minutes
        setInterval(() => {
            this.analyzeDemandPatterns();
        }, 1800000);
    }
    
    async performInventoryCheck() {
        if (!this.initialized) return;
        
        console.log('üîç Performing automated inventory check...');
        
        const restockNeeded = [];
        const currentTime = Date.now();
        
        for (const [productId, product] of this.inventoryData) {
            // Check if restock is needed
            if (this.needsRestock(product)) {
                const orderQuantity = this.calculateOptimalOrderQuantity(product);
                
                if (orderQuantity > 0 && !this.pendingOrders.has(productId)) {
                    restockNeeded.push({
                        product: product,
                        quantity: orderQuantity,
                        urgency: this.calculateUrgency(product)
                    });
                }
            }
            
            // Update stock levels from recent sales
            this.updateStockFromSales(product);
        }
        
        // Process restock orders
        if (restockNeeded.length > 0) {
            await this.processRestockOrders(restockNeeded);
        }
        
        // Emit inventory status
        this.eventBus.emit('inventory:statusUpdate', {
            totalProducts: this.inventoryData.size,
            restockNeeded: restockNeeded.length,
            pendingOrders: this.pendingOrders.size,
            timestamp: currentTime
        });
    }
    
    needsRestock(product) {
        // Check against reorder point
        if (product.currentStock <= product.reorderPoint) {
            return true;
        }
        
        // Check forecast demand vs current stock
        const forecast = this.demandForecasts.get(product.id);
        if (forecast) {
            const daysUntilStockout = product.currentStock / forecast.dailyDemand;
            if (daysUntilStockout <= product.leadTime + 1) {
                return true;
            }
        }
        
        return false;
    }
    
    calculateOptimalOrderQuantity(product) {
        const forecast = this.demandForecasts.get(product.id);
        const dailyDemand = forecast ? forecast.dailyDemand : product.averageDailySales;
        
        // Economic Order Quantity (EOQ) calculation
        const demandPeriod = 30; // 30 days
        const orderingCost = 10; // Fixed cost per order
        const holdingCostRate = 0.1; // 10% of product cost annually
        
        const annualDemand = dailyDemand * 365;
        const holdingCost = product.cost * holdingCostRate;
        
        let eoq = Math.sqrt((2 * annualDemand * orderingCost) / holdingCost);
        
        // Adjust for constraints
        eoq = Math.min(eoq, this.settings.maxOrderQuantity);
        eoq = Math.min(eoq, product.maxStock - product.currentStock);
        eoq = Math.max(eoq, 1);
        
        // Seasonal adjustment
        if (this.settings.seasonalAdjustment) {
            const seasonalFactor = this.getSeasonalFactor(product.id);
            eoq *= seasonalFactor;
        }
        
        return Math.floor(eoq);
    }
    
    calculateUrgency(product) {
        const stockRatio = product.currentStock / product.maxStock;
        const forecast = this.demandForecasts.get(product.id);
        
        if (stockRatio < 0.1) return 'critical';
        if (stockRatio < 0.2) return 'high';
        if (forecast && forecast.trend === 'increasing') return 'medium';
        return 'low';
    }
    
    async processRestockOrders(restockOrders) {
        console.log(`üìã Processing ${restockOrders.length} restock orders...`);
        
        // Sort by urgency
        restockOrders.sort((a, b) => {
            const urgencyPriority = { critical: 4, high: 3, medium: 2, low: 1 };
            return urgencyPriority[b.urgency] - urgencyPriority[a.urgency];
        });
        
        let totalCost = 0;
        const successfulOrders = [];
        
        for (const order of restockOrders) {
            const orderCost = order.quantity * order.product.cost;
            
            // Check budget constraint
            if (totalCost + orderCost > this.settings.budgetLimit) {
                console.log(`üí∞ Budget limit reached, skipping order for ${order.product.name}`);
                continue;
            }
            
            // Create order
            const orderDetails = await this.createRestockOrder(order);
            if (orderDetails) {
                successfulOrders.push(orderDetails);
                totalCost += orderCost;
            }
        }
        
        if (successfulOrders.length > 0) {
            this.eventBus.emit('inventory:restockOrdered', {
                orders: successfulOrders,
                totalCost: totalCost,
                timestamp: Date.now()
            });
        }
    }
    
    async createRestockOrder(order) {
        const orderId = `auto_order_${Date.now()}_${order.product.id}`;
        const deliveryDate = Date.now() + (order.product.leadTime * 24 * 60 * 60 * 1000);
        
        const orderDetails = {
            id: orderId,
            productId: order.product.id,
            productName: order.product.name,
            quantity: order.quantity,
            unitCost: order.product.cost,
            totalCost: order.quantity * order.product.cost,
            supplier: order.product.supplier,
            orderDate: Date.now(),
            expectedDelivery: deliveryDate,
            urgency: order.urgency,
            automated: true
        };
        
        // Add to pending orders
        this.pendingOrders.set(order.product.id, orderDetails);
        
        // Add to order history
        this.orderHistory.push(orderDetails);
        
        // Schedule delivery
        setTimeout(() => {
            this.processDelivery(orderDetails);
        }, order.product.leadTime * 24 * 60 * 60 * 1000);
        
        console.log(`üì¶ Restock order placed: ${order.quantity}x ${order.product.name} - ${orderDetails.totalCost}`);
        
        return orderDetails;
    }
    
    processDelivery(orderDetails) {
        console.log(`üöö Processing delivery: ${orderDetails.productName}`);
        
        // Update inventory
        const product = this.inventoryData.get(orderDetails.productId);
        if (product) {
            product.currentStock += orderDetails.quantity;
            product.lastRestockDate = Date.now();
            
            // Update game state
            if (this.gameState.inventory && this.gameState.inventory[orderDetails.productId]) {
                this.gameState.inventory[orderDetails.productId].quantity = product.currentStock;
                this.gameState.inventory[orderDetails.productId].lastRestock = product.lastRestockDate;
            }
            
            // Update store finances
            if (this.gameState.store) {
                this.gameState.store.cash = (this.gameState.store.cash || 1000) - orderDetails.totalCost;
            }
        }
        
        // Remove from pending orders
        this.pendingOrders.delete(orderDetails.productId);
        
        // Update order status
        orderDetails.status = 'delivered';
        orderDetails.deliveryDate = Date.now();
        
        // Update metrics
        this.metrics.stockoutsPreventedToday++;
        
        this.eventBus.emit('inventory:deliveryReceived', orderDetails);
    }
    
    updateDemandForecasts() {
        console.log('üìà Updating demand forecasts...');
        
        for (const [productId, product] of this.inventoryData) {
            const historicalData = this.getSalesHistory(productId);
            const forecast = this.generateDemandForecast(product, historicalData);
            this.demandForecasts.set(productId, forecast);
        }
    }
    
    generateDemandForecast(product, historicalData) {
        // Simple moving average with trend analysis
        const recentSales = historicalData.slice(-7); // Last 7 days
        const averageDailySales = recentSales.reduce((sum, day) => sum + day.quantity, 0) / recentSales.length;
        
        // Calculate trend
        let trend = 'stable';
        if (recentSales.length >= 3) {
            const earlyAvg = recentSales.slice(0, 3).reduce((sum, day) => sum + day.quantity, 0) / 3;
            const lateAvg = recentSales.slice(-3).reduce((sum, day) => sum + day.quantity, 0) / 3;
            
            if (lateAvg > earlyAvg * 1.1) trend = 'increasing';
            else if (lateAvg < earlyAvg * 0.9) trend = 'decreasing';
        }
        
        // Future demand projection
        const trendMultiplier = trend === 'increasing' ? 1.1 : trend === 'decreasing' ? 0.9 : 1.0;
        const forecastDemand = averageDailySales * trendMultiplier;
        
        return {
            dailyDemand: Math.max(0.1, forecastDemand),
            trend: trend,
            confidence: Math.min(0.9, recentSales.length / 7),
            lastUpdated: Date.now()
        };
    }
    
    analyzeDemandPatterns() {
        // Analyze daily patterns (hour of day)
        // Analyze weekly patterns (day of week)
        // Analyze seasonal patterns (month/season)
        
        for (const [productId, product] of this.inventoryData) {
            const salesHistory = this.getSalesHistory(productId);
            
            // Daily pattern analysis
            const hourlyPattern = this.analyzeHourlyPattern(salesHistory);
            this.demandPatterns.daily.set(productId, hourlyPattern);
            
            // Weekly pattern analysis
            const weeklyPattern = this.analyzeWeeklyPattern(salesHistory);
            this.demandPatterns.weekly.set(productId, weeklyPattern);
        }
    }
    
    analyzeHourlyPattern(salesHistory) {
        const hourlyData = new Array(24).fill(0);
        
        salesHistory.forEach(sale => {
            const hour = new Date(sale.timestamp).getHours();
            hourlyData[hour] += sale.quantity;
        });
        
        return hourlyData;
    }
    
    analyzeWeeklyPattern(salesHistory) {
        const weeklyData = new Array(7).fill(0); // 0 = Sunday
        
        salesHistory.forEach(sale => {
            const dayOfWeek = new Date(sale.timestamp).getDay();
            weeklyData[dayOfWeek] += sale.quantity;
        });
        
        return weeklyData;
    }
    
    getSeasonalFactor(productId) {
        const currentMonth = new Date().getMonth();
        
        // Simple seasonal factors (could be enhanced with ML)
        const seasonalFactors = {
            beverages: [0.8, 0.8, 0.9, 1.0, 1.2, 1.3, 1.4, 1.3, 1.1, 1.0, 0.9, 0.8],
            snacks: [1.1, 1.0, 0.9, 0.9, 1.0, 1.1, 1.2, 1.1, 1.0, 1.0, 1.1, 1.2],
            default: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
        };
        
        // Determine product category (simplified)
        const product = this.inventoryData.get(productId);
        let category = 'default';
        if (product.name.toLowerCase().includes('drink') || product.name.toLowerCase().includes('soda')) {
            category = 'beverages';
        } else if (product.name.toLowerCase().includes('snack') || product.name.toLowerCase().includes('chip')) {
            category = 'snacks';
        }
        
        return seasonalFactors[category][currentMonth];
    }
    
    getSalesHistory(productId) {
        // Mock sales history - in real implementation, this would come from actual sales data
        const history = [];
        const daysBack = 30;
        
        for (let i = daysBack; i >= 0; i--) {
            const date = new Date();
            date.setDate(date.getDate() - i);
            
            // Generate mock sales with some randomness
            const baseSales = Math.random() * 10 + 2;
            history.push({
                date: date.toISOString().split('T')[0],
                timestamp: date.getTime(),
                quantity: Math.floor(baseSales),
                productId: productId
            });
        }
        
        return history;
    }
    
    calculateAverageDailySales(productId) {
        const history = this.getSalesHistory(productId);
        const total = history.reduce((sum, day) => sum + day.quantity, 0);
        return total / history.length;
    }
    
    updateStockFromSales(product) {
        // This would be called when actual sales occur
        // For now, we simulate gradual stock depletion
        if (Math.random() < 0.1) { // 10% chance per check
            const salesAmount = Math.floor(Math.random() * 3) + 1;
            product.currentStock = Math.max(0, product.currentStock - salesAmount);
            
            if (this.gameState.inventory && this.gameState.inventory[product.id]) {
                this.gameState.inventory[product.id].quantity = product.currentStock;
            }
        }
    }
    
    async handleLowStock(product) {
        console.log('‚ö†Ô∏è Low stock alert received for:', product.name);
        
        if (this.settings.autoRestock) {
            const productData = this.inventoryData.get(product.id);
            if (productData && !this.pendingOrders.has(product.id)) {
                const quantity = this.calculateOptimalOrderQuantity(productData);
                if (quantity > 0) {
                    await this.createRestockOrder({
                        product: productData,
                        quantity: quantity,
                        urgency: 'high'
                    });
                }
            }
        }
    }
    
    performDailyAnalysis() {
        console.log('üìä Performing daily inventory analysis...');
        
        // Calculate inventory turnover
        // Analyze cost savings
        // Update performance metrics
        
        this.eventBus.emit('inventory:dailyAnalysis', {
            metrics: this.metrics,
            inventoryStatus: this.getInventoryStatus(),
            timestamp: Date.now()
        });
    }
    
    getInventoryStatus() {
        const status = {
            totalProducts: this.inventoryData.size,
            lowStockItems: 0,
            overstockedItems: 0,
            pendingOrders: this.pendingOrders.size,
            totalValue: 0
        };
        
        for (const [productId, product] of this.inventoryData) {
            status.totalValue += product.currentStock * product.cost;
            
            if (product.currentStock <= product.reorderPoint) {
                status.lowStockItems++;
            } else if (product.currentStock > product.maxStock * 0.9) {
                status.overstockedItems++;
            }
        }
        
        return status;
    }
    
    getPerformanceReport() {
        return {
            metrics: this.metrics,
            inventoryStatus: this.getInventoryStatus(),
            demandForecasts: Array.from(this.demandForecasts.entries()),
            recentOrders: this.orderHistory.slice(-10),
            settings: this.settings
        };
    }
    
    updateSettings(newSettings) {
        Object.assign(this.settings, newSettings);
        console.log('‚öôÔ∏è Automated inventory settings updated:', newSettings);
    }
}

// Export for use in automation system
if (typeof window !== 'undefined') {
    window.AutomatedInventorySystem = AutomatedInventorySystem;
} else if (typeof module !== 'undefined' && module.exports) {
    module.exports = AutomatedInventorySystem;
}


/* === interfaces/automationInterface.js === */
/**
 * Automation Interface
 * Control panel for all automation systems
 */

class AutomationInterface {
    constructor() {
        this.automationSystem = null;
        this.gameState = null;
        this.eventBus = null;
        
        // UI state
        this.activeView = 'overview';
        this.selectedSystem = null;
        
        // Real-time data
        this.systemStatus = {};
        this.performanceData = {};
        this.alerts = [];
        
        this.initialized = false;
    }
    
    async initialize(automationSystem, gameState, eventBus) {
        console.log('ü§ñ Initializing Automation Interface...');
        
        this.automationSystem = automationSystem;
        this.gameState = gameState;
        this.eventBus = eventBus;
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Initialize real-time data
        this.refreshSystemData();
        
        this.initialized = true;
        console.log('‚úÖ Automation Interface initialized!');
    }
    
    setupEventListeners() {
        // System status updates
        this.eventBus.on('automation:enabled', (data) => {
            this.handleSystemStatusChange(data.system, 'enabled');
        });
        
        this.eventBus.on('automation:disabled', (data) => {
            this.handleSystemStatusChange(data.system, 'disabled');
        });
        
        // Performance updates
        this.eventBus.on('automation:metricsUpdated', (metrics) => {
            this.performanceData = metrics;
            this.refreshPerformanceDisplay();
        });
        
        // AI Assistant updates
        this.eventBus.on('aiAssistant:recommendation', (recommendation) => {
            this.addAlert({
                type: 'recommendation',
                message: `AI suggests: ${recommendation.recommendations[0]?.action}`,
                data: recommendation,
                priority: 'medium'
            });
        });
        
        // Cashier updates
        this.eventBus.on('cashier:transactionCompleted', (transaction) => {
            this.updateSystemPerformance('customerService', {
                transactionsProcessed: 1,
                averageTime: transaction.duration / 1000
            });
        });
        
        // Inventory updates
        this.eventBus.on('inventory:restockOrdered', (orders) => {
            this.addAlert({
                type: 'info',
                message: `Automated restock: ${orders.orders.length} orders placed`,
                data: orders,
                priority: 'low'
            });
        });
    }
    
    render() {
        if (!this.initialized) {
            return '<div class="automation-loading">Initializing Automation Systems...</div>';
        }
        
        return `
            <div class="automation-interface">
                <div class="automation-header">
                    <h2>ü§ñ Automation Control Center</h2>
                    <div class="automation-status">
                        <span class="status-indicator ${this.getOverallStatus()}"></span>
                        <span>${this.getSystemCount()} Systems Active</span>
                    </div>
                </div>
                
                <div class="automation-nav">
                    ${this.renderNavigationTabs()}
                </div>
                
                <div class="automation-content">
                    ${this.renderActiveView()}
                </div>
                
                <div class="automation-alerts">
                    ${this.renderAlerts()}
                </div>
            </div>
        `;
    }
    
    renderNavigationTabs() {
        const tabs = [
            { id: 'overview', name: 'Overview', icon: 'üìä' },
            { id: 'systems', name: 'Systems', icon: '‚öôÔ∏è' },
            { id: 'performance', name: 'Performance', icon: 'üìà' },
            { id: 'ai-assistant', name: 'AI Assistant', icon: 'üß†' },
            { id: 'settings', name: 'Settings', icon: 'üîß' }
        ];
        
        return tabs.map(tab => `
            <button class="automation-tab ${this.activeView === tab.id ? 'active' : ''}"
                    onclick="automationInterface.switchView('${tab.id}')">
                ${tab.icon} ${tab.name}
            </button>
        `).join('');
    }
    
    renderActiveView() {
        switch (this.activeView) {
            case 'overview':
                return this.renderOverviewView();
            case 'systems':
                return this.renderSystemsView();
            case 'performance':
                return this.renderPerformanceView();
            case 'ai-assistant':
                return this.renderAIAssistantView();
            case 'settings':
                return this.renderSettingsView();
            default:
                return this.renderOverviewView();
        }
    }
    
    renderOverviewView() {
        const status = this.automationSystem.getAutomationStatus();
        const recommendations = this.automationSystem.getRecommendations();
        
        return `
            <div class="overview-content">
                <div class="overview-grid">
                    <div class="overview-card">
                        <h3>üéØ System Status</h3>
                        <div class="status-grid">
                            <div class="status-item">
                                <span class="status-label">Active Systems</span>
                                <span class="status-value">${status.active.length}</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">Efficiency</span>
                                <span class="status-value">${Math.round(status.efficiency.timesSaved * 10)}%</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">Quality Score</span>
                                <span class="status-value">${Math.round(status.quality.qualityScore * 100)}%</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">ROI</span>
                                <span class="status-value">${Math.round(status.costs.roi)}%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="overview-card">
                        <h3>üîÑ Active Automations</h3>
                        <div class="active-systems">
                            ${status.active.length > 0 ? 
                                status.active.map(system => `
                                    <div class="system-item active">
                                        <span class="system-icon">${this.getSystemIcon(system)}</span>
                                        <span class="system-name">${this.getSystemName(system)}</span>
                                        <span class="system-status online">Online</span>
                                    </div>
                                `).join('') :
                                '<div class="no-systems">No automation systems active</div>'
                            }
                        </div>
                    </div>
                    
                    <div class="overview-card">
                        <h3>üí° Recommendations</h3>
                        <div class="recommendations">
                            ${recommendations.length > 0 ?
                                recommendations.slice(0, 3).map(rec => `
                                    <div class="recommendation-item ${rec.priority}">
                                        <span class="rec-type">${rec.type.toUpperCase()}</span>
                                        <span class="rec-message">${rec.reason}</span>
                                        <button class="rec-action" onclick="automationInterface.handleRecommendation('${rec.system}', '${rec.type}')">
                                            Apply
                                        </button>
                                    </div>
                                `).join('') :
                                '<div class="no-recommendations">All systems optimized</div>'
                            }
                        </div>
                    </div>
                    
                    <div class="overview-card">
                        <h3>üìä Performance Summary</h3>
                        <div class="performance-summary">
                            <div class="perf-metric">
                                <span class="metric-label">Tasks Automated</span>
                                <span class="metric-value">${status.efficiency.tasksAutomated}</span>
                            </div>
                            <div class="perf-metric">
                                <span class="metric-label">Time Saved</span>
                                <span class="metric-value">${status.efficiency.timesSaved.toFixed(1)}h</span>
                            </div>
                            <div class="perf-metric">
                                <span class="metric-label">Cost Savings</span>
                                <span class="metric-value">${status.costs.operationalSavings}</span>
                            </div>
                            <div class="perf-metric">
                                <span class="metric-label">Error Rate</span>
                                <span class="metric-value">${(status.efficiency.errorRate * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    renderSystemsView() {
        const availableSystems = this.automationSystem.getAvailableSystems();
        const status = this.automationSystem.getAutomationStatus();
        
        return `
            <div class="systems-content">
                <div class="systems-header">
                    <h3>‚öôÔ∏è Automation Systems</h3>
                    <button class="btn-emergency" onclick="automationInterface.emergencyShutdown()">
                        üö® Emergency Shutdown
                    </button>
                </div>
                
                <div class="systems-grid">
                    ${availableSystems.map(system => {
                        const isActive = status.active.includes(system.id);
                        const settings = this.automationSystem.automationSettings[system.id];
                        
                        return `
                            <div class="system-card ${isActive ? 'active' : 'inactive'}">
                                <div class="system-header">
                                    <span class="system-icon">${system.icon}</span>
                                    <h4>${system.name}</h4>
                                    <div class="system-toggle">
                                        <label class="toggle-switch">
                                            <input type="checkbox" ${isActive ? 'checked' : ''} 
                                                   onchange="automationInterface.toggleSystem('${system.id}')">
                                            <span class="toggle-slider"></span>
                                        </label>
                                    </div>
                                </div>
                                
                                <div class="system-description">
                                    ${system.description}
                                </div>
                                
                                <div class="system-details">
                                    <div class="detail-item">
                                        <span class="detail-label">Cost:</span>
                                        <span class="detail-value">${system.cost}</span>
                                    </div>
                                    <div class="detail-item">
                                        <span class="detail-label">Category:</span>
                                        <span class="detail-value">${system.category}</span>
                                    </div>
                                    <div class="detail-item">
                                        <span class="detail-label">Status:</span>
                                        <span class="detail-value ${isActive ? 'online' : 'offline'}">
                                            ${isActive ? 'Online' : 'Offline'}
                                        </span>
                                    </div>
                                </div>
                                
                                ${isActive ? `
                                    <div class="system-settings">
                                        <button class="btn-configure" 
                                                onclick="automationInterface.configureSystem('${system.id}')">
                                            Configure
                                        </button>
                                    </div>
                                ` : ''}
                            </div>
                        `;
                    }).join('')}
                </div>
            </div>
        `;
    }
    
    renderPerformanceView() {
        const status = this.automationSystem.getAutomationStatus();
        
        return `
            <div class="performance-content">
                <h3>üìà Performance Analytics</h3>
                
                <div class="performance-grid">
                    <div class="perf-card">
                        <h4>‚ö° Efficiency Metrics</h4>
                        <div class="metric-chart">
                            <div class="chart-bar">
                                <div class="bar-fill" style="width: ${status.efficiency.timesSaved * 10}%"></div>
                                <span class="bar-label">Time Saved: ${status.efficiency.timesSaved.toFixed(1)}h</span>
                            </div>
                            <div class="chart-bar">
                                <div class="bar-fill" style="width: ${status.efficiency.tasksAutomated * 2}%"></div>
                                <span class="bar-label">Tasks Automated: ${status.efficiency.tasksAutomated}</span>
                            </div>
                            <div class="chart-bar">
                                <div class="bar-fill error" style="width: ${status.efficiency.errorRate * 100}%"></div>
                                <span class="bar-label">Error Rate: ${(status.efficiency.errorRate * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="perf-card">
                        <h4>üéØ Quality Metrics</h4>
                        <div class="quality-display">
                            <div class="quality-circle">
                                <div class="circle-progress" style="--progress: ${status.quality.qualityScore * 100}%">
                                    <span class="quality-score">${Math.round(status.quality.qualityScore * 100)}%</span>
                                </div>
                            </div>
                            <div class="quality-details">
                                <div class="quality-item">
                                    <span>Customer Satisfaction:</span>
                                    <span>${Math.round(status.quality.customerSatisfaction * 100)}%</span>
                                </div>
                                <div class="quality-item">
                                    <span>Task Completion:</span>
                                    <span>${Math.round(status.quality.taskCompletionRate * 100)}%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="perf-card">
                        <h4>üí∞ Cost Analysis</h4>
                        <div class="cost-breakdown">
                            <div class="cost-item positive">
                                <span class="cost-label">Operational Savings</span>
                                <span class="cost-value">+${status.costs.operationalSavings}</span>
                            </div>
                            <div class="cost-item negative">
                                <span class="cost-label">Automation Costs</span>
                                <span class="cost-value">-${status.costs.automationCosts}</span>
                            </div>
                            <div class="cost-item ${status.costs.roi >= 0 ? 'positive' : 'negative'}">
                                <span class="cost-label">Return on Investment</span>
                                <span class="cost-value">${status.costs.roi.toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="performance-history">
                    <h4>üìä Performance History</h4>
                    <div class="history-chart">
                        ${this.renderPerformanceChart()}
                    </div>
                </div>
            </div>
        `;
    }
    
    renderAIAssistantView() {
        const aiReport = this.automationSystem.aiAssistant.getPerformanceReport();
        
        return `
            <div class="ai-assistant-content">
                <h3>üß† AI Assistant Manager</h3>
                
                <div class="ai-status-grid">
                    <div class="ai-card">
                        <h4>üéØ Decision Making</h4>
                        <div class="ai-metrics">
                            <div class="ai-metric">
                                <span class="metric-label">Decisions Made</span>
                                <span class="metric-value">${aiReport.decisionsMade}</span>
                            </div>
                            <div class="ai-metric">
                                <span class="metric-label">Success Rate</span>
                                <span class="metric-value">${Math.round(aiReport.successRate * 100)}%</span>
                            </div>
                            <div class="ai-metric">
                                <span class="metric-label">Confidence</span>
                                <span class="metric-value">${Math.round(aiReport.intelligence.confidence * 100)}%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="ai-card">
                        <h4>üß† Intelligence Profile</h4>
                        <div class="intelligence-bars">
                            <div class="intel-bar">
                                <span class="intel-label">Learning Rate</span>
                                <div class="intel-progress">
                                    <div class="intel-fill" style="width: ${aiReport.intelligence.learningRate * 100}%"></div>
                                </div>
                            </div>
                            <div class="intel-bar">
                                <span class="intel-label">Risk Tolerance</span>
                                <div class="intel-progress">
                                    <div class="intel-fill" style="width: ${aiReport.intelligence.riskTolerance * 100}%"></div>
                                </div>
                            </div>
                            <div class="intel-bar">
                                <span class="intel-label">Creativity</span>
                                <div class="intel-progress">
                                    <div class="intel-fill" style="width: ${aiReport.intelligence.creativityLevel * 100}%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="ai-card full-width">
                        <h4>üìã Recent Decisions</h4>
                        <div class="recent-decisions">
                            ${aiReport.recentDecisions.length > 0 ?
                                aiReport.recentDecisions.map(decision => `
                                    <div class="decision-item">
                                        <span class="decision-type">${decision.decision.type}</span>
                                        <span class="decision-context">${decision.decision.context?.description || 'Strategic decision'}</span>
                                        <span class="decision-confidence">${Math.round(decision.analysis.confidence * 100)}%</span>
                                    </div>
                                `).join('') :
                                '<div class="no-decisions">No recent decisions</div>'
                            }
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    renderSettingsView() {
        const settings = this.automationSystem.automationSettings;
        
        return `
            <div class="settings-content">
                <h3>üîß Automation Settings</h3>
                
                <div class="settings-sections">
                    ${Object.entries(settings).map(([systemId, systemSettings]) => `
                        <div class="settings-section">
                            <h4>${this.getSystemIcon(systemId)} ${this.getSystemName(systemId)}</h4>
                            <div class="settings-form">
                                ${this.renderSystemSettings(systemId, systemSettings)}
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div class="settings-actions">
                    <button class="btn-save" onclick="automationInterface.saveSettings()">
                        üíæ Save Settings
                    </button>
                    <button class="btn-reset" onclick="automationInterface.resetSettings()">
                        üîÑ Reset to Defaults
                    </button>
                </div>
            </div>
        `;
    }
    
    renderSystemSettings(systemId, settings) {
        // Different settings for different systems
        switch (systemId) {
            case 'customerService':
                return `
                    <div class="setting-item">
                        <label>Quality Level:</label>
                        <select onchange="automationInterface.updateSetting('${systemId}', 'quality', this.value)">
                            <option value="basic" ${settings.quality === 'basic' ? 'selected' : ''}>Basic</option>
                            <option value="standard" ${settings.quality === 'standard' ? 'selected' : ''}>Standard</option>
                            <option value="premium" ${settings.quality === 'premium' ? 'selected' : ''}>Premium</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Personal Touch:</label>
                        <input type="range" min="0" max="1" step="0.1" value="${settings.personalTouch}"
                               onchange="automationInterface.updateSetting('${systemId}', 'personalTouch', this.value)">
                        <span>${Math.round(settings.personalTouch * 100)}%</span>
                    </div>
                `;
            case 'inventory':
                return `
                    <div class="setting-item">
                        <label>Auto Restock:</label>
                        <input type="checkbox" ${settings.autoRestock ? 'checked' : ''}
                               onchange="automationInterface.updateSetting('${systemId}', 'autoRestock', this.checked)">
                    </div>
                    <div class="setting-item">
                        <label>Reorder Point:</label>
                        <input type="range" min="0.1" max="0.5" step="0.05" value="${settings.reorderPoint}"
                               onchange="automationInterface.updateSetting('${systemId}', 'reorderPoint', this.value)">
                        <span>${Math.round(settings.reorderPoint * 100)}%</span>
                    </div>
                    <div class="setting-item">
                        <label>Budget Limit:</label>
                        <input type="number" min="100" max="5000" step="100" value="${settings.budgetLimit}"
                               onchange="automationInterface.updateSetting('${systemId}', 'budgetLimit', this.value)">
                    </div>
                `;
            default:
                return `<div class="no-settings">No configurable settings for this system</div>`;
        }
    }
    
    renderAlerts() {
        if (this.alerts.length === 0) {
            return '<div class="no-alerts">No active alerts</div>';
        }
        
        return `
            <div class="alerts-container">
                <h4>üîî System Alerts</h4>
                <div class="alerts-list">
                    ${this.alerts.slice(0, 5).map((alert, index) => `
                        <div class="alert-item ${alert.type} ${alert.priority}">
                            <span class="alert-icon">${this.getAlertIcon(alert.type)}</span>
                            <span class="alert-message">${alert.message}</span>
                            <span class="alert-time">${this.getTimeAgo(alert.timestamp)}</span>
                            <button class="alert-dismiss" onclick="automationInterface.dismissAlert(${index})">√ó</button>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }
    
    // UI Event Handlers
    switchView(viewId) {
        this.activeView = viewId;
        this.refreshUI();
    }
    
    async toggleSystem(systemId) {
        const status = this.automationSystem.getAutomationStatus();
        
        if (status.active.includes(systemId)) {
            await this.automationSystem.disableAutomation(systemId);
        } else {
            await this.automationSystem.enableAutomation(systemId);
        }
        
        this.refreshUI();
    }
    
    configureSystem(systemId) {
        this.selectedSystem = systemId;
        this.switchView('settings');
    }
    
    async handleRecommendation(systemId, action) {
        if (action === 'enable') {
            await this.automationSystem.enableAutomation(systemId);
        }
        this.refreshUI();
    }
    
    emergencyShutdown() {
        if (confirm('Are you sure you want to shut down all automation systems?')) {
            this.automationSystem.emergencyShutdown('User initiated emergency shutdown');
            this.addAlert({
                type: 'warning',
                message: 'All automation systems have been shut down',
                priority: 'high'
            });
            this.refreshUI();
        }
    }
    
    updateSetting(systemId, settingName, value) {
        const numericValue = !isNaN(value) ? parseFloat(value) : value;
        this.automationSystem.configureAutomation(systemId, { [settingName]: numericValue });
    }
    
    saveSettings() {
        this.addAlert({
            type: 'success',
            message: 'Settings saved successfully',
            priority: 'low'
        });
    }
    
    resetSettings() {
        if (confirm('Reset all settings to defaults?')) {
            // Implementation would reset all settings
            this.addAlert({
                type: 'info',
                message: 'Settings reset to defaults',
                priority: 'low'
            });
        }
    }
    
    dismissAlert(index) {
        this.alerts.splice(index, 1);
        this.refreshUI();
    }
    
    // Helper Methods
    getSystemIcon(systemId) {
        const icons = {
            customerService: 'ü§ñ',
            inventory: 'üì¶',
            maintenance: 'üîß',
            security: 'üõ°Ô∏è',
            aiAssistant: 'üß†'
        };
        return icons[systemId] || '‚öôÔ∏è';
    }
    
    getSystemName(systemId) {
        const names = {
            customerService: 'Customer Service',
            inventory: 'Inventory Management',
            maintenance: 'Maintenance',
            security: 'Security Monitoring',
            aiAssistant: 'AI Assistant'
        };
        return names[systemId] || systemId;
    }
    
    getAlertIcon(type) {
        const icons = {
            success: '‚úÖ',
            warning: '‚ö†Ô∏è',
            error: '‚ùå',
            info: '‚ÑπÔ∏è',
            recommendation: 'üí°'
        };
        return icons[type] || '‚ÑπÔ∏è';
    }
    
    getOverallStatus() {
        const status = this.automationSystem.getAutomationStatus();
        if (status.active.length === 0) return 'offline';
        if (status.quality.qualityScore > 0.8) return 'optimal';
        if (status.quality.qualityScore > 0.6) return 'good';
        return 'warning';
    }
    
    getSystemCount() {
        return this.automationSystem.getAutomationStatus().active.length;
    }
    
    getTimeAgo(timestamp) {
        const now = Date.now();
        const diff = now - timestamp;
        const minutes = Math.floor(diff / 60000);
        if (minutes < 1) return 'Just now';
        if (minutes < 60) return `${minutes}m ago`;
        const hours = Math.floor(minutes / 60);
        return `${hours}h ago`;
    }
    
    renderPerformanceChart() {
        // Simplified chart representation
        return `
            <div class="chart-placeholder">
                <div class="chart-line">üìà Performance trending upward</div>
                <div class="chart-data">
                    <span>Efficiency: +15% this week</span>
                    <span>Quality: Stable at 88%</span>
                    <span>Costs: -$200 savings</span>
                </div>
            </div>
        `;
    }
    
    // Data Management
    refreshSystemData() {
        this.systemStatus = this.automationSystem.getAutomationStatus();
        this.performanceData = this.automationSystem.automationMetrics;
    }
    
    refreshPerformanceDisplay() {
        // Update performance displays without full refresh
        const perfElements = document.querySelectorAll('.metric-value, .status-value');
        // Implementation would update specific elements
    }
    
    handleSystemStatusChange(systemId, status) {
        this.addAlert({
            type: status === 'enabled' ? 'success' : 'info',
            message: `${this.getSystemName(systemId)} automation ${status}`,
            priority: 'medium'
        });
        this.refreshSystemData();
        this.refreshUI();
    }
    
    updateSystemPerformance(systemId, metrics) {
        // Update performance tracking for specific system
        if (!this.performanceData[systemId]) {
            this.performanceData[systemId] = {};
        }
        Object.assign(this.performanceData[systemId], metrics);
    }
    
    addAlert(alert) {
        alert.timestamp = Date.now();
        this.alerts.unshift(alert);
        // Keep only last 20 alerts
        if (this.alerts.length > 20) {
            this.alerts = this.alerts.slice(0, 20);
        }
    }
    
    refreshUI() {
        if (this.initialized) {
            const container = document.querySelector('.automation-interface');
            if (container) {
                container.outerHTML = this.render();
            }
        }
    }
}

// Export for use in other modules
if (typeof window !== 'undefined') {
    window.AutomationInterface = AutomationInterface;
} else if (typeof module !== 'undefined' && module.exports) {
    module.exports = AutomationInterface;
}


/* === scripts/workstation/workstationManager.js === */
/**
 * Work Computer System - Main interface for business management
 * Provides tabbed interface with various business applications
 */

class WorkComputer {
    constructor() {
        this.eventBus = null;
        this.gameState = null;
        this.container = null;
        this.isBooted = false;
        this.isPoweredOn = false;
        this.currentApp = null;
    this.initialized = false;
    // Track open windows for external apps expecting a Map API
    this.openWindows = new Map();
        this.staffActiveTab = 'management'; // Default to management tab for Phase 5B
        
        this.state = {
            activeWindows: [],
            minimizedWindows: [],
            desktop: {
                wallpaper: 'default',
                icons: []
            },
            taskbar: {
                apps: [],
                notifications: []
            }
        };

        // Available applications
        this.applications = {
            npc_manager: {
                name: 'Customer Relations',
                icon: 'üë•',
                description: 'Manage customer profiles and relationships',
                component: 'NPCManagerApp',
                isInstalled: true,
                position: { x: 50, y: 50 }
            },
            inventory_manager: {
                name: 'Inventory Management',
                icon: 'üì¶',
                description: 'Track products, stock levels, and orders',
                component: 'InventoryManagerApp',
                isInstalled: true,
                position: { x: 150, y: 50 }
            },
            financial_reports: {
                name: 'Financial Reports',
                icon: 'üìä',
                description: 'View financial reports and analytics',
                component: 'FinancialReportsApp',
                isInstalled: true,
                position: { x: 250, y: 50 }
            },
            social_media: {
                name: 'Social Hub',
                icon: 'üì±',
                description: 'Manage social media and online presence',
                component: 'SocialMediaApp',
                isInstalled: true,
                position: { x: 350, y: 50 }
            },
            bank_manager: {
                name: 'Banking',
                icon: 'üè¶',
                description: 'Manage accounts, loans, and investments',
                component: 'BankManagerApp',
                isInstalled: true,
                position: { x: 50, y: 150 }
            },
            staff_scheduler: {
                name: 'Staff Management',
                icon: 'üëî',
                description: 'Schedule staff and manage HR',
                component: 'StaffSchedulerApp',
                isInstalled: true,
                position: { x: 150, y: 150 }
            },
            security_monitor: {
                name: 'Security Monitor',
                icon: 'üîí',
                description: 'Monitor security cameras and incidents',
                component: 'SecurityMonitorApp',
                isInstalled: false, // Unlocked later
                position: { x: 250, y: 150 }
            },
            settings: {
                name: 'Settings',
                icon: '‚öôÔ∏è',
                description: 'System settings and preferences',
                component: 'SettingsApp',
                isInstalled: true,
                position: { x: 350, y: 150 }
            }
        };
    }

    initialize(eventBus, gameState) {
        this.eventBus = eventBus;
        this.gameState = gameState;
        // Mount point: prefer dedicated desktop area, else whole computer view
        this.container = document.getElementById('computer-desktop') || document.getElementById('computer-view');
        this.initialized = true;

        // Listen for computer events
        this.eventBus.on('computer.powerOn', () => this.powerOn());
        this.eventBus.on('computer.powerOff', () => this.powerOff());
        this.eventBus.on('computer.openApp', (data) => this.openApplication(data.appId));
        this.eventBus.on('computer.closeApp', (data) => this.closeApplication(data.windowId));
        this.eventBus.on('computer.minimizeApp', (data) => this.minimizeApplication(data.windowId));
        this.eventBus.on('computer.maximizeApp', (data) => this.maximizeApplication(data.windowId));
        this.eventBus.on('ui.showWorkComputer', () => this.show());
        this.eventBus.on('ui.hideWorkComputer', () => this.hide());

        // Listen for computer close event from main UI
        if (typeof gameEventBus !== 'undefined') {
            gameEventBus.on(GAME_EVENTS.COMPUTER_CLOSED, () => {
                this.powerOff();
                if (typeof uiManager !== 'undefined') {
                    uiManager.showView('store');
                    gameState.setView(GAME_CONSTANTS.VIEWS.STORE);
                }
            });
        }

        // Setup keyboard shortcuts
        this.setupKeyboardEvents();

        // Wire legacy close button if present
        const closeBtn = document.getElementById('close-computer');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                if (typeof gameEventBus !== 'undefined' && typeof GAME_EVENTS !== 'undefined') {
                    gameEventBus.emit(GAME_EVENTS.COMPUTER_CLOSED);
                }
            });
        }

        // Initial render
        this.updateDisplay();

        console.log('üíª Work Computer System initialized');
    }

    setupKeyboardEvents() {
        document.addEventListener('keydown', (e) => {
            // Only handle keyboard events when computer is visible and focused
            const computerView = document.getElementById('computer-view');
            if (!computerView || computerView.classList.contains('hidden')) {
                return;
            }

            // Escape key to exit computer
            if (e.key === 'Escape') {
                e.preventDefault();
                gameEventBus.emit(GAME_EVENTS.COMPUTER_CLOSED);
            }

            // Alt+Tab to switch between open applications
            if (e.altKey && e.key === 'Tab') {
                e.preventDefault();
                this.switchToNextApplication();
            }
        });
    }

    switchToNextApplication() {
        const runningApps = Array.from(this.openWindows.keys());
        if (runningApps.length <= 1) return;

        const currentFocused = this.focusedWindow;
        const currentIndex = runningApps.indexOf(currentFocused);
        const nextIndex = (currentIndex + 1) % runningApps.length;
        const nextApp = runningApps[nextIndex];

        this.focusWindow(nextApp);
    }

    render() {
        if (this.container && this.container.id === 'computer-desktop') {
            return this.renderForContainer();
        }
        if (!this.isPoweredOn) {
            return this.renderPoweredOff();
        }
        if (!this.isBooted) {
            return this.renderBootSequence();
        }
        return this.renderDesktop();
    }

    renderForContainer() {
        // Render content tailored for the #computer-desktop area (no extra wrappers)
        if (!this.isPoweredOn) {
            return `
                <div class="powered-off-overlay">
                    <div class="power-button-container">
                        <button class="power-button" onclick="workComputer.powerOn()">
                            <div class="power-icon">‚ö°</div>
                            <span>Power On</span>
                        </button>
                    </div>
                </div>
            `;
        }
        if (!this.isBooted) {
            return `
                <div class="boot-sequence">
                    <div class="boot-logo">
                        <div class="logo-icon">üíª</div>
                        <h2>StoreOS</h2>
                        <div class="version">Business Management Suite v2.1</div>
                    </div>
                    <div class="boot-progress">
                        <div class="progress-bar"><div class="progress-fill" id="boot-progress"></div></div>
                        <div class="boot-status" id="boot-status">Initializing system...</div>
                    </div>
                    <div class="boot-messages" id="boot-messages"></div>
                </div>
            `;
        }
        // Booted desktop inner contents
        return `
            <div class="desktop-wallpaper ${this.state.desktop.wallpaper}">
                <div class="desktop-icons">${this.renderDesktopIcons()}</div>
                <div class="window-container">${this.state.activeWindows.map(w => this.renderWindow(w)).join('')}</div>
                <div class="taskbar">
                    <div class="taskbar-start">
                        <button class="start-button" onclick="workComputer.toggleStartMenu()">
                            <span class="start-icon">üè™</span>
                            <span class="start-text">Start</span>
                        </button>
                    </div>
                    <div class="taskbar-apps">${this.renderTaskbarApps()}</div>
                    <div class="taskbar-system">
                        <div class="system-notifications">${this.renderNotifications()}</div>
                        <div class="system-clock">${this.renderSystemClock()}</div>
                        <button class="power-menu-btn" onclick="workComputer.showPowerMenu()">‚ö°</button>
                    </div>
                </div>
                <div class="start-menu hidden" id="start-menu">${this.renderStartMenu()}</div>
            </div>
        `;
    }

    renderPoweredOff() {
        return `
            <div id="work-computer" class="work-computer powered-off">
                <div class="computer-screen off">
                    <div class="power-button-container">
                        <button class="power-button" onclick="workComputer.powerOn()">
                            <div class="power-icon">‚ö°</div>
                            <span>Power On</span>
                        </button>
                    </div>
                </div>
            </div>
        `;
    }

    renderBootSequence() {
        return `
            <div id="work-computer" class="work-computer booting">
                <div class="computer-screen">
                    <div class="boot-sequence">
                        <div class="boot-logo">
                            <div class="logo-icon">üíª</div>
                            <h2>StoreOS</h2>
                            <div class="version">Business Management Suite v2.1</div>
                        </div>
                        
                        <div class="boot-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" id="boot-progress"></div>
                            </div>
                            <div class="boot-status" id="boot-status">Initializing system...</div>
                        </div>

                        <div class="boot-messages" id="boot-messages">
                            <div class="boot-message">Loading drivers...</div>
                            <div class="boot-message">Checking network connection...</div>
                            <div class="boot-message">Starting business applications...</div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    renderDesktop() {
        return `
            <div id="work-computer" class="work-computer desktop">
                <div class="computer-screen">
                    <!-- Desktop Wallpaper -->
                    <div class="desktop-wallpaper ${this.state.desktop.wallpaper}">
                        
                        <!-- Desktop Icons -->
                        <div class="desktop-icons">
                            ${this.renderDesktopIcons()}
                        </div>

                        <!-- Active Windows -->
                        <div class="window-container">
                            ${this.state.activeWindows.map(window => this.renderWindow(window)).join('')}
                        </div>

                        <!-- Taskbar -->
                        <div class="taskbar">
                            <div class="taskbar-start">
                                <button class="start-button" onclick="workComputer.toggleStartMenu()">
                                    <span class="start-icon">üè™</span>
                                    <span class="start-text">Start</span>
                                </button>
                            </div>

                            <div class="taskbar-apps">
                                ${this.renderTaskbarApps()}
                            </div>

                            <div class="taskbar-system">
                                <div class="system-notifications">
                                    ${this.renderNotifications()}
                                </div>
                                <div class="system-clock">
                                    ${this.renderSystemClock()}
                                </div>
                                <button class="power-menu-btn" onclick="workComputer.showPowerMenu()">
                                    ‚ö°
                                </button>
                            </div>
                        </div>

                        <!-- Start Menu -->
                        <div class="start-menu hidden" id="start-menu">
                            ${this.renderStartMenu()}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    renderDesktopIcons() {
        return Object.entries(this.applications)
            .filter(([id, app]) => app.isInstalled)
            .map(([id, app]) => `
                <div class="desktop-icon" 
                     style="left: ${app.position.x}px; top: ${app.position.y}px;"
                     ondblclick="workComputer.openApplication('${id}')"
                     data-app-id="${id}">
                    <div class="icon-image">${app.icon}</div>
                    <div class="icon-label">${app.name}</div>
                </div>
            `).join('');
    }

    renderWindow(window) {
        return `
            <div class="app-window ${window.state}" 
                 id="window-${window.id}"
                 style="left: ${window.x}px; top: ${window.y}px; width: ${window.width}px; height: ${window.height}px; z-index: ${window.zIndex};"
                 onclick="workComputer.focusWindow('${window.id}')">
                
                <div class="window-titlebar" onmousedown="workComputer.startDrag(event, '${window.id}')">
                    <div class="window-title">
                        <span class="window-icon">${window.icon}</span>
                        <span class="window-name">${window.title}</span>
                    </div>
                    <div class="window-controls">
                        <button class="window-btn minimize" onclick="workComputer.minimizeApplication('${window.id}')">‚àí</button>
                        <button class="window-btn maximize" onclick="workComputer.toggleMaximize('${window.id}')">‚ñ°</button>
                        <button class="window-btn close" onclick="workComputer.closeApplication('${window.id}')">√ó</button>
                    </div>
                </div>

                <div class="window-content">
                    <div id="app-content-${window.id}" class="app-content">
                        ${window.content ? window.content : this.renderApplicationContent(window.appId, window.id)}
                    </div>
                </div>
            </div>
        `;
    }

    renderApplicationContent(appId, windowId) {
        // This will be populated by specific application components
        switch (appId) {
            case 'npc_manager':
                // Launch Customer Relations App
                if (typeof customerRelationsApp !== 'undefined') {
                    setTimeout(() => customerRelationsApp.open(), 100);
                    return '<div class="app-loading">Launching Customer Relations...</div>';
                }
                return '<div class="app-placeholder">Customer Relations Manager<br/>Loading...</div>';
            case 'inventory_manager':
                // Launch Inventory Management App
                if (typeof inventoryManagementApp !== 'undefined') {
                    setTimeout(() => inventoryManagementApp.open(), 100);
                    return '<div class="app-loading">Launching Inventory Management...</div>';
                }
                return '<div class="app-placeholder">Inventory Management System<br/>Loading...</div>';
            case 'financial_reports':
                return '<div class="app-placeholder">Financial Reports Dashboard<br/>Loading...</div>';
            case 'social_media':
                return '<div class="app-placeholder">Social Media Hub<br/>Loading...</div>';
            case 'bank_manager':
                return '<div class="app-placeholder">Banking & Investments<br/>Loading...</div>';
            case 'staff_scheduler':
                return this.renderStaffHiringApp();
            case 'security_monitor':
                return '<div class="app-placeholder">Security Monitor<br/>Loading...</div>';
            case 'settings':
                return '<div class="app-placeholder">System Settings<br/>Loading...</div>';
            default:
                return '<div class="app-placeholder">Unknown Application</div>';
        }
    }

    renderStaffHiringApp() {
        // Initialize Staff Hiring System if not already done
        if (!this.staffHiringSystem) {
            this.staffHiringSystem = new StaffHiringSystem();
            this.staffHiringInterface = new StaffHiringInterface();
            
            // Initialize with dependencies
            this.staffHiringSystem.initialize(
                this.gameState, 
                this.eventBus, 
                this.gameState.npcSystem, 
                this.gameState.aiContentManager
            );
            
            this.staffHiringInterface.initialize(
                this.staffHiringSystem,
                this.gameState,
                this.eventBus
            );
        }

        // Initialize Staff Management System (Phase 5B)
        if (!this.staffManagementSystem) {
            this.staffManagementSystem = new StaffManagementSystem();
            this.staffManagementInterface = new StaffManagementInterface();
            
            // Initialize with dependencies
            this.staffManagementSystem.initialize(
                this.gameState,
                this.eventBus,
                this.staffHiringSystem,
                this.gameState.timeSystem
            );
            
            this.staffManagementInterface.initialize(
                this.staffManagementSystem,
                this.staffHiringSystem,
                this.gameState,
                this.eventBus
            );
        }

        // Initialize Automation System (Phase 5C)
        if (!this.automationSystem) {
            this.automationSystem = new AutomationSystem();
            this.automationInterface = new AutomationInterface();
            
            // Initialize automation with all required systems
            this.automationSystem.initialize(
                this.gameState,
                this.eventBus,
                this.staffManagementSystem,
                this.gameState.customerSystem,
                this.gameState.inventorySystem
            );
            
            this.automationInterface.initialize(
                this.automationSystem,
                this.gameState,
                this.eventBus
            );
        }
        
        // Check if we have hired staff - show management interface, otherwise show hiring
        const hasStaff = this.gameState.staff?.employees?.length > 0;
        
        if (hasStaff) {
            return `
                <div class="staff-app-container">
                    <div class="staff-app-tabs">
                        <button class="staff-tab ${this.staffActiveTab === 'management' ? 'active' : ''}" 
                                onclick="workComputer.switchStaffTab('management')">
                            üìä Management
                        </button>
                        <button class="staff-tab ${this.staffActiveTab === 'hiring' ? 'active' : ''}" 
                                onclick="workComputer.switchStaffTab('hiring')">
                            üëî Hiring
                        </button>
                        <button class="staff-tab ${this.staffActiveTab === 'automation' ? 'active' : ''}" 
                                onclick="workComputer.switchStaffTab('automation')">
                            ü§ñ Automation
                        </button>
                    </div>
                    <div class="staff-app-content">
                        ${this.staffActiveTab === 'management' ? 
                            this.staffManagementInterface.render() : 
                            this.staffActiveTab === 'automation' ?
                            this.automationInterface.render() :
                            this.staffHiringInterface.render()
                        }
                    </div>
                </div>
            `;
        } else {
            // No staff yet - show hiring interface only
            return this.staffHiringInterface.render();
        }
    }

    switchStaffTab(tab) {
        this.staffActiveTab = tab;
        const contentElement = document.querySelector('.staff-app-content');
        if (contentElement) {
            if (tab === 'management') {
                contentElement.innerHTML = this.staffManagementInterface.render();
            } else if (tab === 'automation') {
                contentElement.innerHTML = this.automationInterface.render();
            } else {
                contentElement.innerHTML = this.staffHiringInterface.render();
            }
        }
    }

    renderTaskbarApps() {
        return this.state.activeWindows.map(window => `
            <button class="taskbar-app ${window.state === 'minimized' ? 'minimized' : 'active'}"
                    onclick="workComputer.restoreWindow('${window.id}')"
                    title="${window.title}">
                <span class="app-icon">${window.icon}</span>
                <span class="app-title">${window.title}</span>
            </button>
        `).join('');
    }

    renderNotifications() {
        return this.state.taskbar.notifications.map(notification => `
            <div class="notification-icon ${notification.type}" title="${notification.message}">
                ${notification.icon}
            </div>
        `).join('');
    }

    renderSystemClock() {
        const now = new Date();
        return `
            <div class="clock">
                <div class="time">${now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                <div class="date">${now.toLocaleDateString([], { month: 'short', day: 'numeric' })}</div>
            </div>
        `;
    }

    renderStartMenu() {
        return `
            <div class="start-menu-content">
                <div class="start-menu-header">
                    <h3>Business Applications</h3>
                </div>
                
                <div class="start-menu-apps">
                    ${Object.entries(this.applications)
                        .filter(([id, app]) => app.isInstalled)
                        .map(([id, app]) => `
                            <div class="start-menu-item" onclick="workComputer.openApplication('${id}')">
                                <span class="start-item-icon">${app.icon}</span>
                                <div class="start-item-content">
                                    <div class="start-item-name">${app.name}</div>
                                    <div class="start-item-description">${app.description}</div>
                                </div>
                            </div>
                        `).join('')}
                </div>

                <div class="start-menu-footer">
                    <button class="start-footer-btn" onclick="workComputer.showSettings()">
                        <span>‚öôÔ∏è</span> Settings
                    </button>
                    <button class="start-footer-btn" onclick="workComputer.powerOff()">
                        <span>‚ö°</span> Shutdown
                    </button>
                </div>
            </div>
        `;
    }

    // Core functionality methods
    powerOn() {
        if (this.isPoweredOn) return;

        this.isPoweredOn = true;
        this.isBooted = false;
        this.updateDisplay();

        // Simulate boot sequence
        this.startBootSequence();
    }

    powerOff() {
        // Close all applications
        this.state.activeWindows.forEach(window => {
            this.eventBus.emit(`app.${window.appId}.close`, { windowId: window.id });
        });

        this.state.activeWindows = [];
        this.state.minimizedWindows = [];
        this.isPoweredOn = false;
        this.isBooted = false;
        this.currentApp = null;

        this.updateDisplay();
        this.eventBus.emit('computer.powerOff', {});
    }

    startBootSequence() {
        const bootMessages = [
            'Loading system drivers...',
            'Checking network connectivity...',
            'Initializing business applications...',
            'Loading customer database...',
            'Connecting to financial systems...',
            'Starting inventory management...',
            'System ready!'
        ];

        let currentMessage = 0;
        let progress = 0;

        const bootInterval = setInterval(() => {
            progress += 15 + Math.random() * 10;
            
            if (currentMessage < bootMessages.length) {
                const bootMessagesEl = document.getElementById('boot-messages');
                if (bootMessagesEl) {
                    bootMessagesEl.innerHTML += `<div class="boot-message">${bootMessages[currentMessage]}</div>`;
                }
                currentMessage++;
            }

            const progressEl = document.getElementById('boot-progress');
            const statusEl = document.getElementById('boot-status');
            
            if (progressEl) {
                progressEl.style.width = Math.min(progress, 100) + '%';
            }
            
            if (statusEl && currentMessage < bootMessages.length) {
                statusEl.textContent = bootMessages[currentMessage] || 'Starting system...';
            }

            if (progress >= 100) {
                clearInterval(bootInterval);
                setTimeout(() => {
                    this.isBooted = true;
                    this.updateDisplay();
                    this.eventBus.emit('computer.booted', {});
                }, 1000);
            }
        }, 500);
    }

    openApplication(appOrConfig) {
        // Support opening by appId (string) or a custom window config (object)
        if (typeof appOrConfig === 'object' && appOrConfig !== null) {
            const cfg = appOrConfig;
            const win = {
                id: cfg.id || this.generateWindowId(),
                appId: cfg.appId || cfg.id || 'custom',
                title: cfg.title || 'Application',
                icon: cfg.icon || 'ü™ü',
                x: cfg.x ?? (100 + (this.state.activeWindows.length * 30)),
                y: cfg.y ?? (50 + (this.state.activeWindows.length * 30)),
                width: cfg.width ?? 800,
                height: cfg.height ?? 600,
                content: cfg.content || '',
                state: 'normal',
                zIndex: 1000 + this.state.activeWindows.length
            };
            this.state.activeWindows.push(win);
            this.openWindows.set(win.id, win);
            this.currentApp = win.appId;
            this.updateDisplay();
            this.eventBus.emit('computer.appOpened', { appId: win.appId, windowId: win.id });
            return;
        }

        const appId = appOrConfig;
        const app = this.applications[appId];
        if (!app || !app.isInstalled) return;

        // Check if app is already open
        const existingWindow = this.state.activeWindows.find(w => w.appId === appId);
        if (existingWindow) {
            this.focusWindow(existingWindow.id);
            return;
        }

        // Create new window
        const win = {
            id: this.generateWindowId(),
            appId: appId,
            title: app.name,
            icon: app.icon,
            x: 100 + (this.state.activeWindows.length * 30),
            y: 50 + (this.state.activeWindows.length * 30),
            width: 800,
            height: 600,
            state: 'normal', // normal, minimized, maximized
            zIndex: 1000 + this.state.activeWindows.length
        };

        this.state.activeWindows.push(win);
        this.openWindows.set(win.id, win);
        this.currentApp = appId;
        this.updateDisplay();

        // Notify the application that it's being opened
        this.eventBus.emit(`app.${appId}.open`, { windowId: win.id });
        this.eventBus.emit('computer.appOpened', { appId, windowId: win.id });
    }

    closeApplication(windowId) {
        const windowIndex = this.state.activeWindows.findIndex(w => w.id === windowId);
        if (windowIndex === -1) return;

        const window = this.state.activeWindows[windowIndex];
        
        // Notify the application that it's being closed
        this.eventBus.emit(`app.${window.appId}.close`, { windowId });
        
        // Remove from active windows
        this.state.activeWindows.splice(windowIndex, 1);
        this.openWindows.delete(windowId);
        
        // Also remove from minimized if it was there
        const minIndex = this.state.minimizedWindows.findIndex(w => w.id === windowId);
        if (minIndex !== -1) {
            this.state.minimizedWindows.splice(minIndex, 1);
        }

        this.updateDisplay();
        this.eventBus.emit('computer.appClosed', { windowId, appId: window.appId });
    }

    minimizeApplication(windowId) {
        const window = this.state.activeWindows.find(w => w.id === windowId);
        if (!window) return;

        window.state = 'minimized';
        this.updateDisplay();
    }

    maximizeApplication(windowId) {
        const window = this.state.activeWindows.find(w => w.id === windowId);
        if (!window) return;

        if (window.state === 'maximized') {
            window.state = 'normal';
            window.x = 100;
            window.y = 50;
            window.width = 800;
            window.height = 600;
        } else {
            window.state = 'maximized';
            window.x = 0;
            window.y = 0;
            window.width = window.parentWidth || 1200;
            window.height = (window.parentHeight || 800) - 40; // Account for taskbar
        }

        this.updateDisplay();
    }

    focusWindow(windowId) {
        const window = this.state.activeWindows.find(w => w.id === windowId);
        if (!window) return;

        // Bring window to front
        const maxZ = Math.max(...this.state.activeWindows.map(w => w.zIndex));
        window.zIndex = maxZ + 1;
        
        if (window.state === 'minimized') {
            window.state = 'normal';
        }

        this.updateDisplay();
    }

    restoreWindow(windowId) {
        const window = this.state.activeWindows.find(w => w.id === windowId);
        if (!window) return;

        if (window.state === 'minimized') {
            window.state = 'normal';
            this.focusWindow(windowId);
        } else {
            this.minimizeApplication(windowId);
        }
    }

    toggleStartMenu() {
        const startMenu = document.getElementById('start-menu');
        if (startMenu) {
            startMenu.classList.toggle('hidden');
        }
    }

    showPowerMenu() {
        this.eventBus.emit('ui.showModal', {
            type: 'power-menu',
            title: 'Power Options',
            content: `
                <div class="power-menu">
                    <button class="power-option" onclick="workComputer.powerOff(); ui.closeModal();">
                        <span class="power-icon">‚ö°</span>
                        <span class="power-text">Shutdown Computer</span>
                    </button>
                    <button class="power-option" onclick="workComputer.restart(); ui.closeModal();">
                        <span class="power-icon">üîÑ</span>
                        <span class="power-text">Restart System</span>
                    </button>
                    <button class="power-option" onclick="workComputer.standby(); ui.closeModal();">
                        <span class="power-icon">‚è∏Ô∏è</span>
                        <span class="power-text">Standby Mode</span>
                    </button>
                </div>
            `,
            buttons: [
                { text: 'Cancel', action: () => this.eventBus.emit('ui.closeModal') }
            ]
        });
    }

    addNotification(notification) {
        this.state.taskbar.notifications.push({
            id: Date.now(),
            icon: notification.icon,
            message: notification.message,
            type: notification.type || 'info',
            timestamp: new Date()
        });

        // Remove old notifications (keep last 5)
        if (this.state.taskbar.notifications.length > 5) {
            this.state.taskbar.notifications = this.state.taskbar.notifications.slice(-5);
        }

        this.updateDisplay();
    }

    // Utility methods
    generateWindowId() {
        return 'win_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    startDrag(event, windowId) {
        // Window dragging functionality would be implemented here
        event.preventDefault();
        console.log('Starting drag for window:', windowId);
    }

    toggleMaximize(windowId) {
        this.maximizeApplication(windowId);
    }

    show() {
        if (this.container) {
            this.container.classList.remove('hidden');
        }
    }

    hide() {
        if (this.container) {
            this.container.classList.add('hidden');
        }
    }

    updateDisplay() {
        if (this.container) {
            this.container.innerHTML = this.render();
        }

        // Update system clock every minute
        if (this.isBooted && this.isPoweredOn) {
            setTimeout(() => {
                const clockEl = document.querySelector('.system-clock .clock');
                if (clockEl) {
                    clockEl.innerHTML = this.renderSystemClock();
                }
            }, 1000);
        }
    }

    // Public API for external components
    getActiveWindows() {
        return [...this.state.activeWindows];
    }

    getApplications() {
        return { ...this.applications };
    }

    installApplication(appId, appConfig) {
        this.applications[appId] = {
            ...appConfig,
            isInstalled: true
        };
        this.updateDisplay();
    }

    uninstallApplication(appId) {
        if (this.applications[appId]) {
            // Close the app if it's open
            const window = this.state.activeWindows.find(w => w.appId === appId);
            if (window) {
                this.closeApplication(window.id);
            }
            
            this.applications[appId].isInstalled = false;
            this.updateDisplay();
        }
    }
}

// Initialize global work computer instance
let workComputer = null;

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = WorkComputer;
}


/* === scripts/workstation/apps/customerRelationsApp.js === */
// Customer Relations App - NPC Management System
class CustomerRelationsApp {
    constructor() {
        this.appId = 'customer-relations';
        this.appName = 'Customer Relations';
        this.appIcon = 'üë•';
        this.windowId = null;
        this.currentView = 'overview'; // overview, profile, search, history
        this.selectedNPC = null;
        this.searchFilters = {
            name: '',
            relationship: 'all',
            lastVisit: 'all',
            archetype: 'all'
        };
        
        // Sample NPC data - in real game this would come from npcSystem
        this.npcs = this.generateSampleNPCs();
    }

    // Initialize the app
    initialize() {
        console.log('üì± Customer Relations App initialized');
    }

    // Open the app window
    open() {
        if (this.windowId && workComputer.openWindows.has(this.windowId)) {
            workComputer.focusWindow(this.windowId);
            return;
        }

        this.windowId = `${this.appId}-${Date.now()}`;
        
        const windowConfig = {
            id: this.windowId,
            title: this.appName,
            icon: this.appIcon,
            width: 800,
            height: 600,
            x: 100,
            y: 100,
            content: this.renderContent(),
            onClose: () => this.close(),
            onMinimize: () => this.minimize(),
            onMaximize: () => this.maximize()
        };

        workComputer.openApplication(windowConfig);
        this.setupEventListeners();
    }

    // Close the app
    close() {
        if (this.windowId) {
            workComputer.closeApplication(this.windowId);
            this.windowId = null;
        }
    }

    // Minimize the app
    minimize() {
        workComputer.minimizeApplication(this.windowId);
    }

    // Maximize the app
    maximize() {
        workComputer.maximizeApplication(this.windowId);
    }

    // Render the main app content
    renderContent() {
        return `
            <div class="customer-relations-app">
                ${this.renderNavigation()}
                ${this.renderMainContent()}
            </div>
        `;
    }

    // Render navigation tabs
    renderNavigation() {
        return `
            <div class="app-navigation">
                <div class="nav-tabs">
                    <button class="nav-tab ${this.currentView === 'overview' ? 'active' : ''}" 
                            data-view="overview">
                        üìä Overview
                    </button>
                    <button class="nav-tab ${this.currentView === 'search' ? 'active' : ''}" 
                            data-view="search">
                        üîç Search & Filter
                    </button>
                    <button class="nav-tab ${this.currentView === 'history' ? 'active' : ''}" 
                            data-view="history">
                        üìö Interaction History
                    </button>
                </div>
                <div class="nav-actions">
                    <button class="btn btn-primary" id="add-customer-btn">
                        ‚ûï Add Customer Note
                    </button>
                    <button class="btn btn-secondary" id="export-data-btn">
                        üì§ Export Data
                    </button>
                </div>
            </div>
        `;
    }

    // Render main content based on current view
    renderMainContent() {
        switch (this.currentView) {
            case 'overview':
                return this.renderOverview();
            case 'search':
                return this.renderSearch();
            case 'profile':
                return this.renderProfile();
            case 'history':
                return this.renderHistory();
            default:
                return this.renderOverview();
        }
    }

    // Render overview dashboard
    renderOverview() {
        const totalCustomers = this.npcs.length;
        const regulars = this.npcs.filter(npc => npc.relationship >= 21).length;
        const vips = this.npcs.filter(npc => npc.relationship >= 81).length;
        const recentVisitors = this.npcs.filter(npc => 
            Date.now() - npc.lastVisit < 7 * 24 * 60 * 60 * 1000
        ).length;

        return `
            <div class="main-content overview-content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-icon">üë•</div>
                        <div class="stat-info">
                            <div class="stat-number">${totalCustomers}</div>
                            <div class="stat-label">Total Customers</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">‚≠ê</div>
                        <div class="stat-info">
                            <div class="stat-number">${regulars}</div>
                            <div class="stat-label">Regular Customers</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">üíé</div>
                        <div class="stat-info">
                            <div class="stat-number">${vips}</div>
                            <div class="stat-label">VIP Customers</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">üìÖ</div>
                        <div class="stat-info">
                            <div class="stat-number">${recentVisitors}</div>
                            <div class="stat-label">Recent Visitors</div>
                        </div>
                    </div>
                </div>

                <div class="customers-section">
                    <div class="section-header">
                        <h3>Customer Profiles</h3>
                        <div class="section-actions">
                            <select id="sort-customers" class="form-select">
                                <option value="name">Sort by Name</option>
                                <option value="relationship">Sort by Relationship</option>
                                <option value="lastVisit">Sort by Last Visit</option>
                                <option value="totalSpent">Sort by Total Spent</option>
                            </select>
                        </div>
                    </div>
                    <div class="customers-grid" id="customers-grid">
                        ${this.renderCustomerCards()}
                    </div>
                </div>
            </div>
        `;
    }

    // Render customer cards
    renderCustomerCards(filteredNPCs = null) {
        const npcsToShow = filteredNPCs || this.npcs;
        
        return npcsToShow.map(npc => `
            <div class="customer-card" data-npc-id="${npc.id}">
                <div class="customer-avatar">
                    <img src="${npc.avatar}" alt="${npc.name}" onerror="this.style.display='none'">
                    <div class="avatar-fallback">${npc.name.charAt(0)}</div>
                </div>
                <div class="customer-info">
                    <div class="customer-name">${npc.name}</div>
                    <div class="customer-archetype">${npc.archetype}</div>
                    <div class="relationship-meter">
                        <div class="relationship-bar">
                            <div class="relationship-fill" 
                                 style="width: ${npc.relationship}%; background: ${this.getRelationshipColor(npc.relationship)}">
                            </div>
                        </div>
                        <div class="relationship-label">${this.getRelationshipLabel(npc.relationship)}</div>
                    </div>
                    <div class="customer-stats">
                        <span class="stat">üí∞ ${npc.totalSpent}</span>
                        <span class="stat">üìÖ ${this.formatLastVisit(npc.lastVisit)}</span>
                        <span class="stat">üõí ${npc.visitCount} visits</span>
                    </div>
                </div>
                <div class="customer-actions">
                    <button class="btn btn-sm btn-primary" data-action="view-profile" data-npc-id="${npc.id}">
                        View Profile
                    </button>
                    <button class="btn btn-sm btn-secondary" data-action="add-note" data-npc-id="${npc.id}">
                        Add Note
                    </button>
                </div>
            </div>
        `).join('');
    }

    // Render search and filter interface
    renderSearch() {
        return `
            <div class="main-content search-content">
                <div class="search-panel">
                    <div class="search-section">
                        <h3>Search Customers</h3>
                        <div class="search-grid">
                            <div class="search-field">
                                <label for="search-name">Name</label>
                                <input type="text" id="search-name" class="form-input" 
                                       placeholder="Enter customer name..." 
                                       value="${this.searchFilters.name}">
                            </div>
                            <div class="search-field">
                                <label for="filter-relationship">Relationship Level</label>
                                <select id="filter-relationship" class="form-select">
                                    <option value="all">All Levels</option>
                                    <option value="stranger">Stranger (0-20)</option>
                                    <option value="regular">Regular (21-50)</option>
                                    <option value="friend">Friend (51-80)</option>
                                    <option value="vip">VIP (81-100)</option>
                                </select>
                            </div>
                            <div class="search-field">
                                <label for="filter-archetype">Customer Type</label>
                                <select id="filter-archetype" class="form-select">
                                    <option value="all">All Types</option>
                                    <option value="student">College Student</option>
                                    <option value="professional">Professional</option>
                                    <option value="retiree">Retiree</option>
                                    <option value="parent">Parent</option>
                                    <option value="teenager">Teenager</option>
                                </select>
                            </div>
                            <div class="search-field">
                                <label for="filter-last-visit">Last Visit</label>
                                <select id="filter-last-visit" class="form-select">
                                    <option value="all">Any Time</option>
                                    <option value="today">Today</option>
                                    <option value="week">This Week</option>
                                    <option value="month">This Month</option>
                                    <option value="older">Older</option>
                                </select>
                            </div>
                        </div>
                        <div class="search-actions">
                            <button id="apply-filters-btn" class="btn btn-primary">Apply Filters</button>
                            <button id="clear-filters-btn" class="btn btn-secondary">Clear All</button>
                        </div>
                    </div>
                </div>
                
                <div class="search-results">
                    <div class="results-header">
                        <h3>Search Results</h3>
                        <div class="results-count" id="results-count">
                            ${this.npcs.length} customers found
                        </div>
                    </div>
                    <div class="results-grid" id="search-results-grid">
                        ${this.renderCustomerCards()}
                    </div>
                </div>
            </div>
        `;
    }

    // Render individual customer profile
    renderProfile() {
        if (!this.selectedNPC) {
            return '<div class="main-content">No customer selected</div>';
        }

        const npc = this.selectedNPC;
        return `
            <div class="main-content profile-content">
                <div class="profile-header">
                    <button class="btn btn-back" id="back-to-overview">‚Üê Back to Overview</button>
                    <div class="profile-actions">
                        <button class="btn btn-primary" id="edit-profile-btn">Edit Profile</button>
                        <button class="btn btn-secondary" id="message-customer-btn">Send Message</button>
                    </div>
                </div>

                <div class="profile-main">
                    <div class="profile-card">
                        <div class="profile-avatar">
                            <img src="${npc.avatar}" alt="${npc.name}" onerror="this.style.display='none'">
                            <div class="avatar-fallback large">${npc.name.charAt(0)}</div>
                        </div>
                        <div class="profile-info">
                            <h2 class="profile-name">${npc.name}</h2>
                            <div class="profile-archetype">${npc.archetype}</div>
                            <div class="profile-relationship">
                                <div class="relationship-meter large">
                                    <div class="relationship-bar">
                                        <div class="relationship-fill" 
                                             style="width: ${npc.relationship}%; background: ${this.getRelationshipColor(npc.relationship)}">
                                        </div>
                                    </div>
                                    <div class="relationship-details">
                                        <span class="relationship-level">${this.getRelationshipLabel(npc.relationship)}</span>
                                        <span class="relationship-score">${npc.relationship}/100</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="profile-sections">
                        <div class="profile-section">
                            <h3>üìä Statistics</h3>
                            <div class="stats-list">
                                <div class="stat-item">
                                    <span class="stat-label">Total Spent:</span>
                                    <span class="stat-value">${npc.totalSpent}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Visit Count:</span>
                                    <span class="stat-value">${npc.visitCount}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Average Purchase:</span>
                                    <span class="stat-value">${(npc.totalSpent / Math.max(npc.visitCount, 1)).toFixed(2)}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Last Visit:</span>
                                    <span class="stat-value">${this.formatLastVisit(npc.lastVisit)}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Customer Since:</span>
                                    <span class="stat-value">${this.formatDate(npc.firstVisit)}</span>
                                </div>
                            </div>
                        </div>

                        <div class="profile-section">
                            <h3>üè∑Ô∏è Preferences & Notes</h3>
                            <div class="preferences-list">
                                <div class="preference-item">
                                    <span class="preference-label">Favorite Products:</span>
                                    <span class="preference-value">${npc.favoriteProducts.join(', ')}</span>
                                </div>
                                <div class="preference-item">
                                    <span class="preference-label">Shopping Times:</span>
                                    <span class="preference-value">${npc.preferredTimes.join(', ')}</span>
                                </div>
                                <div class="preference-item">
                                    <span class="preference-label">Payment Method:</span>
                                    <span class="preference-value">${npc.preferredPayment}</span>
                                </div>
                            </div>
                            <div class="notes-section">
                                <h4>Personal Notes</h4>
                                <div class="notes-content" contenteditable="true" id="customer-notes">
                                    ${npc.notes || 'Click to add notes about this customer...'}
                                </div>
                                <button class="btn btn-sm btn-primary" id="save-notes-btn">Save Notes</button>
                            </div>
                        </div>

                        ${this.renderAIEnhancedSections(npc)}

                        <div class="profile-section">
                            <h3>üí¨ Recent Interactions</h3>
                            <div class="interactions-list" id="interactions-list">
                                ${this.renderInteractionHistory(npc)}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    // Render interaction history
    renderInteractionHistory(npc) {
        const interactions = npc.interactions || [];
        
        if (interactions.length === 0) {
            return '<div class="no-interactions">No interactions recorded yet.</div>';
        }

        return interactions.map(interaction => `
            <div class="interaction-item">
                <div class="interaction-header">
                    <div class="interaction-type ${interaction.type}">
                        ${this.getInteractionIcon(interaction.type)} ${interaction.type}
                    </div>
                    <div class="interaction-date">${this.formatDate(interaction.date)}</div>
                </div>
                <div class="interaction-content">
                    ${interaction.description}
                </div>
                ${interaction.relationshipChange ? `
                    <div class="relationship-change ${interaction.relationshipChange > 0 ? 'positive' : 'negative'}">
                        ${interaction.relationshipChange > 0 ? '+' : ''}${interaction.relationshipChange} relationship
                    </div>
                ` : ''}
            </div>
        `).join('');
    }

    // Render full interaction history view
    renderHistory() {
        const allInteractions = [];
        this.npcs.forEach(npc => {
            if (npc.interactions) {
                npc.interactions.forEach(interaction => {
                    allInteractions.push({
                        ...interaction,
                        customerName: npc.name,
                        customerId: npc.id
                    });
                });
            }
        });

        // Sort by date, most recent first
        allInteractions.sort((a, b) => new Date(b.date) - new Date(a.date));

        return `
            <div class="main-content history-content">
                <div class="history-header">
                    <h3>üìö Complete Interaction History</h3>
                    <div class="history-filters">
                        <select id="history-filter-type" class="form-select">
                            <option value="all">All Interactions</option>
                            <option value="purchase">Purchases</option>
                            <option value="conversation">Conversations</option>
                            <option value="complaint">Complaints</option>
                            <option value="compliment">Compliments</option>
                        </select>
                        <select id="history-filter-period" class="form-select">
                            <option value="all">All Time</option>
                            <option value="today">Today</option>
                            <option value="week">This Week</option>
                            <option value="month">This Month</option>
                        </select>
                    </div>
                </div>
                
                <div class="history-timeline" id="history-timeline">
                    ${allInteractions.map(interaction => `
                        <div class="timeline-item">
                            <div class="timeline-marker ${interaction.type}"></div>
                            <div class="timeline-content">
                                <div class="timeline-header">
                                    <span class="customer-name" data-customer-id="${interaction.customerId}">
                                        ${interaction.customerName}
                                    </span>
                                    <span class="interaction-type">${interaction.type}</span>
                                    <span class="timeline-date">${this.formatDate(interaction.date)}</span>
                                </div>
                                <div class="timeline-description">
                                    ${interaction.description}
                                </div>
                                ${interaction.relationshipChange ? `
                                    <div class="timeline-relationship ${interaction.relationshipChange > 0 ? 'positive' : 'negative'}">
                                        Relationship ${interaction.relationshipChange > 0 ? '+' : ''}${interaction.relationshipChange}
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    // Render AI-enhanced sections for NPC profiles
    renderAIEnhancedSections(npc) {
        if (!npc.aiEnhanced && !npc.isEnriched) {
            return `
                <div class="profile-section ai-enhancement">
                    <h3>üß† AI Enhancement</h3>
                    <div class="enhancement-status">
                        <p>This customer profile can be enhanced with AI-generated details.</p>
                        <button class="btn btn-primary" onclick="customerRelationsApp.requestNPCEnrichment('${npc.id}')">
                            Enhance Profile
                        </button>
                    </div>
                </div>
            `;
        }

        let sections = '';

        // Backstory section
        if (npc.backstory) {
            sections += `
                <div class="profile-section">
                    <h3>üìñ Background Story</h3>
                    <div class="backstory-content">
                        ${npc.backstory}
                    </div>
                </div>
            `;
        }

        // Personality traits (new format)
        if (npc.personalityTraits && Object.keys(npc.personalityTraits).length > 0) {
            sections += `
                <div class="profile-section">
                    <h3>üé≠ Personality Profile</h3>
                    <div class="personality-traits">
                        ${Object.entries(npc.personalityTraits).map(([category, traits]) => `
                            <div class="trait-category">
                                <div class="trait-category-name">${this.formatCategoryName(category)}</div>
                                <div class="trait-tags">
                                    ${traits.map(trait => `<span class="trait-tag">${trait}</span>`).join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Behavior patterns
        if (npc.behaviorPatterns && Object.keys(npc.behaviorPatterns).length > 0) {
            sections += `
                <div class="profile-section">
                    <h3>üõçÔ∏è Shopping Behavior</h3>
                    <div class="behavior-patterns">
                        ${Object.entries(npc.behaviorPatterns).map(([type, data]) => `
                            <div class="behavior-item">
                                <div class="behavior-type">${this.formatBehaviorType(type)}</div>
                                <div class="behavior-description">${data.description || data}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Secrets and interesting facts
        if (npc.secrets && npc.secrets.length > 0) {
            sections += `
                <div class="profile-section">
                    <h3>üîç Insights & Secrets</h3>
                    <div class="secrets-list">
                        ${npc.secrets.map(secret => `
                            <div class="secret-item">
                                <span class="secret-icon">ü§´</span>
                                <span class="secret-text">${secret}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Relationship insights (new format)
        if (npc.relationshipData && npc.relationshipData.trajectory) {
            sections += `
                <div class="profile-section">
                    <h3>üíù Relationship Insights</h3>
                    <div class="relationship-insights">
                        <div class="insight-item">
                            <div class="insight-label">Initial Meeting:</div>
                            <div class="insight-content">${npc.relationshipData.initialMeeting}</div>
                        </div>
                        <div class="insight-item">
                            <div class="insight-label">Relationship Development:</div>
                            <div class="insight-content">${npc.relationshipData.trajectory}</div>
                        </div>
                        <div class="insight-item">
                            <div class="insight-label">Long-term Potential:</div>
                            <div class="insight-content">${npc.relationshipData.longTermPotential}</div>
                        </div>
                    </div>
                </div>
            `;
        }

        return sections;
    }

    // Helper methods for AI-enhanced data formatting
    formatCategoryName(category) {
        const categoryNames = {
            'social': 'üë• Social',
            'economic': 'üí∞ Economic',
            'emotional': 'üòä Emotional',
            'behavioral': 'üîÑ Behavioral',
            'quirks': 'üé≤ Quirks',
            'flaws': '‚ö†Ô∏è Flaws'
        };
        return categoryNames[category] || category.charAt(0).toUpperCase() + category.slice(1);
    }

    formatBehaviorType(type) {
        const typeNames = {
            'shopping': 'üõí Shopping Habits',
            'social': 'üëã Social Behavior',
            'decisionMaking': 'ü§î Decision Making',
            'payment': 'üí≥ Payment & Checkout'
        };
        return typeNames[type] || type.charAt(0).toUpperCase() + type.slice(1);
    }

    // Request NPC enrichment
    async requestNPCEnrichment(npcId) {
        if (typeof npcSystem !== 'undefined') {
            try {
                const button = event.target;
                button.disabled = true;
                button.textContent = 'Enhancing...';
                
                await npcSystem.enrichNPC(npcId);
                
                // Refresh the view
                this.refreshNPCData();
                this.switchView('profile');
            } catch (error) {
                console.error('Failed to enhance NPC:', error);
                button.disabled = false;
                button.textContent = 'Enhance Profile';
            }
        }
    }

    // Refresh NPC data
    refreshNPCData() {
        this.loadNPCs();
        if (this.currentView === 'profile' && this.selectedNPC) {
            // Find updated NPC
            this.selectedNPC = this.npcs.find(npc => npc.id === this.selectedNPC.id) || this.selectedNPC;
        }
        this.render();
    }

    // Setup event listeners for the app
    setupEventListeners() {
        const window = document.getElementById(this.windowId);
        if (!window) return;

        // Navigation tabs
        window.addEventListener('click', (e) => {
            if (e.target.classList.contains('nav-tab')) {
                const view = e.target.dataset.view;
                this.switchView(view);
            }

            // Customer card actions
            if (e.target.dataset.action === 'view-profile') {
                const npcId = e.target.dataset.npcId;
                this.viewProfile(npcId);
            }

            if (e.target.dataset.action === 'add-note') {
                const npcId = e.target.dataset.npcId;
                this.addNote(npcId);
            }

            // Back to overview
            if (e.target.id === 'back-to-overview') {
                this.switchView('overview');
            }

            // Apply filters
            if (e.target.id === 'apply-filters-btn') {
                this.applyFilters();
            }

            // Clear filters
            if (e.target.id === 'clear-filters-btn') {
                this.clearFilters();
            }

            // Save notes
            if (e.target.id === 'save-notes-btn') {
                this.saveNotes();
            }

            // Customer name click in history
            if (e.target.classList.contains('customer-name')) {
                const customerId = e.target.dataset.customerId;
                this.viewProfile(customerId);
            }
        });

        // Search input
        const searchInput = window.querySelector('#search-name');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                this.searchFilters.name = e.target.value;
                this.debounceSearch();
            });
        }

        // Sort dropdown
        const sortSelect = window.querySelector('#sort-customers');
        if (sortSelect) {
            sortSelect.addEventListener('change', (e) => {
                this.sortCustomers(e.target.value);
            });
        }
    }

    // Switch between different views
    switchView(view) {
        this.currentView = view;
        this.updateContent();
    }

    // Update the window content
    updateContent() {
        const window = document.getElementById(this.windowId);
        if (!window) return;

        const content = window.querySelector('.window-content');
        if (content) {
            content.innerHTML = this.renderContent();
            this.setupEventListeners();
        }
    }

    // View a specific customer profile
    viewProfile(npcId) {
        this.selectedNPC = this.npcs.find(npc => npc.id === npcId);
        if (this.selectedNPC) {
            this.switchView('profile');
        }
    }

    // Add a note for a customer
    addNote(npcId) {
        const npc = this.npcs.find(npc => npc.id === npcId);
        if (npc) {
            const note = prompt(`Add a note for ${npc.name}:`);
            if (note && note.trim()) {
                if (!npc.interactions) npc.interactions = [];
                npc.interactions.unshift({
                    type: 'note',
                    date: new Date().toISOString(),
                    description: `Note: ${note.trim()}`,
                    relationshipChange: 0
                });
                this.updateContent();
            }
        }
    }

    // Apply search filters
    applyFilters() {
        const window = document.getElementById(this.windowId);
        if (!window) return;

        // Get filter values
        this.searchFilters.name = window.querySelector('#search-name')?.value || '';
        this.searchFilters.relationship = window.querySelector('#filter-relationship')?.value || 'all';
        this.searchFilters.archetype = window.querySelector('#filter-archetype')?.value || 'all';
        this.searchFilters.lastVisit = window.querySelector('#filter-last-visit')?.value || 'all';

        // Filter NPCs
        const filtered = this.filterNPCs();
        
        // Update results
        const resultsGrid = window.querySelector('#search-results-grid');
        const resultsCount = window.querySelector('#results-count');
        
        if (resultsGrid) {
            resultsGrid.innerHTML = this.renderCustomerCards(filtered);
        }
        
        if (resultsCount) {
            resultsCount.textContent = `${filtered.length} customers found`;
        }
    }

    // Clear all filters
    clearFilters() {
        this.searchFilters = {
            name: '',
            relationship: 'all',
            lastVisit: 'all',
            archetype: 'all'
        };
        this.switchView('search');
    }

    // Filter NPCs based on current filters
    filterNPCs() {
        return this.npcs.filter(npc => {
            // Name filter
            if (this.searchFilters.name && 
                !npc.name.toLowerCase().includes(this.searchFilters.name.toLowerCase())) {
                return false;
            }

            // Relationship filter
            if (this.searchFilters.relationship !== 'all') {
                const relationship = npc.relationship;
                switch (this.searchFilters.relationship) {
                    case 'stranger':
                        if (relationship > 20) return false;
                        break;
                    case 'regular':
                        if (relationship < 21 || relationship > 50) return false;
                        break;
                    case 'friend':
                        if (relationship < 51 || relationship > 80) return false;
                        break;
                    case 'vip':
                        if (relationship < 81) return false;
                        break;
                }
            }

            // Archetype filter
            if (this.searchFilters.archetype !== 'all' && 
                !npc.archetype.toLowerCase().includes(this.searchFilters.archetype.toLowerCase())) {
                return false;
            }

            // Last visit filter
            if (this.searchFilters.lastVisit !== 'all') {
                const daysSinceVisit = (Date.now() - npc.lastVisit) / (24 * 60 * 60 * 1000);
                switch (this.searchFilters.lastVisit) {
                    case 'today':
                        if (daysSinceVisit > 1) return false;
                        break;
                    case 'week':
                        if (daysSinceVisit > 7) return false;
                        break;
                    case 'month':
                        if (daysSinceVisit > 30) return false;
                        break;
                    case 'older':
                        if (daysSinceVisit <= 30) return false;
                        break;
                }
            }

            return true;
        });
    }

    // Sort customers by various criteria
    sortCustomers(criteria) {
        const sortedNPCs = [...this.npcs];
        
        switch (criteria) {
            case 'name':
                sortedNPCs.sort((a, b) => a.name.localeCompare(b.name));
                break;
            case 'relationship':
                sortedNPCs.sort((a, b) => b.relationship - a.relationship);
                break;
            case 'lastVisit':
                sortedNPCs.sort((a, b) => b.lastVisit - a.lastVisit);
                break;
            case 'totalSpent':
                sortedNPCs.sort((a, b) => b.totalSpent - a.totalSpent);
                break;
        }

        const window = document.getElementById(this.windowId);
        const grid = window?.querySelector('#customers-grid');
        if (grid) {
            grid.innerHTML = this.renderCustomerCards(sortedNPCs);
        }
    }

    // Save customer notes
    saveNotes() {
        if (!this.selectedNPC) return;

        const window = document.getElementById(this.windowId);
        const notesElement = window?.querySelector('#customer-notes');
        
        if (notesElement) {
            this.selectedNPC.notes = notesElement.textContent;
            // Show saved notification
            workComputer.showNotification('Notes saved successfully', 'success');
        }
    }

    // Debounced search function
    debounceSearch() {
        clearTimeout(this.searchTimeout);
        this.searchTimeout = setTimeout(() => {
            this.applyFilters();
        }, 300);
    }

    // Utility functions
    getRelationshipColor(relationship) {
        if (relationship >= 81) return '#28a745'; // VIP - Green
        if (relationship >= 51) return '#17a2b8'; // Friend - Blue
        if (relationship >= 21) return '#ffc107'; // Regular - Yellow
        return '#6c757d'; // Stranger - Gray
    }

    getRelationshipLabel(relationship) {
        if (relationship >= 81) return 'VIP Customer';
        if (relationship >= 51) return 'Friend';
        if (relationship >= 21) return 'Regular';
        return 'Stranger';
    }

    formatLastVisit(timestamp) {
        const now = Date.now();
        const diff = now - timestamp;
        const days = Math.floor(diff / (24 * 60 * 60 * 1000));
        
        if (days === 0) return 'Today';
        if (days === 1) return 'Yesterday';
        if (days < 7) return `${days} days ago`;
        if (days < 30) return `${Math.floor(days / 7)} weeks ago`;
        return `${Math.floor(days / 30)} months ago`;
    }

    formatDate(timestamp) {
        return new Date(timestamp).toLocaleDateString();
    }

    getInteractionIcon(type) {
        const icons = {
            purchase: 'üõí',
            conversation: 'üí¨',
            complaint: 'üò†',
            compliment: 'üòä',
            note: 'üìù',
            return: '‚Ü©Ô∏è'
        };
        return icons[type] || 'üìã';
    }

    // Generate sample NPC data for testing
    generateSampleNPCs() {
        const archetypes = ['College Student', 'Business Professional', 'Retiree', 'Parent', 'Teenager'];
        const names = [
            'Alex Johnson', 'Sarah Miller', 'Mike Wilson', 'Emma Davis', 'John Smith',
            'Lisa Brown', 'David Garcia', 'Amy Taylor', 'Chris Anderson', 'Jessica White'
        ];
        
        return names.map((name, index) => ({
            id: `npc-${index + 1}`,
            name,
            archetype: archetypes[index % archetypes.length],
            relationship: Math.floor(Math.random() * 100),
            totalSpent: Math.floor(Math.random() * 2000) + 50,
            visitCount: Math.floor(Math.random() * 50) + 1,
            lastVisit: Date.now() - Math.floor(Math.random() * 30) * 24 * 60 * 60 * 1000,
            firstVisit: Date.now() - Math.floor(Math.random() * 365) * 24 * 60 * 60 * 1000,
            avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${name.replace(' ', '')}`,
            favoriteProducts: ['Snacks', 'Beverages', 'Magazines'],
            preferredTimes: ['Morning', 'Evening'],
            preferredPayment: 'Credit Card',
            notes: index % 3 === 0 ? 'Prefers organic products. Very friendly.' : '',
            interactions: this.generateSampleInteractions()
        }));
    }

    generateSampleInteractions() {
        const interactions = [];
        const types = ['purchase', 'conversation', 'complaint', 'compliment'];
        const descriptions = {
            purchase: ['Bought daily essentials', 'Purchased gift items', 'Large grocery shopping'],
            conversation: ['Asked about new products', 'Chatted about weather', 'Discussed store hours'],
            complaint: ['Item was expired', 'Long wait time', 'Price too high'],
            compliment: ['Great customer service', 'Clean store', 'Helpful staff']
        };

        for (let i = 0; i < Math.floor(Math.random() * 5) + 1; i++) {
            const type = types[Math.floor(Math.random() * types.length)];
            const descOptions = descriptions[type];
            
            interactions.push({
                type,
                date: new Date(Date.now() - Math.floor(Math.random() * 30) * 24 * 60 * 60 * 1000).toISOString(),
                description: descOptions[Math.floor(Math.random() * descOptions.length)],
                relationshipChange: type === 'complaint' ? -Math.floor(Math.random() * 5) - 1 : 
                                  type === 'compliment' ? Math.floor(Math.random() * 5) + 1 : 0
            });
        }

        return interactions.sort((a, b) => new Date(b.date) - new Date(a.date));
    }
}

// Create global instance
window.customerRelationsApp = new CustomerRelationsApp();


/* === scripts/workstation/apps/npcApp.js === */
/**
 * NPC Registry App - Work Computer Application for managing NPCs
 * Displays all encountered NPCs, their profiles, and relationship tracking
 */

class NPCApp {
    constructor(appWindow) {
        this.appWindow = appWindow;
        this.gameState = null;
        this.eventBus = null;
        this.npcSystem = null;
        this.currentView = 'overview';
        this.selectedNPC = null;
        this.searchQuery = '';
        this.filterLevel = 'all';
        this.sortBy = 'relationship';
    }

    initialize(gameState, eventBus, npcSystem) {
        this.gameState = gameState;
        this.eventBus = eventBus;
        this.npcSystem = npcSystem;
        
        // Listen for NPC events
        this.eventBus.on('npc.relationshipChanged', () => this.refreshCurrentView());
        this.eventBus.on('npc.enriched', () => this.refreshCurrentView());
        this.eventBus.on('npc.encounterProcessed', () => this.refreshCurrentView());
        
        this.initializeInterface();
    }

    initializeInterface() {
        this.appWindow.setTitle('NPC Registry');
        this.appWindow.setIcon('üë•');
        this.appWindow.setContent(this.renderMainInterface());
        
        // Set up event listeners
        this.setupEventListeners();
    }

    renderMainInterface() {
        return `
            <div class="npc-app">
                <div class="npc-app-header">
                    <div class="npc-app-nav">
                        <button class="nav-btn ${this.currentView === 'overview' ? 'active' : ''}" 
                                data-view="overview">Overview</button>
                        <button class="nav-btn ${this.currentView === 'directory' ? 'active' : ''}" 
                                data-view="directory">Directory</button>
                        <button class="nav-btn ${this.currentView === 'relationships' ? 'active' : ''}" 
                                data-view="relationships">Relationships</button>
                        <button class="nav-btn ${this.currentView === 'analytics' ? 'active' : ''}" 
                                data-view="analytics">Analytics</button>
                    </div>
                    
                    <div class="npc-app-tools">
                        <div class="search-box">
                            <input type="text" id="npc-search" placeholder="Search NPCs..." 
                                   value="${this.searchQuery}">
                            <button id="search-btn">üîç</button>
                        </div>
                        
                        <select id="filter-level" value="${this.filterLevel}">
                            <option value="all">All Levels</option>
                            <option value="stranger">Strangers</option>
                            <option value="regular">Regulars</option>
                            <option value="friend">Friends</option>
                            <option value="vip">VIPs</option>
                        </select>
                    </div>
                </div>
                
                <div class="npc-app-content">
                    ${this.renderCurrentView()}
                </div>
            </div>
        `;
    }

    renderCurrentView() {
        switch (this.currentView) {
            case 'overview':
                return this.renderOverview();
            case 'directory':
                return this.renderDirectory();
            case 'relationships':
                return this.renderRelationships();
            case 'analytics':
                return this.renderAnalytics();
            default:
                return this.renderOverview();
        }
    }

    renderOverview() {
        const registry = this.npcSystem.getNPCRegistry();
        const recentCustomers = this.getRecentCustomers(5);
        const topCustomers = this.getTopCustomers(5);
        
        return `
            <div class="overview-content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number">${registry.total}</div>
                        <div class="stat-label">Total NPCs</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${registry.encountered}</div>
                        <div class="stat-label">Encountered</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${registry.byLevel.friend + registry.byLevel.vip}</div>
                        <div class="stat-label">Friends & VIPs</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${registry.byLevel.regular}</div>
                        <div class="stat-label">Regulars</div>
                    </div>
                </div>
                
                <div class="overview-sections">
                    <div class="section">
                        <h3>üìÖ Recent Customers</h3>
                        <div class="customer-list">
                            ${recentCustomers.map(npc => this.renderNPCCard(npc, 'compact')).join('')}
                        </div>
                    </div>
                    
                    <div class="section">
                        <h3>‚≠ê Top Relationships</h3>
                        <div class="customer-list">
                            ${topCustomers.map(npc => this.renderNPCCard(npc, 'compact')).join('')}
                        </div>
                    </div>
                    
                    <div class="section">
                        <h3>üìä Relationship Breakdown</h3>
                        <div class="relationship-chart">
                            ${this.renderRelationshipChart(registry.byLevel)}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    renderDirectory() {
        const filteredNPCs = this.getFilteredNPCs();
        const sortedNPCs = this.sortNPCs(filteredNPCs);
        
        return `
            <div class="directory-content">
                <div class="directory-header">
                    <div class="directory-controls">
                        <span class="result-count">${sortedNPCs.length} NPCs</span>
                        
                        <select id="sort-by" value="${this.sortBy}">
                            <option value="relationship">By Relationship</option>
                            <option value="name">By Name</option>
                            <option value="lastVisit">By Last Visit</option>
                            <option value="totalSpent">By Total Spent</option>
                            <option value="visitCount">By Visit Count</option>
                        </select>
                    </div>
                </div>
                
                <div class="directory-grid">
                    ${sortedNPCs.map(npc => this.renderNPCCard(npc, 'full')).join('')}
                </div>
            </div>
        `;
    }

    renderRelationships() {
        const relationships = this.npcSystem.getAllNPCs()
            .filter(npc => npc.visitCount > 0)
            .sort((a, b) => b.relationship - a.relationship);
        
        return `
            <div class="relationships-content">
                <div class="relationship-levels">
                    ${this.renderRelationshipLevel('VIP', relationships.filter(npc => npc.relationshipLevel === 'vip'))}
                    ${this.renderRelationshipLevel('Friends', relationships.filter(npc => npc.relationshipLevel === 'friend'))}
                    ${this.renderRelationshipLevel('Regulars', relationships.filter(npc => npc.relationshipLevel === 'regular'))}
                    ${this.renderRelationshipLevel('Strangers', relationships.filter(npc => npc.relationshipLevel === 'stranger'))}
                </div>
            </div>
        `;
    }

    renderAnalytics() {
        const analytics = this.calculateAnalytics();
        
        return `
            <div class="analytics-content">
                <div class="analytics-sections">
                    <div class="section">
                        <h3>üìà Customer Trends</h3>
                        <div class="trend-stats">
                            <div class="trend-item">
                                <span class="trend-label">Average Relationship Score:</span>
                                <span class="trend-value">${analytics.avgRelationship.toFixed(1)}</span>
                            </div>
                            <div class="trend-item">
                                <span class="trend-label">Average Spending per Customer:</span>
                                <span class="trend-value">${analytics.avgSpending.toFixed(2)}</span>
                            </div>
                            <div class="trend-item">
                                <span class="trend-label">Most Common Archetype:</span>
                                <span class="trend-value">${analytics.topArchetype}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="section">
                        <h3>üéØ Relationship Goals</h3>
                        <div class="goals-list">
                            ${this.renderRelationshipGoals(analytics)}
                        </div>
                    </div>
                    
                    <div class="section">
                        <h3>üìä Archetype Distribution</h3>
                        <div class="archetype-chart">
                            ${this.renderArchetypeChart(analytics.archetypeDistribution)}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    renderNPCCard(npc, style = 'full') {
        const relationshipColor = this.getRelationshipColor(npc.relationshipLevel);
        const isCompact = style === 'compact';
        
        return `
            <div class="npc-card ${isCompact ? 'compact' : 'full'}" 
                 data-npc-id="${npc.id}" 
                 onclick="npcApp.selectNPC('${npc.id}')">
                
                <div class="npc-avatar">
                    ${npc.avatar ? 
                        `<img src="${npc.avatar}" alt="${npc.name}" class="avatar-img">` :
                        `<div class="avatar-placeholder">${npc.name.charAt(0)}</div>`
                    }
                    <div class="relationship-badge" style="background: ${relationshipColor}">
                        ${npc.relationship}
                    </div>
                </div>
                
                <div class="npc-info">
                    <div class="npc-name">${npc.name}</div>
                    <div class="npc-details">
                        <span class="npc-archetype">${this.formatArchetype(npc.archetype)}</span>
                        <span class="npc-age">${npc.age}${npc.gender ? ', ' + npc.gender : ''}</span>
                    </div>
                    
                    ${!isCompact ? `
                        <div class="npc-stats">
                            <div class="stat">
                                <span class="stat-label">Visits:</span>
                                <span class="stat-value">${npc.visitCount}</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Spent:</span>
                                <span class="stat-value">${npc.totalSpent.toFixed(2)}</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Level:</span>
                                <span class="stat-value">${this.formatRelationshipLevel(npc.relationshipLevel)}</span>
                            </div>
                        </div>
                        
                        <div class="npc-traits">
                            ${npc.traits.slice(0, 3).map(trait => 
                                `<span class="trait-tag">${this.formatTrait(trait)}</span>`
                            ).join('')}
                        </div>
                    ` : ''}
                </div>
                
                ${npc.visitCount > 0 ? `
                    <div class="npc-status">
                        <div class="last-visit">
                            Last visit: ${this.formatDaysAgo(npc.lastVisit)}
                        </div>
                    </div>
                ` : ''}
            </div>
        `;
    }

    renderRelationshipLevel(levelName, npcs) {
        if (npcs.length === 0) return '';
        
        return `
            <div class="relationship-level-section">
                <h3>${levelName} (${npcs.length})</h3>
                <div class="relationship-list">
                    ${npcs.map(npc => `
                        <div class="relationship-item" onclick="npcApp.selectNPC('${npc.id}')">
                            <div class="relationship-avatar">
                                ${npc.avatar ? 
                                    `<img src="${npc.avatar}" alt="${npc.name}">` :
                                    `<div class="avatar-placeholder">${npc.name.charAt(0)}</div>`
                                }
                            </div>
                            <div class="relationship-info">
                                <div class="relationship-name">${npc.name}</div>
                                <div class="relationship-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${npc.relationship}%"></div>
                                    </div>
                                    <span class="progress-text">${npc.relationship}/100</span>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    renderRelationshipChart(levels) {
        const total = Object.values(levels).reduce((sum, count) => sum + count, 0);
        if (total === 0) return '<div class="no-data">No customer data yet</div>';
        
        return `
            <div class="chart-bars">
                ${Object.entries(levels).map(([level, count]) => {
                    const percentage = (count / total) * 100;
                    const color = this.getRelationshipColor(level);
                    return `
                        <div class="chart-bar">
                            <div class="bar-label">${this.formatRelationshipLevel(level)}</div>
                            <div class="bar-container">
                                <div class="bar-fill" style="width: ${percentage}%; background: ${color}"></div>
                            </div>
                            <div class="bar-value">${count}</div>
                        </div>
                    `;
                }).join('')}
            </div>
        `;
    }

    renderArchetypeChart(distribution) {
        const sortedArchetypes = Object.entries(distribution)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 8);
        
        return `
            <div class="archetype-bars">
                ${sortedArchetypes.map(([archetype, count]) => `
                    <div class="archetype-bar">
                        <div class="archetype-label">${this.formatArchetype(archetype)}</div>
                        <div class="archetype-count">${count}</div>
                    </div>
                `).join('')}
            </div>
        `;
    }

    renderRelationshipGoals(analytics) {
        const goals = [
            {
                title: 'Convert Strangers to Regulars',
                current: analytics.strangers,
                target: Math.max(0, analytics.strangers - 5),
                type: 'decrease'
            },
            {
                title: 'Build Friend Relationships',
                current: analytics.friends,
                target: analytics.friends + 3,
                type: 'increase'
            },
            {
                title: 'Create VIP Customers',
                current: analytics.vips,
                target: Math.max(5, analytics.vips + 2),
                type: 'increase'
            }
        ];
        
        return goals.map(goal => `
            <div class="goal-item">
                <div class="goal-title">${goal.title}</div>
                <div class="goal-progress">
                    <span class="goal-current">${goal.current}</span>
                    <span class="goal-arrow">${goal.type === 'increase' ? '‚Üí' : '‚Üì'}</span>
                    <span class="goal-target">${goal.target}</span>
                </div>
            </div>
        `).join('');
    }

    // Data Processing Methods
    getFilteredNPCs() {
        let npcs = this.npcSystem.getAllNPCs();
        
        // Apply search filter
        if (this.searchQuery) {
            npcs = this.npcSystem.searchNPCs(this.searchQuery);
        }
        
        // Apply level filter
        if (this.filterLevel !== 'all') {
            npcs = npcs.filter(npc => npc.relationshipLevel === this.filterLevel);
        }
        
        return npcs;
    }

    sortNPCs(npcs) {
        return npcs.sort((a, b) => {
            switch (this.sortBy) {
                case 'name':
                    return a.name.localeCompare(b.name);
                case 'lastVisit':
                    return b.lastVisit - a.lastVisit;
                case 'totalSpent':
                    return b.totalSpent - a.totalSpent;
                case 'visitCount':
                    return b.visitCount - a.visitCount;
                case 'relationship':
                default:
                    return b.relationship - a.relationship;
            }
        });
    }

    getRecentCustomers(limit) {
        return this.npcSystem.getAllNPCs()
            .filter(npc => npc.visitCount > 0)
            .sort((a, b) => b.lastInteraction - a.lastInteraction)
            .slice(0, limit);
    }

    getTopCustomers(limit) {
        return this.npcSystem.getAllNPCs()
            .filter(npc => npc.visitCount > 0)
            .sort((a, b) => b.relationship - a.relationship)
            .slice(0, limit);
    }

    calculateAnalytics() {
        const allNPCs = this.npcSystem.getAllNPCs();
        const encounteredNPCs = allNPCs.filter(npc => npc.visitCount > 0);
        
        if (encounteredNPCs.length === 0) {
            return {
                avgRelationship: 0,
                avgSpending: 0,
                topArchetype: 'None',
                archetypeDistribution: {},
                strangers: 0,
                regulars: 0,
                friends: 0,
                vips: 0
            };
        }
        
        const avgRelationship = encounteredNPCs.reduce((sum, npc) => sum + npc.relationship, 0) / encounteredNPCs.length;
        const avgSpending = encounteredNPCs.reduce((sum, npc) => sum + npc.totalSpent, 0) / encounteredNPCs.length;
        
        const archetypeDistribution = {};
        encounteredNPCs.forEach(npc => {
            archetypeDistribution[npc.archetype] = (archetypeDistribution[npc.archetype] || 0) + 1;
        });
        
        const topArchetype = Object.entries(archetypeDistribution)
            .sort((a, b) => b[1] - a[1])[0]?.[0] || 'None';
        
        const levels = {
            strangers: encounteredNPCs.filter(npc => npc.relationshipLevel === 'stranger').length,
            regulars: encounteredNPCs.filter(npc => npc.relationshipLevel === 'regular').length,
            friends: encounteredNPCs.filter(npc => npc.relationshipLevel === 'friend').length,
            vips: encounteredNPCs.filter(npc => npc.relationshipLevel === 'vip').length
        };
        
        return {
            avgRelationship,
            avgSpending,
            topArchetype,
            archetypeDistribution,
            ...levels
        };
    }

    // Event Handlers
    setupEventListeners() {
        this.appWindow.getElement().addEventListener('click', (e) => {
            if (e.target.matches('.nav-btn')) {
                this.switchView(e.target.dataset.view);
            }
        });
        
        this.appWindow.getElement().addEventListener('change', (e) => {
            if (e.target.id === 'filter-level') {
                this.filterLevel = e.target.value;
                this.refreshCurrentView();
            } else if (e.target.id === 'sort-by') {
                this.sortBy = e.target.value;
                this.refreshCurrentView();
            }
        });
        
        this.appWindow.getElement().addEventListener('input', (e) => {
            if (e.target.id === 'npc-search') {
                this.searchQuery = e.target.value;
                this.debounceSearch();
            }
        });
    }

    debounceSearch() {
        clearTimeout(this.searchTimeout);
        this.searchTimeout = setTimeout(() => {
            this.refreshCurrentView();
        }, 300);
    }

    switchView(view) {
        this.currentView = view;
        this.refreshInterface();
    }

    selectNPC(npcId) {
        this.selectedNPC = npcId;
        this.showNPCDetails(npcId);
    }

    showNPCDetails(npcId) {
        const npc = this.npcSystem.getNPC(npcId);
        if (!npc) return;
        
        // Open detailed NPC view (this would be a modal or separate view)
        this.eventBus.emit('ui.showModal', {
            type: 'npcDetails',
            npc: npc
        });
    }

    refreshInterface() {
        this.appWindow.setContent(this.renderMainInterface());
        this.setupEventListeners();
    }

    refreshCurrentView() {
        const contentElement = this.appWindow.getElement().querySelector('.npc-app-content');
        if (contentElement) {
            contentElement.innerHTML = this.renderCurrentView();
        }
    }

    // Utility Methods
    getRelationshipColor(level) {
        const colors = {
            'stranger': '#6b7280',
            'regular': '#3b82f6',
            'friend': '#10b981',
            'vip': '#f59e0b'
        };
        return colors[level] || colors.stranger;
    }

    formatArchetype(archetype) {
        return archetype.split('_').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
    }

    formatRelationshipLevel(level) {
        return level.charAt(0).toUpperCase() + level.slice(1);
    }

    formatTrait(trait) {
        return trait.split('_').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
    }

    formatDaysAgo(dayNumber) {
        const currentDay = this.gameState.data.time.currentDay;
        const daysAgo = currentDay - dayNumber;
        
        if (daysAgo === 0) return 'Today';
        if (daysAgo === 1) return 'Yesterday';
        return `${daysAgo} days ago`;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = NPCApp;
} else if (typeof window !== 'undefined') {
    window.NPCApp = NPCApp;
}


/* === scripts/main.js === */
// Main Application Entry Point
class StoreManagerSimulator {
    constructor() {
        this.initialized = false;
        this.version = '1.0.0';
        
        // Bind methods
        this.init = this.init.bind(this);
        this.start = this.start.bind(this);
        this.handleError = this.handleError.bind(this);
    }

    // Initialize the application
    async init() {
        if (this.initialized) return;

        console.log('üè™ Store Manager Simulator v' + this.version);
        console.log('üöÄ Initializing application...');

        try {
            // Set up global error handling
            this.setupErrorHandling();

            // Show loading screen
            this.showLoadingScreen();

            // Initialize core systems in order
            await this.initializeCoreSystems();

            // Hide loading screen
            this.hideLoadingScreen();

            // Start the game
            await this.start();

            this.initialized = true;
            console.log('‚úÖ Application initialized successfully');

        } catch (error) {
            console.error('‚ùå Failed to initialize application:', error);
            this.handleError(error, 'initialization');
        }
    }

    // Initialize core systems
    async initializeCoreSystems() {
        console.log('‚öôÔ∏è Initializing core systems...');

        // Initialize AI hooks first
        aiHooks.initialize();

        // Initialize game state
        gameState.initialize();

        // Initialize UI manager
        if (typeof uiManager !== 'undefined') {
            uiManager.initialize();
            if (typeof uiManager.wireUIEvents === 'function') {
                uiManager.wireUIEvents();
            }
        }

        // Phase 4C: Initialize Event UI Manager
        if (typeof eventUIManager !== 'undefined') {
            eventUIManager.initialize(gameState, gameEventBus);
            console.log('üé≠ Event UI Manager initialized');
        }

        // Initialize event bus for system communication
        if (typeof gameEventBus !== 'undefined') {
            console.log('üì° Event bus ready');
        }

        // Initialize time system early (needed by other systems)
        if (typeof timeSystem !== 'undefined') {
            timeSystem.initialize();
            console.log('‚è∞ Time system initialized');
        }

        // Initialize NPC system
        if (typeof npcSystem !== 'undefined') {
            npcSystem.initialize(gameState, gameEventBus, aiHooks);
            console.log('üë• NPC system initialized');
        }

        // Initialize Setup Screen Controller so setup buttons are wired
        if (typeof SetupScreenController !== 'undefined') {
            if (!window.setupController) {
                window.setupController = new SetupScreenController();
            }
            try {
                // Initialize CharacterCreation and pass to controller
                if (typeof CharacterCreation !== 'undefined') {
                    window.characterCreation = new CharacterCreation();
                    window.characterCreation.initialize(gameState, gameEventBus, aiHooks);
                }
                window.setupController.initialize(gameState, gameEventBus, window.characterCreation || null, null);
                console.log('üß© SetupScreenController initialized (app-managed path)');
            } catch (e) {
                console.warn('‚ö†Ô∏è Failed to initialize SetupScreenController:', e);
            }
        }

        // Initialize conversation system
        if (typeof conversationSystem !== 'undefined') {
            conversationSystem.initialize(gameState, gameEventBus, aiHooks, npcSystem);
            console.log('üí¨ Conversation system initialized');
        }

        // Phase 4C: Initialize AI Content Manager with all systems
        if (typeof AIContentManager !== 'undefined') {
            window.aiContentManager = new AIContentManager();
            
            const aiSystems = {
                // Phase 4A: NPC AI Enhancement
                npcAIEnhancer: typeof npcAIEnhancer !== 'undefined' ? npcAIEnhancer : null,
                
                // Phase 4B: Product AI Generation
                productAIGenerator: typeof productAIGenerator !== 'undefined' ? productAIGenerator : null,
                
                // Core systems needed by AI
                npcSystem: npcSystem,
                conversationSystem: conversationSystem,
                timeSystem: timeSystem
            };
            
            await window.aiContentManager.initialize(gameState, gameEventBus, aiHooks, aiSystems);
            
            // Enhance existing systems with AI capabilities
            if (conversationSystem && window.aiContentManager.dialogueAI) {
                await window.aiContentManager.enhanceConversationSystem(conversationSystem);
            }
            
            if (npcSystem && window.aiContentManager.npcAIEnhancer) {
                await window.aiContentManager.enhanceNPCSystem(npcSystem);
            }
            
            console.log('ü§ñ AI Content Manager initialized with all Phase 4 systems');
        }

        // Initialize work computer system
        if (typeof WorkComputer !== 'undefined') {
            window.workComputer = new WorkComputer();
            // Wire it to the event bus and game state so UI events work
            if (typeof window.workComputer.initialize === 'function') {
                window.workComputer.initialize(gameEventBus, gameState);
            }
            // Bind container explicitly and power on to desktop
            const desktop = document.getElementById('computer-desktop') || document.getElementById('computer-view');
            if (desktop) {
                window.workComputer.container = desktop;
            }
            window.workComputer.powerOn();
            console.log('üíª Work computer system initialized');
        }

        // Check for existing save data
        const hasExistingSave = this.checkForExistingSave();
        
        if (hasExistingSave) {
            console.log('üíæ Found existing save data');
            // Will handle save loading in game initialization
        } else {
            console.log('üÜï No existing save found - new game');
        }

        console.log('‚úÖ Core systems initialized with Phase 4C AI enhancement');
    }

    // Start the game
    async start() {
        console.log('üéÆ Starting game...');

        // Check if player has completed setup
        const playerData = gameState.getValue('player');
        const isSetupComplete = playerData && playerData.name && playerData.name.trim() !== '';

        if (isSetupComplete) {
            // Go directly to game
            this.startMainGame();
        } else {
            // Show setup screen
            this.startSetup();
        }
    }

    // Start setup process
    startSetup() {
        console.log('üìù Starting setup process...');
        
        gameState.setState(GAME_CONSTANTS.GAME_STATES.SETUP);
        
        if (typeof uiManager !== 'undefined') {
            uiManager.showScreen('setup');
        }

        // Emit setup started event
        gameEventBus.emit('setup:started');
    }

    // Start main game
    async startMainGame() {
        console.log('üè™ Starting main game...');
        
        gameState.setState(GAME_CONSTANTS.GAME_STATES.PLAYING);
        gameState.setView(GAME_CONSTANTS.VIEWS.STORE);
        
        if (typeof uiManager !== 'undefined') {
            uiManager.showScreen('game');
            uiManager.showView('store');
        }

        // Start time system if available
        if (typeof timeSystem !== 'undefined') {
            timeSystem.start();
        }

        // Phase 4C: Test AI systems and start content generation
        if (window.aiContentManager) {
            console.log('üß™ Testing AI systems...');
            
            try {
                const testResults = await window.aiContentManager.testAllSystems();
                console.log('üéØ AI System Test Results:', testResults);
                
                // Display AI system status to player
                if (typeof uiManager !== 'undefined') {
                    const systemStatus = window.aiContentManager.getSystemStatus();
                    uiManager.showNotification(`AI Systems Online: ${Object.values(systemStatus.systems).filter(Boolean).length}/5 systems active`, 'success');
                }
                
            } catch (error) {
                console.warn('‚ö†Ô∏è AI system testing failed:', error);
                if (typeof uiManager !== 'undefined') {
                    uiManager.showNotification('AI systems running with limited functionality', 'warning');
                }
            }
        }

        // Emit game started event
        gameEventBus.emit(GAME_EVENTS.GAME_STARTED);
        
        console.log('üéÆ Main game started with AI enhancement');
    }

    // Show loading screen
    showLoadingScreen() {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.classList.remove('hidden');
        }
    }

    // Hide loading screen
    hideLoadingScreen() {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.classList.add('hidden');
        }
    }

    // Check for existing save data
    checkForExistingSave() {
        try {
            const quicksave = localStorage.getItem('storeManager_quicksave');
            const autosave = localStorage.getItem('storeManager_autosave');
            return !!(quicksave || autosave);
        } catch (error) {
            console.warn('‚ö†Ô∏è Could not check for existing saves:', error);
            return false;
        }
    }

    // Setup global error handling
    setupErrorHandling() {
        // Handle uncaught errors
        window.addEventListener('error', (event) => {
            this.handleError(event.error, 'runtime', event);
        });

        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', (event) => {
            this.handleError(event.reason, 'promise', event);
        });

        console.log('üõ°Ô∏è Error handling setup complete');
    }

    // Handle application errors
    handleError(error, context = 'unknown', event = null) {
        console.error(`‚ùå Error in ${context}:`, error);

        // Log additional event info if available
        if (event) {
            console.error('Event details:', {
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        }

        // Show user-friendly error message
        this.showErrorMessage(error, context);

        // Try to save game state if error occurs during gameplay
        if (context === 'runtime' && gameState.getState() === GAME_CONSTANTS.GAME_STATES.PLAYING) {
            try {
                gameState.save('emergency_save');
                console.log('üíæ Emergency save completed');
            } catch (saveError) {
                console.error('‚ùå Emergency save failed:', saveError);
            }
        }
    }

    // Show error message to user
    showErrorMessage(error, context) {
        // Create error notification if UI manager is available
        if (typeof uiManager !== 'undefined' && uiManager.initialized) {
            uiManager.showNotification(`An error occurred in ${context}. The game has been saved.`, 'error');
        } else {
            // Fallback alert
            alert(`An error occurred: ${error.message || error}. Please refresh the page.`);
        }
    }

    // Pause the game
    pause() {
        if (gameState.getState() === GAME_CONSTANTS.GAME_STATES.PLAYING) {
            gameState.setState(GAME_CONSTANTS.GAME_STATES.PAUSED);
            gameEventBus.emit(GAME_EVENTS.GAME_PAUSED);
            console.log('‚è∏Ô∏è Game paused');
        }
    }

    // Resume the game
    resume() {
        if (gameState.getState() === GAME_CONSTANTS.GAME_STATES.PAUSED) {
            gameState.setState(GAME_CONSTANTS.GAME_STATES.PLAYING);
            gameEventBus.emit(GAME_EVENTS.GAME_RESUMED);
            console.log('‚ñ∂Ô∏è Game resumed');
        }
    }

    // Save and quit
    saveAndQuit() {
        try {
            gameState.save('manual_save');
            console.log('üíæ Game saved before quit');
            
            // Reset to loading state
            gameState.setState(GAME_CONSTANTS.GAME_STATES.LOADING);
            
            // Reload page to fully reset
            window.location.reload();
        } catch (error) {
            console.error('‚ùå Save and quit failed:', error);
            this.handleError(error, 'save-quit');
        }
    }

    // Get application info
    getInfo() {
        return {
            version: this.version,
            initialized: this.initialized,
            gameState: gameState.getState(),
            currentView: gameState.getView(),
            systemsStatus: {
                aiHooks: aiHooks.initialized,
                gameState: gameState.initialized,
                uiManager: typeof uiManager !== 'undefined' ? uiManager.initialized : false
            }
        };
    }
}

// Create global application instance
window.app = new StoreManagerSimulator();

// Auto-initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    console.log('üìÑ DOM loaded, initializing application...');
    window.app.init();
});

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // Page is hidden - auto-save if playing
        if (gameState.getState() === GAME_CONSTANTS.GAME_STATES.PLAYING) {
            gameState.autoSave();
        }
    }
});

// Handle before page unload
window.addEventListener('beforeunload', (event) => {
    // Auto-save before leaving
    if (gameState.getState() === GAME_CONSTANTS.GAME_STATES.PLAYING) {
        gameState.autoSave();
        
        // Show confirmation dialog for unsaved changes
        event.preventDefault();
        event.returnValue = 'Are you sure you want to leave? Your game has been auto-saved.';
        return event.returnValue;
    }
});

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { StoreManagerSimulator, app };
}


/* === Global Exports for Perchance === */
    if (typeof GAME_CONSTANTS !== 'undefined') window.GAME_CONSTANTS = GAME_CONSTANTS;
    if (typeof onceWrapper !== 'undefined') window.onceWrapper = onceWrapper;
    if (typeof gameEventBus !== 'undefined') window.gameEventBus = gameEventBus;
    if (typeof GAME_EVENTS !== 'undefined') window.GAME_EVENTS = GAME_EVENTS;
    if (typeof oldState !== 'undefined') window.oldState = oldState;
    if (typeof oldView !== 'undefined') window.oldView = oldView;
    if (typeof pathArray !== 'undefined') window.pathArray = pathArray;
    if (typeof saveData !== 'undefined') window.saveData = saveData;
    if (typeof importedData !== 'undefined') window.importedData = importedData;
    if (typeof slots !== 'undefined') window.slots = slots;
    if (typeof key !== 'undefined') window.key = key;
    if (typeof slotName !== 'undefined') window.slotName = slotName;
    if (typeof data !== 'undefined') window.data = data;
    if (typeof gameState !== 'undefined') window.gameState = gameState;
    if (typeof cacheKey !== 'undefined') window.cacheKey = cacheKey;
    if (typeof result !== 'undefined') window.result = result;
    if (typeof textResult !== 'undefined') window.textResult = textResult;
    if (typeof productData !== 'undefined') window.productData = productData;
    if (typeof imagePrompt !== 'undefined') window.imagePrompt = imagePrompt;
    if (typeof char !== 'undefined') window.char = char;
    if (typeof aiHooks !== 'undefined') window.aiHooks = aiHooks;
    if (typeof timeData !== 'undefined') window.timeData = timeData;
    if (typeof now !== 'undefined') window.now = now;
    if (typeof deltaTime !== 'undefined') window.deltaTime = deltaTime;
    if (typeof minutesPassed !== 'undefined') window.minutesPassed = minutesPassed;
    if (typeof currentTime !== 'undefined') window.currentTime = currentTime;
    if (typeof newTime !== 'undefined') window.newTime = newTime;
    if (typeof daysToAdd !== 'undefined') window.daysToAdd = daysToAdd;
    if (typeof remainingMinutes !== 'undefined') window.remainingMinutes = remainingMinutes;
    if (typeof storeHours !== 'undefined') window.storeHours = storeHours;
    if (typeof dayName !== 'undefined') window.dayName = dayName;
    if (typeof dayHours !== 'undefined') window.dayHours = dayHours;
    if (typeof currentMinutes !== 'undefined') window.currentMinutes = currentMinutes;
    if (typeof openMinutes !== 'undefined') window.openMinutes = openMinutes;
    if (typeof closeMinutes !== 'undefined') window.closeMinutes = closeMinutes;
    if (typeof wasOpen !== 'undefined') window.wasOpen = wasOpen;
    if (typeof hours !== 'undefined') window.hours = hours;
    if (typeof mins !== 'undefined') window.mins = mins;
    if (typeof days !== 'undefined') window.days = days;
    if (typeof expenses !== 'undefined') window.expenses = expenses;
    if (typeof dailySales !== 'undefined') window.dailySales = dailySales;
    if (typeof dailyExpenses !== 'undefined') window.dailyExpenses = dailyExpenses;
    if (typeof dailyProfit !== 'undefined') window.dailyProfit = dailyProfit;
    if (typeof staff !== 'undefined') window.staff = staff;
    if (typeof weeklyPay !== 'undefined') window.weeklyPay = weeklyPay;
    if (typeof debt !== 'undefined') window.debt = debt;
    if (typeof currentDay !== 'undefined') window.currentDay = currentDay;
    if (typeof monthlyExpenses !== 'undefined') window.monthlyExpenses = monthlyExpenses;
    if (typeof today !== 'undefined') window.today = today;
    if (typeof currentWeek !== 'undefined') window.currentWeek = currentWeek;
    if (typeof currentMonth !== 'undefined') window.currentMonth = currentMonth;
    if (typeof transactions !== 'undefined') window.transactions = transactions;
    if (typeof revenue !== 'undefined') window.revenue = revenue;
    if (typeof archetypeData !== 'undefined') window.archetypeData = archetypeData;
    if (typeof gender !== 'undefined') window.gender = gender;
    if (typeof age !== 'undefined') window.age = age;
    if (typeof spendingPower !== 'undefined') window.spendingPower = spendingPower;
    if (typeof npc !== 'undefined') window.npc = npc;
    if (typeof archetypes !== 'undefined') window.archetypes = archetypes;
    if (typeof roll !== 'undefined') window.roll = roll;
    if (typeof firstName !== 'undefined') window.firstName = firstName;
    if (typeof lastName !== 'undefined') window.lastName = lastName;
    if (typeof roll1 !== 'undefined') window.roll1 = roll1;
    if (typeof roll2 !== 'undefined') window.roll2 = roll2;
    if (typeof normalizedRoll !== 'undefined') window.normalizedRoll = normalizedRoll;
    if (typeof pronounMap !== 'undefined') window.pronounMap = pronounMap;
    if (typeof moods !== 'undefined') window.moods = moods;
    if (typeof poolSize !== 'undefined') window.poolSize = poolSize;
    if (typeof baseEncounters !== 'undefined') window.baseEncounters = baseEncounters;
    if (typeof storeType !== 'undefined') window.storeType = storeType;
    if (typeof environment !== 'undefined') window.environment = environment;
    if (typeof todayEncounters !== 'undefined') window.todayEncounters = todayEncounters;
    if (typeof availableNPCs !== 'undefined') window.availableNPCs = availableNPCs;
    if (typeof regulars !== 'undefined') window.regulars = regulars;
    if (typeof others !== 'undefined') window.others = others;
    if (typeof remainingSlots !== 'undefined') window.remainingSlots = remainingSlots;
    if (typeof randomNPC !== 'undefined') window.randomNPC = randomNPC;
    if (typeof daysSinceLastVisit !== 'undefined') window.daysSinceLastVisit = daysSinceLastVisit;
    if (typeof npcId !== 'undefined') window.npcId = npcId;
    if (typeof archetype !== 'undefined') window.archetype = archetype;
    if (typeof enrichmentText !== 'undefined') window.enrichmentText = enrichmentText;
    if (typeof enrichmentData !== 'undefined') window.enrichmentData = enrichmentData;
    if (typeof avatarPrompt !== 'undefined') window.avatarPrompt = avatarPrompt;
    if (typeof avatarUrl !== 'undefined') window.avatarUrl = avatarUrl;
    if (typeof oldLevel !== 'undefined') window.oldLevel = oldLevel;
    if (typeof newLevel !== 'undefined') window.newLevel = newLevel;
    if (typeof lowerQuery !== 'undefined') window.lowerQuery = lowerQuery;
    if (typeof existingNPC !== 'undefined') window.existingNPC = existingNPC;
    if (typeof imageUrl !== 'undefined') window.imageUrl = imageUrl;
    if (typeof defaultCategories !== 'undefined') window.defaultCategories = defaultCategories;
    if (typeof subcategories !== 'undefined') window.subcategories = subcategories;
    if (typeof defaultProducts !== 'undefined') window.defaultProducts = defaultProducts;
    if (typeof category !== 'undefined') window.category = category;
    if (typeof product !== 'undefined') window.product = product;
    if (typeof searchTerms !== 'undefined') window.searchTerms = searchTerms;
    if (typeof results !== 'undefined') window.results = results;
    if (typeof products !== 'undefined') window.products = products;
    if (typeof targetCategories !== 'undefined') window.targetCategories = targetCategories;
    if (typeof appliedModifiers !== 'undefined') window.appliedModifiers = appliedModifiers;
    if (typeof bulkDiscount !== 'undefined') window.bulkDiscount = bulkDiscount;
    if (typeof applicableDiscount !== 'undefined') window.applicableDiscount = applicableDiscount;
    if (typeof customer !== 'undefined') window.customer = customer;
    if (typeof loyaltyDiscount !== 'undefined') window.loyaltyDiscount = loyaltyDiscount;
    if (typeof tier !== 'undefined') window.tier = tier;
    if (typeof discountAmount !== 'undefined') window.discountAmount = discountAmount;
    if (typeof currentSeason !== 'undefined') window.currentSeason = currentSeason;
    if (typeof seasonalPricing !== 'undefined') window.seasonalPricing = seasonalPricing;
    if (typeof applicableSeasonalRule !== 'undefined') window.applicableSeasonalRule = applicableSeasonalRule;
    if (typeof markupAmount !== 'undefined') window.markupAmount = markupAmount;
    if (typeof clearance !== 'undefined') window.clearance = clearance;
    if (typeof minimumPrice !== 'undefined') window.minimumPrice = minimumPrice;
    if (typeof allProducts !== 'undefined') window.allProducts = allProducts;
    if (typeof month !== 'undefined') window.month = month;
    if (typeof totalRating !== 'undefined') window.totalRating = totalRating;
    if (typeof recommendations !== 'undefined') window.recommendations = recommendations;
    if (typeof preferredCategories !== 'undefined') window.preferredCategories = preferredCategories;
    if (typeof preferredTags !== 'undefined') window.preferredTags = preferredTags;
    if (typeof generatedProduct !== 'undefined') window.generatedProduct = generatedProduct;
    if (typeof aiProducts !== 'undefined') window.aiProducts = aiProducts;
    if (typeof grouped !== 'undefined') window.grouped = grouped;
    if (typeof rarity !== 'undefined') window.rarity = rarity;
    if (typeof timeoutDuration !== 'undefined') window.timeoutDuration = timeoutDuration;
    if (typeof dialogueContext !== 'undefined') window.dialogueContext = dialogueContext;
    if (typeof structuredMessage !== 'undefined') window.structuredMessage = structuredMessage;
    if (typeof aiResponse !== 'undefined') window.aiResponse = aiResponse;
    if (typeof mood !== 'undefined') window.mood = mood;
    if (typeof relationship !== 'undefined') window.relationship = relationship;
    if (typeof conversationHistory !== 'undefined') window.conversationHistory = conversationHistory;
    if (typeof speaker !== 'undefined') window.speaker = speaker;
    if (typeof baseOptions !== 'undefined') window.baseOptions = baseOptions;
    if (typeof scenarioOptions !== 'undefined') window.scenarioOptions = scenarioOptions;
    if (typeof relationshipOptions !== 'undefined') window.relationshipOptions = relationshipOptions;
    if (typeof options !== 'undefined') window.options = options;
    if (typeof selectedOption !== 'undefined') window.selectedOption = selectedOption;
    if (typeof impact !== 'undefined') window.impact = impact;
    if (typeof lowerText !== 'undefined') window.lowerText = lowerText;
    if (typeof baseImpact !== 'undefined') window.baseImpact = baseImpact;
    if (typeof message !== 'undefined') window.message = message;
    if (typeof conversation !== 'undefined') window.conversation = conversation;
    if (typeof duration !== 'undefined') window.duration = duration;
    if (typeof finalSatisfaction !== 'undefined') window.finalSatisfaction = finalSatisfaction;
    if (typeof idealTurns !== 'undefined') window.idealTurns = idealTurns;
    if (typeof actualTurns !== 'undefined') window.actualTurns = actualTurns;
    if (typeof emotionKeywords !== 'undefined') window.emotionKeywords = emotionKeywords;
    if (typeof textLower !== 'undefined') window.textLower = textLower;
    if (typeof personalityEmotions !== 'undefined') window.personalityEmotions = personalityEmotions;
    if (typeof templates !== 'undefined') window.templates = templates;
    if (typeof response !== 'undefined') window.response = response;
    if (typeof existingIndex !== 'undefined') window.existingIndex = existingIndex;
    if (typeof cartItem !== 'undefined') window.cartItem = cartItem;
    if (typeof itemIndex !== 'undefined') window.itemIndex = itemIndex;
    if (typeof transaction !== 'undefined') window.transaction = transaction;
    if (typeof taxableAmount !== 'undefined') window.taxableAmount = taxableAmount;
    if (typeof employeeDiscount !== 'undefined') window.employeeDiscount = employeeDiscount;
    if (typeof subtotal !== 'undefined') window.subtotal = subtotal;
    if (typeof cart !== 'undefined') window.cart = cart;
    if (typeof totalItems !== 'undefined') window.totalItems = totalItems;
    if (typeof upsellItems !== 'undefined') window.upsellItems = upsellItems;
    if (typeof suggestions !== 'undefined') window.suggestions = suggestions;
    if (typeof success !== 'undefined') window.success = success;
    if (typeof acceptedItems !== 'undefined') window.acceptedItems = acceptedItems;
    if (typeof paymentResult !== 'undefined') window.paymentResult = paymentResult;
    if (typeof method !== 'undefined') window.method = method;
    if (typeof amount !== 'undefined') window.amount = amount;
    if (typeof finances !== 'undefined') window.finances = finances;
    if (typeof screenElements !== 'undefined') window.screenElements = screenElements;
    if (typeof viewElements !== 'undefined') window.viewElements = viewElements;
    if (typeof computerBtn !== 'undefined') window.computerBtn = computerBtn;
    if (typeof pauseBtn !== 'undefined') window.pauseBtn = pauseBtn;
    if (typeof endConversationBtn !== 'undefined') window.endConversationBtn = endConversationBtn;
    if (typeof targetScreen !== 'undefined') window.targetScreen = targetScreen;
    if (typeof targetView !== 'undefined') window.targetView = targetView;
    if (typeof modalId !== 'undefined') window.modalId = modalId;
    if (typeof modal !== 'undefined') window.modal = modal;
    if (typeof closeBtn !== 'undefined') window.closeBtn = closeBtn;
    if (typeof overlay !== 'undefined') window.overlay = overlay;
    if (typeof closeModal !== 'undefined') window.closeModal = closeModal;
    if (typeof notificationId !== 'undefined') window.notificationId = notificationId;
    if (typeof notification !== 'undefined') window.notification = notification;
    if (typeof icon !== 'undefined') window.icon = icon;
    if (typeof icons !== 'undefined') window.icons = icons;
    if (typeof notificationIndex !== 'undefined') window.notificationIndex = notificationIndex;
    if (typeof lastModal !== 'undefined') window.lastModal = lastModal;
    if (typeof cashElement !== 'undefined') window.cashElement = cashElement;
    if (typeof timeElement !== 'undefined') window.timeElement = timeElement;
    if (typeof storeNameElement !== 'undefined') window.storeNameElement = storeNameElement;
    if (typeof uiManager !== 'undefined') window.uiManager = uiManager;
    if (typeof customInput !== 'undefined') window.customInput = customInput;
    if (typeof sendButton !== 'undefined') window.sendButton = sendButton;
    if (typeof messageHistory !== 'undefined') window.messageHistory = messageHistory;
    if (typeof avatar !== 'undefined') window.avatar = avatar;
    if (typeof relationshipBadge !== 'undefined') window.relationshipBadge = relationshipBadge;
    if (typeof moodIndicator !== 'undefined') window.moodIndicator = moodIndicator;
    if (typeof meter !== 'undefined') window.meter = meter;
    if (typeof fill !== 'undefined') window.fill = fill;
    if (typeof text !== 'undefined') window.text = text;
    if (typeof messageElement !== 'undefined') window.messageElement = messageElement;
    if (typeof time !== 'undefined') window.time = time;
    if (typeof systemElement !== 'undefined') window.systemElement = systemElement;
    if (typeof indicator !== 'undefined') window.indicator = indicator;
    if (typeof container !== 'undefined') window.container = container;
    if (typeof button !== 'undefined') window.button = button;
    if (typeof input !== 'undefined') window.input = input;
    if (typeof buttonsContainer !== 'undefined') window.buttonsContainer = buttonsContainer;
    if (typeof feedback !== 'undefined') window.feedback = feedback;
    if (typeof customerInfo !== 'undefined') window.customerInfo = customerInfo;
    if (typeof levels !== 'undefined') window.levels = levels;
    if (typeof div !== 'undefined') window.div = div;
    if (typeof phases !== 'undefined') window.phases = phases;
    if (typeof currentIndex !== 'undefined') window.currentIndex = currentIndex;
    if (typeof progress !== 'undefined') window.progress = progress;
    if (typeof isFirst !== 'undefined') window.isFirst = isFirst;
    if (typeof isLast !== 'undefined') window.isLast = isLast;
    if (typeof adultContent !== 'undefined') window.adultContent = adultContent;
    if (typeof difficulty !== 'undefined') window.difficulty = difficulty;
    if (typeof warning !== 'undefined') window.warning = warning;
    if (typeof difficultySettings !== 'undefined') window.difficultySettings = difficultySettings;
    if (typeof settings !== 'undefined') window.settings = settings;
    if (typeof nextPhase !== 'undefined') window.nextPhase = nextPhase;
    if (typeof prevPhase !== 'undefined') window.prevPhase = prevPhase;
    if (typeof stepElements !== 'undefined') window.stepElements = stepElements;
    if (typeof character !== 'undefined') window.character = character;
    if (typeof store !== 'undefined') window.store = store;
    if (typeof summary !== 'undefined') window.summary = summary;
    if (typeof role !== 'undefined') window.role = role;
    if (typeof jobPosting !== 'undefined') window.jobPosting = jobPosting;
    if (typeof applicationCount !== 'undefined') window.applicationCount = applicationCount;
    if (typeof reputation !== 'undefined') window.reputation = reputation;
    if (typeof delay !== 'undefined') window.delay = delay;
    if (typeof applicant !== 'undefined') window.applicant = applicant;
    if (typeof application !== 'undefined') window.application = application;
    if (typeof baseNPC !== 'undefined') window.baseNPC = baseNPC;
    if (typeof archetypesByRole !== 'undefined') window.archetypesByRole = archetypesByRole;
    if (typeof experience !== 'undefined') window.experience = experience;
    if (typeof experienceLevel !== 'undefined') window.experienceLevel = experienceLevel;
    if (typeof allSkills !== 'undefined') window.allSkills = allSkills;
    if (typeof requiredSkills !== 'undefined') window.requiredSkills = requiredSkills;
    if (typeof additionalSkills !== 'undefined') window.additionalSkills = additionalSkills;
    if (typeof skills !== 'undefined') window.skills = skills;
    if (typeof additionalCount !== 'undefined') window.additionalCount = additionalCount;
    if (typeof skill !== 'undefined') window.skill = skill;
    if (typeof requirements !== 'undefined') window.requirements = requirements;
    if (typeof proficiency !== 'undefined') window.proficiency = proficiency;
    if (typeof averageSkills !== 'undefined') window.averageSkills = averageSkills;
    if (typeof requiredPersonality !== 'undefined') window.requiredPersonality = requiredPersonality;
    if (typeof commonQuestions !== 'undefined') window.commonQuestions = commonQuestions;
    if (typeof roleSpecificQuestions !== 'undefined') window.roleSpecificQuestions = roleSpecificQuestions;
    if (typeof allQuestions !== 'undefined') window.allQuestions = allQuestions;
    if (typeof selectedQuestions !== 'undefined') window.selectedQuestions = selectedQuestions;
    if (typeof questionCount !== 'undefined') window.questionCount = questionCount;
    if (typeof questionIndex !== 'undefined') window.questionIndex = questionIndex;
    if (typeof question !== 'undefined') window.question = question;
    if (typeof questionsByRole !== 'undefined') window.questionsByRole = questionsByRole;
    if (typeof interviewScore !== 'undefined') window.interviewScore = interviewScore;
    if (typeof confidence !== 'undefined') window.confidence = confidence;
    if (typeof enthusiasm !== 'undefined') window.enthusiasm = enthusiasm;
    if (typeof honesty !== 'undefined') window.honesty = honesty;
    if (typeof nervousness !== 'undefined') window.nervousness = nervousness;
    if (typeof basePerformance !== 'undefined') window.basePerformance = basePerformance;
    if (typeof nervousnessReduction !== 'undefined') window.nervousnessReduction = nervousnessReduction;
    if (typeof responseQuality !== 'undefined') window.responseQuality = responseQuality;
    if (typeof positiveWords !== 'undefined') window.positiveWords = positiveWords;
    if (typeof jobOffer !== 'undefined') window.jobOffer = jobOffer;
    if (typeof offer !== 'undefined') window.offer = offer;
    if (typeof salaryRatio !== 'undefined') window.salaryRatio = salaryRatio;
    if (typeof accepted !== 'undefined') window.accepted = accepted;
    if (typeof reasons !== 'undefined') window.reasons = reasons;
    if (typeof employee !== 'undefined') window.employee = employee;
    if (typeof trainingByRole !== 'undefined') window.trainingByRole = trainingByRole;
    if (typeof metrics !== 'undefined') window.metrics = metrics;
    if (typeof openPositions !== 'undefined') window.openPositions = openPositions;
    if (typeof pendingApplications !== 'undefined') window.pendingApplications = pendingApplications;
    if (typeof tabs !== 'undefined') window.tabs = tabs;
    if (typeof jobRoles !== 'undefined') window.jobRoles = jobRoles;
    if (typeof recentApplications !== 'undefined') window.recentApplications = recentApplications;
    if (typeof hasOpenPosition !== 'undefined') window.hasOpenPosition = hasOpenPosition;
    if (typeof currentEmployees !== 'undefined') window.currentEmployees = currentEmployees;
    if (typeof timeAgo !== 'undefined') window.timeAgo = timeAgo;
    if (typeof postedTime !== 'undefined') window.postedTime = postedTime;
    if (typeof applications !== 'undefined') window.applications = applications;
    if (typeof statuses !== 'undefined') window.statuses = statuses;
    if (typeof roles !== 'undefined') window.roles = roles;
    if (typeof scheduledInterviews !== 'undefined') window.scheduledInterviews = scheduledInterviews;
    if (typeof completedInterviews !== 'undefined') window.completedInterviews = completedInterviews;
    if (typeof interview !== 'undefined') window.interview = interview;
    if (typeof scheduleTime !== 'undefined') window.scheduleTime = scheduleTime;
    if (typeof completedTime !== 'undefined') window.completedTime = completedTime;
    if (typeof employees !== 'undefined') window.employees = employees;
    if (typeof hireDate !== 'undefined') window.hireDate = hireDate;
    if (typeof performance !== 'undefined') window.performance = performance;
    if (typeof mainContent !== 'undefined') window.mainContent = mainContent;
    if (typeof availableRoles !== 'undefined') window.availableRoles = availableRoles;
    if (typeof modalContent !== 'undefined') window.modalContent = modalContent;
    if (typeof roleId !== 'undefined') window.roleId = roleId;
    if (typeof urgency !== 'undefined') window.urgency = urgency;
    if (typeof salaryOffer !== 'undefined') window.salaryOffer = salaryOffer;
    if (typeof jobData !== 'undefined') window.jobData = jobData;
    if (typeof diff !== 'undefined') window.diff = diff;
    if (typeof minutes !== 'undefined') window.minutes = minutes;
    if (typeof statusMap !== 'undefined') window.statusMap = statusMap;
    if (typeof educationMap !== 'undefined') window.educationMap = educationMap;
    if (typeof schedule !== 'undefined') window.schedule = schedule;
    if (typeof availableEmployees !== 'undefined') window.availableEmployees = availableEmployees;
    if (typeof dayDate !== 'undefined') window.dayDate = dayDate;
    if (typeof dayShifts !== 'undefined') window.dayShifts = dayShifts;
    if (typeof dayOfWeek !== 'undefined') window.dayOfWeek = dayOfWeek;
    if (typeof isWeekend !== 'undefined') window.isWeekend = isWeekend;
    if (typeof shifts !== 'undefined') window.shifts = shifts;
    if (typeof shift !== 'undefined') window.shift = shift;
    if (typeof totalPositions !== 'undefined') window.totalPositions = totalPositions;
    if (typeof sortedShifts !== 'undefined') window.sortedShifts = sortedShifts;
    if (typeof priorityOrder !== 'undefined') window.priorityOrder = priorityOrder;
    if (typeof assignments !== 'undefined') window.assignments = assignments;
    if (typeof roleNeeds !== 'undefined') window.roleNeeds = roleNeeds;
    if (typeof compatibleEmployees !== 'undefined') window.compatibleEmployees = compatibleEmployees;
    if (typeof rankedEmployees !== 'undefined') window.rankedEmployees = rankedEmployees;
    if (typeof preferredRole !== 'undefined') window.preferredRole = preferredRole;
    if (typeof assignment !== 'undefined') window.assignment = assignment;
    if (typeof shiftStart !== 'undefined') window.shiftStart = shiftStart;
    if (typeof shiftEnd !== 'undefined') window.shiftEnd = shiftEnd;
    if (typeof shiftPeriod !== 'undefined') window.shiftPeriod = shiftPeriod;
    if (typeof weeklyHours !== 'undefined') window.weeklyHours = weeklyHours;
    if (typeof employeeRole !== 'undefined') window.employeeRole = employeeRole;
    if (typeof shiftRoles !== 'undefined') window.shiftRoles = shiftRoles;
    if (typeof matchingSkills !== 'undefined') window.matchingSkills = matchingSkills;
    if (typeof review !== 'undefined') window.review = review;
    if (typeof baseScore !== 'undefined') window.baseScore = baseScore;
    if (typeof transactionSpeed !== 'undefined') window.transactionSpeed = transactionSpeed;
    if (typeof accuracy !== 'undefined') window.accuracy = accuracy;
    if (typeof upsellSuccess !== 'undefined') window.upsellSuccess = upsellSuccess;
    if (typeof stockingSpeed !== 'undefined') window.stockingSpeed = stockingSpeed;
    if (typeof organization !== 'undefined') window.organization = organization;
    if (typeof vigilance !== 'undefined') window.vigilance = vigilance;
    if (typeof incidentResponse !== 'undefined') window.incidentResponse = incidentResponse;
    if (typeof preventionEffectiveness !== 'undefined') window.preventionEffectiveness = preventionEffectiveness;
    if (typeof program !== 'undefined') window.program = program;
    if (typeof training !== 'undefined') window.training = training;
    if (typeof effectiveness !== 'undefined') window.effectiveness = effectiveness;
    if (typeof currentLevel !== 'undefined') window.currentLevel = currentLevel;
    if (typeof improvedLevel !== 'undefined') window.improvedLevel = improvedLevel;
    if (typeof performanceBoost !== 'undefined') window.performanceBoost = performanceBoost;
    if (typeof recentTraining !== 'undefined') window.recentTraining = recentTraining;
    if (typeof individualMorale !== 'undefined') window.individualMorale = individualMorale;
    if (typeof averageMorale !== 'undefined') window.averageMorale = averageMorale;
    if (typeof hour !== 'undefined') window.hour = hour;
    if (typeof schedules !== 'undefined') window.schedules = schedules;
    if (typeof weekStart !== 'undefined') window.weekStart = weekStart;
    if (typeof teamMetrics !== 'undefined') window.teamMetrics = teamMetrics;
    if (typeof activeShifts !== 'undefined') window.activeShifts = activeShifts;
    if (typeof recentReviews !== 'undefined') window.recentReviews = recentReviews;
    if (typeof upcomingTraining !== 'undefined') window.upcomingTraining = upcomingTraining;
    if (typeof todayShifts !== 'undefined') window.todayShifts = todayShifts;
    if (typeof shiftTemplates !== 'undefined') window.shiftTemplates = shiftTemplates;
    if (typeof day !== 'undefined') window.day = day;
    if (typeof trainingPrograms !== 'undefined') window.trainingPrograms = trainingPrograms;
    if (typeof activeTraining !== 'undefined') window.activeTraining = activeTraining;
    if (typeof status !== 'undefined') window.status = status;
    if (typeof activeShiftElements !== 'undefined') window.activeShiftElements = activeShiftElements;
    if (typeof shiftDate !== 'undefined') window.shiftDate = shiftDate;
    if (typeof weekEnd !== 'undefined') window.weekEnd = weekEnd;
    if (typeof activeAutomations !== 'undefined') window.activeAutomations = activeAutomations;
    if (typeof inactiveAutomations !== 'undefined') window.inactiveAutomations = inactiveAutomations;
    if (typeof automatedSystems !== 'undefined') window.automatedSystems = automatedSystems;
    if (typeof qualityMap !== 'undefined') window.qualityMap = qualityMap;
    if (typeof totalCosts !== 'undefined') window.totalCosts = totalCosts;
    if (typeof analysis !== 'undefined') window.analysis = analysis;
    if (typeof marketData !== 'undefined') window.marketData = marketData;
    if (typeof customerBehavior !== 'undefined') window.customerBehavior = customerBehavior;
    if (typeof staffAnalysis !== 'undefined') window.staffAnalysis = staffAnalysis;
    if (typeof financialHealth !== 'undefined') window.financialHealth = financialHealth;
    if (typeof demandForecast !== 'undefined') window.demandForecast = demandForecast;
    if (typeof cashFlow !== 'undefined') window.cashFlow = cashFlow;
    if (typeof forecast !== 'undefined') window.forecast = forecast;
    if (typeof marketConditions !== 'undefined') window.marketConditions = marketConditions;
    if (typeof customerSatisfaction !== 'undefined') window.customerSatisfaction = customerSatisfaction;
    if (typeof operationalData !== 'undefined') window.operationalData = operationalData;
    if (typeof totalConfidence !== 'undefined') window.totalConfidence = totalConfidence;
    if (typeof storeAnalysis !== 'undefined') window.storeAnalysis = storeAnalysis;
    if (typeof insights !== 'undefined') window.insights = insights;
    if (typeof alerts !== 'undefined') window.alerts = alerts;
    if (typeof decision !== 'undefined') window.decision = decision;
    if (typeof learningRate !== 'undefined') window.learningRate = learningRate;
    if (typeof escalationFactors !== 'undefined') window.escalationFactors = escalationFactors;
    if (typeof escalationScore !== 'undefined') window.escalationScore = escalationScore;
    if (typeof maxConcurrent !== 'undefined') window.maxConcurrent = maxConcurrent;
    if (typeof processing !== 'undefined') window.processing = processing;
    if (typeof nextTransaction !== 'undefined') window.nextTransaction = nextTransaction;
    if (typeof conversationStep !== 'undefined') window.conversationStep = conversationStep;
    if (typeof tax !== 'undefined') window.tax = tax;
    if (typeof total !== 'undefined') window.total = total;
    if (typeof paymentMethods !== 'undefined') window.paymentMethods = paymentMethods;
    if (typeof selectedMethod !== 'undefined') window.selectedMethod = selectedMethod;
    if (typeof processingTime !== 'undefined') window.processingTime = processingTime;
    if (typeof times !== 'undefined') window.times = times;
    if (typeof satisfaction !== 'undefined') window.satisfaction = satisfaction;
    if (typeof expectedDuration !== 'undefined') window.expectedDuration = expectedDuration;
    if (typeof totalTime !== 'undefined') window.totalTime = totalTime;
    if (typeof satisfactionSum !== 'undefined') window.satisfactionSum = satisfactionSum;
    if (typeof recentTransactions !== 'undefined') window.recentTransactions = recentTransactions;
    if (typeof errors !== 'undefined') window.errors = errors;
    if (typeof inventory !== 'undefined') window.inventory = inventory;
    if (typeof restockNeeded !== 'undefined') window.restockNeeded = restockNeeded;
    if (typeof orderQuantity !== 'undefined') window.orderQuantity = orderQuantity;
    if (typeof daysUntilStockout !== 'undefined') window.daysUntilStockout = daysUntilStockout;
    if (typeof dailyDemand !== 'undefined') window.dailyDemand = dailyDemand;
    if (typeof demandPeriod !== 'undefined') window.demandPeriod = demandPeriod;
    if (typeof orderingCost !== 'undefined') window.orderingCost = orderingCost;
    if (typeof holdingCostRate !== 'undefined') window.holdingCostRate = holdingCostRate;
    if (typeof annualDemand !== 'undefined') window.annualDemand = annualDemand;
    if (typeof holdingCost !== 'undefined') window.holdingCost = holdingCost;
    if (typeof seasonalFactor !== 'undefined') window.seasonalFactor = seasonalFactor;
    if (typeof stockRatio !== 'undefined') window.stockRatio = stockRatio;
    if (typeof urgencyPriority !== 'undefined') window.urgencyPriority = urgencyPriority;
    if (typeof successfulOrders !== 'undefined') window.successfulOrders = successfulOrders;
    if (typeof orderCost !== 'undefined') window.orderCost = orderCost;
    if (typeof orderDetails !== 'undefined') window.orderDetails = orderDetails;
    if (typeof orderId !== 'undefined') window.orderId = orderId;
    if (typeof deliveryDate !== 'undefined') window.deliveryDate = deliveryDate;
    if (typeof historicalData !== 'undefined') window.historicalData = historicalData;
    if (typeof recentSales !== 'undefined') window.recentSales = recentSales;
    if (typeof averageDailySales !== 'undefined') window.averageDailySales = averageDailySales;
    if (typeof earlyAvg !== 'undefined') window.earlyAvg = earlyAvg;
    if (typeof lateAvg !== 'undefined') window.lateAvg = lateAvg;
    if (typeof trendMultiplier !== 'undefined') window.trendMultiplier = trendMultiplier;
    if (typeof forecastDemand !== 'undefined') window.forecastDemand = forecastDemand;
    if (typeof salesHistory !== 'undefined') window.salesHistory = salesHistory;
    if (typeof hourlyPattern !== 'undefined') window.hourlyPattern = hourlyPattern;
    if (typeof weeklyPattern !== 'undefined') window.weeklyPattern = weeklyPattern;
    if (typeof hourlyData !== 'undefined') window.hourlyData = hourlyData;
    if (typeof weeklyData !== 'undefined') window.weeklyData = weeklyData;
    if (typeof seasonalFactors !== 'undefined') window.seasonalFactors = seasonalFactors;
    if (typeof daysBack !== 'undefined') window.daysBack = daysBack;
    if (typeof date !== 'undefined') window.date = date;
    if (typeof baseSales !== 'undefined') window.baseSales = baseSales;
    if (typeof salesAmount !== 'undefined') window.salesAmount = salesAmount;
    if (typeof quantity !== 'undefined') window.quantity = quantity;
    if (typeof availableSystems !== 'undefined') window.availableSystems = availableSystems;
    if (typeof isActive !== 'undefined') window.isActive = isActive;
    if (typeof aiReport !== 'undefined') window.aiReport = aiReport;
    if (typeof numericValue !== 'undefined') window.numericValue = numericValue;
    if (typeof names !== 'undefined') window.names = names;
    if (typeof perfElements !== 'undefined') window.perfElements = perfElements;
    if (typeof computerView !== 'undefined') window.computerView = computerView;
    if (typeof runningApps !== 'undefined') window.runningApps = runningApps;
    if (typeof currentFocused !== 'undefined') window.currentFocused = currentFocused;
    if (typeof nextIndex !== 'undefined') window.nextIndex = nextIndex;
    if (typeof nextApp !== 'undefined') window.nextApp = nextApp;
    if (typeof hasStaff !== 'undefined') window.hasStaff = hasStaff;
    if (typeof contentElement !== 'undefined') window.contentElement = contentElement;
    if (typeof bootMessages !== 'undefined') window.bootMessages = bootMessages;
    if (typeof bootInterval !== 'undefined') window.bootInterval = bootInterval;
    if (typeof bootMessagesEl !== 'undefined') window.bootMessagesEl = bootMessagesEl;
    if (typeof progressEl !== 'undefined') window.progressEl = progressEl;
    if (typeof statusEl !== 'undefined') window.statusEl = statusEl;
    if (typeof app !== 'undefined') window.app = app;
    if (typeof existingWindow !== 'undefined') window.existingWindow = existingWindow;
    if (typeof windowIndex !== 'undefined') window.windowIndex = windowIndex;
    if (typeof minIndex !== 'undefined') window.minIndex = minIndex;
    if (typeof maxZ !== 'undefined') window.maxZ = maxZ;
    if (typeof startMenu !== 'undefined') window.startMenu = startMenu;
    if (typeof clockEl !== 'undefined') window.clockEl = clockEl;
    if (typeof windowConfig !== 'undefined') window.windowConfig = windowConfig;
    if (typeof totalCustomers !== 'undefined') window.totalCustomers = totalCustomers;
    if (typeof vips !== 'undefined') window.vips = vips;
    if (typeof recentVisitors !== 'undefined') window.recentVisitors = recentVisitors;
    if (typeof npcsToShow !== 'undefined') window.npcsToShow = npcsToShow;
    if (typeof interactions !== 'undefined') window.interactions = interactions;
    if (typeof allInteractions !== 'undefined') window.allInteractions = allInteractions;
    if (typeof categoryNames !== 'undefined') window.categoryNames = categoryNames;
    if (typeof typeNames !== 'undefined') window.typeNames = typeNames;
    if (typeof view !== 'undefined') window.view = view;
    if (typeof customerId !== 'undefined') window.customerId = customerId;
    if (typeof searchInput !== 'undefined') window.searchInput = searchInput;
    if (typeof sortSelect !== 'undefined') window.sortSelect = sortSelect;
    if (typeof content !== 'undefined') window.content = content;
    if (typeof note !== 'undefined') window.note = note;
    if (typeof filtered !== 'undefined') window.filtered = filtered;
    if (typeof resultsGrid !== 'undefined') window.resultsGrid = resultsGrid;
    if (typeof resultsCount !== 'undefined') window.resultsCount = resultsCount;
    if (typeof daysSinceVisit !== 'undefined') window.daysSinceVisit = daysSinceVisit;
    if (typeof sortedNPCs !== 'undefined') window.sortedNPCs = sortedNPCs;
    if (typeof grid !== 'undefined') window.grid = grid;
    if (typeof notesElement !== 'undefined') window.notesElement = notesElement;
    if (typeof types !== 'undefined') window.types = types;
    if (typeof descriptions !== 'undefined') window.descriptions = descriptions;
    if (typeof type !== 'undefined') window.type = type;
    if (typeof descOptions !== 'undefined') window.descOptions = descOptions;
    if (typeof registry !== 'undefined') window.registry = registry;
    if (typeof recentCustomers !== 'undefined') window.recentCustomers = recentCustomers;
    if (typeof topCustomers !== 'undefined') window.topCustomers = topCustomers;
    if (typeof filteredNPCs !== 'undefined') window.filteredNPCs = filteredNPCs;
    if (typeof relationships !== 'undefined') window.relationships = relationships;
    if (typeof analytics !== 'undefined') window.analytics = analytics;
    if (typeof relationshipColor !== 'undefined') window.relationshipColor = relationshipColor;
    if (typeof isCompact !== 'undefined') window.isCompact = isCompact;
    if (typeof percentage !== 'undefined') window.percentage = percentage;
    if (typeof color !== 'undefined') window.color = color;
    if (typeof sortedArchetypes !== 'undefined') window.sortedArchetypes = sortedArchetypes;
    if (typeof goals !== 'undefined') window.goals = goals;
    if (typeof allNPCs !== 'undefined') window.allNPCs = allNPCs;
    if (typeof encounteredNPCs !== 'undefined') window.encounteredNPCs = encounteredNPCs;
    if (typeof avgRelationship !== 'undefined') window.avgRelationship = avgRelationship;
    if (typeof avgSpending !== 'undefined') window.avgSpending = avgSpending;
    if (typeof archetypeDistribution !== 'undefined') window.archetypeDistribution = archetypeDistribution;
    if (typeof topArchetype !== 'undefined') window.topArchetype = topArchetype;
    if (typeof colors !== 'undefined') window.colors = colors;
    if (typeof daysAgo !== 'undefined') window.daysAgo = daysAgo;
    if (typeof aiSystems !== 'undefined') window.aiSystems = aiSystems;
    if (typeof hasExistingSave !== 'undefined') window.hasExistingSave = hasExistingSave;
    if (typeof playerData !== 'undefined') window.playerData = playerData;
    if (typeof isSetupComplete !== 'undefined') window.isSetupComplete = isSetupComplete;
    if (typeof testResults !== 'undefined') window.testResults = testResults;
    if (typeof systemStatus !== 'undefined') window.systemStatus = systemStatus;
    if (typeof loadingScreen !== 'undefined') window.loadingScreen = loadingScreen;
    if (typeof quicksave !== 'undefined') window.quicksave = quicksave;
    if (typeof autosave !== 'undefined') window.autosave = autosave;
    if (typeof EventBus !== 'undefined') window.EventBus = EventBus;
    if (typeof GameState !== 'undefined') window.GameState = GameState;
    if (typeof AIHooks !== 'undefined') window.AIHooks = AIHooks;
    if (typeof TimeSystem !== 'undefined') window.TimeSystem = TimeSystem;
    if (typeof NPCSystem !== 'undefined') window.NPCSystem = NPCSystem;
    if (typeof ProductSystem !== 'undefined') window.ProductSystem = ProductSystem;
    if (typeof ConversationSystem !== 'undefined') window.ConversationSystem = ConversationSystem;
    if (typeof CheckoutSystem !== 'undefined') window.CheckoutSystem = CheckoutSystem;
    if (typeof UIManager !== 'undefined') window.UIManager = UIManager;
    if (typeof from !== 'undefined') window.from = from;
    if (typeof DialogueComponent !== 'undefined') window.DialogueComponent = DialogueComponent;
    if (typeof SetupScreenController !== 'undefined') window.SetupScreenController = SetupScreenController;
    if (typeof StaffHiringSystem !== 'undefined') window.StaffHiringSystem = StaffHiringSystem;
    if (typeof StaffHiringInterface !== 'undefined') window.StaffHiringInterface = StaffHiringInterface;
    if (typeof StaffManagementSystem !== 'undefined') window.StaffManagementSystem = StaffManagementSystem;
    if (typeof StaffManagementInterface !== 'undefined') window.StaffManagementInterface = StaffManagementInterface;
    if (typeof AutomationSystem !== 'undefined') window.AutomationSystem = AutomationSystem;
    if (typeof AIAssistantManager !== 'undefined') window.AIAssistantManager = AIAssistantManager;
    if (typeof CustomerBehaviorAnalyzer !== 'undefined') window.CustomerBehaviorAnalyzer = CustomerBehaviorAnalyzer;
    if (typeof MarketTrendAnalyzer !== 'undefined') window.MarketTrendAnalyzer = MarketTrendAnalyzer;
    if (typeof FinancialHealthAnalyzer !== 'undefined') window.FinancialHealthAnalyzer = FinancialHealthAnalyzer;
    if (typeof StaffPerformanceAnalyzer !== 'undefined') window.StaffPerformanceAnalyzer = StaffPerformanceAnalyzer;
    if (typeof OperationalEfficiencyAnalyzer !== 'undefined') window.OperationalEfficiencyAnalyzer = OperationalEfficiencyAnalyzer;
    if (typeof AutomatedCashierSystem !== 'undefined') window.AutomatedCashierSystem = AutomatedCashierSystem;
    if (typeof AutomatedInventorySystem !== 'undefined') window.AutomatedInventorySystem = AutomatedInventorySystem;
    if (typeof AutomationInterface !== 'undefined') window.AutomationInterface = AutomationInterface;
    if (typeof WorkComputer !== 'undefined') window.WorkComputer = WorkComputer;
    if (typeof CustomerRelationsApp !== 'undefined') window.CustomerRelationsApp = CustomerRelationsApp;
    if (typeof NPCApp !== 'undefined') window.NPCApp = NPCApp;
    if (typeof StoreManagerSimulator !== 'undefined') window.StoreManagerSimulator = StoreManagerSimulator;
    if (typeof onceWrapper !== 'undefined') window.onceWrapper = onceWrapper;
    if (typeof closeModal !== 'undefined') window.closeModal = closeModal;
    if (typeof debounceSearch !== 'undefined') window.debounceSearch = debounceSearch;

    console.log("üåê Global exports complete for Perchance compatibility");

    
    /* === Game Initialization === */
    function initializeGame() {
        // Defer to StoreManagerSimulator bootstrap if present
        if (window.app && typeof window.app.init === 'function') {
            console.log('Skipping legacy initializeGame; app-managed init is active.');
            return;
        }
        if (window.gameInitialized) {
            console.log('‚ö†Ô∏è Game already initialized, skipping...');
            return;
        }
        
        console.log('üöÄ === STORE MANAGER SIMULATOR INITIALIZATION ===');
        console.log('Document ready state:', document.readyState);
        console.log('Available classes check:');
        console.log('- EventBus:', typeof EventBus);
        console.log('- GameState:', typeof GameState);
        console.log('- UIManager:', typeof UIManager);
        console.log('- StoreManagerSimulator:', typeof StoreManagerSimulator);
        console.log('- SetupScreenController:', typeof SetupScreenController);
        
        try {
            // Mark as initialized
            window.gameInitialized = true;
            
            // Ensure only one screen is visible at a time
            console.log('üîÑ Managing screen visibility...');
            hideAllScreens();
            
            // Check available DOM elements
            console.log('üîç Checking DOM elements...');
            console.log('- setup-screen:', !!document.getElementById('setup-screen'));
            console.log('- game-interface:', !!document.getElementById('game-interface'));
            console.log('- loading-screen:', !!document.getElementById('loading-screen'));
            console.log('- newGameButton:', !!document.getElementById('newGameButton'));
            console.log('- loadGameButton:', !!document.getElementById('loadGameButton'));
            
            // Initialize core systems
            if (typeof EventBus !== 'undefined') {
                window.eventBus = new EventBus();
                console.log('‚úÖ Event bus initialized');
            } else {
                console.log('‚ö†Ô∏è EventBus not available');
            }
            
            if (typeof GameState !== 'undefined') {
                window.gameState = new GameState();
                console.log('‚úÖ Game state initialized');
            } else {
                console.log('‚ö†Ô∏è GameState not available');
            }
            
            if (typeof UIManager !== 'undefined') {
                window.uiManager = new UIManager();
                console.log('‚úÖ UI manager initialized');
            } else {
                console.log('‚ö†Ô∏è UIManager not available');
            }
            
            // Start the main application
            if (typeof StoreManagerSimulator !== 'undefined') {
                console.log('üéÆ Starting StoreManagerSimulator...');
                window.app = new StoreManagerSimulator();
                window.app.init();
                console.log('‚úÖ Application started');
            } else {
                console.log('‚ö†Ô∏è StoreManagerSimulator not available, showing setup screen');
                // Fallback: show setup screen
                showSetupScreen();
            }
            
        } catch (error) {
            console.error('‚ùå Failed to initialize game:', error);
            console.error('Error stack:', error.stack);
            // Fallback: show setup screen
            console.log('üîÑ Falling back to setup screen...');
            showSetupScreen();
        }
        
        console.log('üöÄ === INITIALIZATION COMPLETE ===');
    }
    
    function hideAllScreens() {
        console.log('üîÑ === HIDING ALL SCREENS ===');
        const screens = document.querySelectorAll('.screen');
        console.log('Found screens:', screens.length);
        
        screens.forEach((screen, index) => {
            console.log(`Screen ${index}: ${screen.id}, currently hidden: ${screen.classList.contains('hidden')}`);
            screen.classList.add('hidden');
            screen.style.display = 'none';
            console.log(`Screen ${index}: ${screen.id} - HIDDEN`);
        });
        
        console.log('üîÑ === ALL SCREENS HIDDEN ===');
    }
    
    function showSetupScreen() {
        console.log('üìù === SHOWING SETUP SCREEN ===');
        hideAllScreens();
        
        const setupScreen = document.getElementById('setup-screen');
        if (setupScreen) {
            console.log('‚úÖ Found setup screen:', setupScreen);
            setupScreen.classList.remove('hidden');
            setupScreen.style.display = 'flex';
            setupScreen.style.alignItems = 'center';
            setupScreen.style.justifyContent = 'center';
            console.log('‚úÖ Setup screen classes and styles applied');
            console.log('Setup screen display:', window.getComputedStyle(setupScreen).display);
            console.log('Setup screen visibility:', window.getComputedStyle(setupScreen).visibility);
            
            // Initialize setup screen controller
            initializeSetupScreen();
        } else {
            console.error('‚ùå Setup screen element NOT FOUND');
        }
        console.log('üìù === SETUP SCREEN SHOW COMPLETE ===');
    }
    
    function initializeSetupScreen() {
        console.log('‚öôÔ∏è === INITIALIZING SETUP SCREEN ===');
        
        try {
            // Create and initialize setup screen controller
            if (typeof SetupScreenController !== 'undefined') {
                console.log('‚úÖ SetupScreenController class found');
                window.setupController = new SetupScreenController();
                
                // Initialize with minimal dependencies
                const mockGameState = window.gameState || { 
                    initializeNewGame: () => console.log('üéÆ Mock: New game initialized'),
                    data: { meta: {} }
                };
                const mockEventBus = window.eventBus || {
                    emit: (event, data) => console.log('üì° Event:', event, data),
                    on: (event, handler) => console.log('üì° Listening for:', event)
                };
                // Initialize CharacterCreation if available
                if (typeof CharacterCreation !== 'undefined' && !window.characterCreation) {
                    window.characterCreation = new CharacterCreation();
                    window.characterCreation.initialize(mockGameState, mockEventBus, window.aiHooks);
                }
                window.setupController.initialize(mockGameState, mockEventBus, window.characterCreation || null, null);
                console.log('‚úÖ Setup screen controller initialized');
                
                // Bind buttons with multiple retry attempts
                attemptButtonBinding();
            } else {
                console.log('‚ö†Ô∏è SetupScreenController not found, using fallback');
                // Fallback: manually bind button events
                attemptButtonBinding();
            }
        } catch (error) {
            console.error('‚ùå Failed to initialize setup controller:', error);
            // Fallback: manually bind button events
            attemptButtonBinding();
        }
        
        console.log('‚öôÔ∏è === SETUP SCREEN INITIALIZATION COMPLETE ===');
    }
    
    function attemptButtonBinding(retryCount = 0) {
        console.log(`üîó Attempting button binding (attempt ${retryCount + 1}/5)...`);
        
        const success = bindSetupButtons();
        
        if (!success && retryCount < 4) {
            console.log(`‚ö†Ô∏è Button binding failed, retrying in ${(retryCount + 1) * 100}ms...`);
            setTimeout(() => attemptButtonBinding(retryCount + 1), (retryCount + 1) * 100);
        } else if (!success) {
            console.error('‚ùå Button binding failed after all attempts');
        }
    }
    
    function bindSetupButtons() {
        console.log('üîß Starting button binding process...');
        let success = true;
        
        // Bind New Game button
        const newGameBtn = document.getElementById('newGameButton');
        if (newGameBtn) {
            console.log('‚úÖ Found New Game button:', newGameBtn);
            
            // Remove any existing listeners first
            const newButton = newGameBtn.cloneNode(true);
            newGameBtn.parentNode.replaceChild(newButton, newGameBtn);
            
            newButton.addEventListener('click', (e) => {
                console.log('üéÆ NEW GAME BUTTON CLICKED!');
                console.log('Event:', e);
                e.preventDefault();
                e.stopPropagation();
                startNewGameFlow();
            });
            console.log('‚úÖ New Game button event listener attached');
        } else {
            console.error('‚ùå New Game button NOT FOUND');
            success = false;
        }
        
        // Bind Load Game button  
        const loadGameBtn = document.getElementById('loadGameButton');
        if (loadGameBtn) {
            console.log('‚úÖ Found Load Game button:', loadGameBtn);
            
            // Remove any existing listeners first
            const newLoadButton = loadGameBtn.cloneNode(true);
            loadGameBtn.parentNode.replaceChild(newLoadButton, loadGameBtn);
            
            newLoadButton.addEventListener('click', (e) => {
                console.log('üíæ LOAD GAME BUTTON CLICKED!');
                console.log('Event:', e);
                e.preventDefault();
                e.stopPropagation();
                startLoadGameFlow();
            });
            console.log('‚úÖ Load Game button event listener attached');
        } else {
            console.error('‚ùå Load Game button NOT FOUND');
            success = false;
        }
        
        // Bind adult content toggle
        const adultToggle = document.getElementById('adultContentToggle');
        if (adultToggle) {
            console.log('‚úÖ Found Adult Content toggle:', adultToggle);
            adultToggle.addEventListener('change', (e) => {
                console.log('üîû ADULT CONTENT TOGGLED:', e.target.checked);
            });
            console.log('‚úÖ Adult content toggle event listener attached');
        } else {
            console.error('‚ùå Adult content toggle NOT FOUND');
        }
        
        console.log('üîß Button binding process complete, success:', success);
        return success;
    }
    
    function startNewGameFlow() {
        console.log('üöÄ === START NEW GAME FLOW ===');
        console.log('Current screens before hiding:');
        document.querySelectorAll('.screen').forEach(screen => {
            console.log('Screen:', screen.id, 'Hidden:', screen.classList.contains('hidden'), 'Display:', window.getComputedStyle(screen).display);
        });
        
        // Hide setup screen and start game
        console.log('üîÑ Hiding all screens...');
        hideAllScreens();
        
        console.log('Screens after hiding:');
        document.querySelectorAll('.screen').forEach(screen => {
            console.log('Screen:', screen.id, 'Hidden:', screen.classList.contains('hidden'), 'Display:', window.getComputedStyle(screen).display);
        });
        
        // Show game interface
        console.log('üéÆ Looking for game interface...');
        const gameInterface = document.getElementById('game-interface');
        if (gameInterface) {
            console.log('‚úÖ Found game interface:', gameInterface);
            gameInterface.classList.remove('hidden');
            gameInterface.style.display = 'block';
            console.log('‚úÖ Game interface shown');
            
            // Show store view by default
            const storeView = document.getElementById('store-view');
            if (storeView) {
                console.log('‚úÖ Found store view:', storeView);
                storeView.classList.add('active');
                storeView.style.display = 'block';
                console.log('‚úÖ Store view activated');
            } else {
                console.error('‚ùå Store view NOT FOUND');
            }
            
            console.log('üè™ Game started - showing store view');
        } else {
            console.log('‚ùå Game interface not found, creating fallback...');
            // Create a simple game started message
            const fallbackHTML = `
                <div id="game-started-screen" style="display: flex !important; align-items: center !important; justify-content: center !important; 
                     height: 100vh !important; width: 100vw !important; position: fixed !important; top: 0 !important; left: 0 !important;
                     background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important; color: white !important; 
                     font-family: 'Segoe UI', sans-serif !important; text-align: center !important; z-index: 2000 !important;">
                    <div>
                        <h1 style="font-size: 3rem !important; margin-bottom: 1rem !important;">üè™ Store Manager Simulator</h1>
                        <h2 style="font-size: 2rem !important; margin-bottom: 1rem !important;">Game Started Successfully!</h2>
                        <p style="font-size: 1.2rem !important; margin-bottom: 0.5rem !important;">Phase 5C Automation Systems: Online</p>
                        <p style="font-size: 1.2rem !important; margin-bottom: 2rem !important;">Your store is ready for business!</p>
                        <button onclick="console.log('üîÑ Restart clicked'); location.reload();" 
                                style="background: #4CAF50 !important; color: white !important; border: none !important; 
                                       padding: 15px 30px !important; font-size: 1.1rem !important; border-radius: 10px !important; 
                                       cursor: pointer !important; box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3) !important;">
                            üîÑ Restart Demo
                        </button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', fallbackHTML);
            console.log('‚úÖ Fallback game started screen created');
        }
        
        console.log('üöÄ === END NEW GAME FLOW ===');
    }
    
    function startLoadGameFlow() {
        console.log('üíæ === START LOAD GAME FLOW ===');
        alert('Load Game functionality will be implemented in a future update!');
        console.log('üíæ Load game alert displayed');
        console.log('üíæ === END LOAD GAME FLOW ===');
    }
    
    function hideLoadingScreen() {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.classList.add('hidden');
            console.log('üö´ Loading screen hidden');
        }
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üìÑ DOM loaded, initializing application...');
            setTimeout(initializeGame, 500); // Longer delay to ensure all elements are rendered
        });
    } else {
        console.log('üìÑ DOM already loaded, initializing application...');
        setTimeout(initializeGame, 500);
    }
    
    // Also try after window load as backup
    window.addEventListener('load', () => {
        console.log('üåê Window fully loaded');
        // Only initialize if not already done
        if (!window.gameInitialized) {
            console.log('üîÑ Backup initialization...');
            setTimeout(initializeGame, 100);
        }
    });

    // Expose minimal global fallbacks for Perchance inline handlers
    window.__startNewGame = () => {
        try {
            if (window.setupController && typeof window.setupController.startNewGame === 'function') {
                window.setupController.startNewGame();
            } else {
                startNewGameFlow();
            }
        } catch (e) {
            console.error('Failed to start new game via fallback:', e);
            startNewGameFlow();
        }
    };
    window.__loadGame = () => {
        try {
            if (window.setupController && typeof window.setupController.loadGame === 'function') {
                window.setupController.loadGame();
            } else {
                startLoadGameFlow();
            }
        } catch (e) {
            console.error('Failed to load game via fallback:', e);
            startLoadGameFlow();
        }
    };
    window.__startPlaying = () => {
        try {
            if (window.setupController && typeof window.setupController.startGame === 'function') {
                window.setupController.startGame();
            } else {
                // Fallback: mimic startNewGameFlow end-state
                startNewGameFlow();
            }
        } catch (e) {
            console.error('Failed to start playing via fallback:', e);
            startNewGameFlow();
        }
    };
    
})();

/* For this version of the game, I would like to stamp character creation as Complete *Stamp Noise*.

Now it is time to move on to Store Creation.

We will be pre-loading 4 - 5 different store types.
No matter what store you have, you start out with a max of 3 products you can sell (This can be upgraded later)

Players will have the following Creation options:
Store Type (Premade 6 options including two "Adult" themed stores if NSFW is enabled)
Store Name
Starting Difficulty (sets debt amount and repayment rates for later, as well as crime-rates, accident rates (messes to clean up))
Products (Max 3 at creation) Auto-loaded for our premade store types
Store Location (City, Suburban, Rural, Fantasy)

Before we start coding can you think of any improvements to this creation layout? */


    </script>
</body>
</html>


